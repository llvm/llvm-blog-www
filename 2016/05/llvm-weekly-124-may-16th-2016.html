<!doctype html><html lang=en><head><title>LLVM Weekly - #124, May 16th 2016 - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Alex Bradbury"><meta property="og:url" content="https://blog.llvm.org/2016/05/llvm-weekly-124-may-16th-2016.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="LLVM Weekly - #124, May 16th 2016"><meta property="og:description" content="Welcome to the one hundred and twenty-fourth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects. LLVM Weekly is brought to you by Alex Bradbury."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-05-16T04:26:00+00:00"><meta property="article:modified_time" content="2016-05-16T04:26:00+00:00"><meta property="article:tag" content="Llvmweekly"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM Weekly - #124, May 16th 2016"><meta name=twitter:description content="Welcome to the one hundred and twenty-fourth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects. LLVM Weekly is brought to you by Alex Bradbury."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>LLVM Weekly - #124, May 16th 2016</h1><aside><ul><li>By Alex Bradbury</li><li><time class=post-date datetime=2016-05-16T04:26:00Z>May 16, 2016</time></li><li><em><a href=https://blog.llvm.org/tags/llvmweekly>#llvmweekly</a></em></li><li>5 minute read</li></ul></aside><p>Welcome to the one hundred and twenty-fourth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects. LLVM Weekly is brought to you by <a href=http://asbradbury.org>Alex Bradbury</a>. Subscribe to future issues at <a href=http://llvmweekly.org>http://llvmweekly.org</a> and pass it on to anyone else you think may be interested. Please send any tips or feedback to <a href=mailto:asb@asbradbury.org>asb@asbradbury.org</a>, or <a href=https://twitter.com/llvmweekly>@llvmweekly</a> or <a href=https://twitter.com/asbradbury>@asbradbury</a> on Twitter.</p><p>The canonical home for this issue <a href=http://llvmweekly.org/issue/124>can be found here at llvmweekly.org</a>.</p><a name=more></a><h3>News and articles from around the web</h3><p>The main news this week is the announcement of <a href=http://www.scala-native.org/>Scala-native</a>, an ahead-of-time compiler for Scala using LLVM. Jos Dirkens has written a <a href=http://www.smartjava.org/content/getting-started-scala-native>getting started guide</a> if you want to compile it and try it out. There's also more information in the <a href=https://github.com/densh/talks/blob/master/2016-05-11-scala-goes-native.pdf>slides from the announcement talk</a>.</p><h3>On the mailing lists</h3><ul><li><p>More of the students taking part in Google Summer of Code with LLVM-related projects have introduced themselves and their plans. Vivek Pandya will be working on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099492.html>interprocedural register allocation</a>. Scott Egerton will be working on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099704.html>capture tracking improvements</a>. Jie Chen will be working on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099573.html>better alias analysis, specifically improving cfl-aa</a>. Matthias Reisinger will be working on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099471.html>enabling polyhedral optimisations in Julia</a>, and Zhengyan Liu has plans for <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099600.html>SAFECode memory hardening</a>.</p></li><li><p>Renato Golin kicked off a discussion about <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099541.html>whether LLVM's release process could be better aligned with downstream users</a>. This thread covered a broad range of topics and triggered a lot of discussion, but luckily there's no need to summarise it as Renato has <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099706.html>done the job for us</a>.</p></li><li><p>Nicolai HÃ¤hnle notes that currently libLLVM.so <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099398.html>contains about 1.7MB in its .data.rel.ro section</a>, of which about 1.3MB comes from the MCInstrDesc tables created by tablegen representing a massive number of pointers to be relocated. He suggests reducing this by using offsets instead. Reducing the relocations will both reduce binary size and increase the portion of the binary that can be mapped as shared. So far, responses to the thread are supportive of the idea.</p></li><li><p>James Knight has written a detailed post on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099490.html>how it's not really possible to write an LL/SC loop guaranteed to make forward progress in LLVM IR right now</a>. There are restrictions on what you can do between a load-linked and a store-conditional instruction that the code generator may not meet.</p></li><li><p>A public <a href=http://lists.llvm.org/cgi-bin/mailman/listinfo/llvm-foundation>llvm-foundation</a> mailing list has been <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099574.html>announced</a>, which to facilitate discussions related to the Foundation.</p></li><li><p>As well as the long, technically detailed and precise threads each week it's nice to highlight cases where a simple question has a simple answer. How do you register a pass as being opt-in based on a command-line flag? <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099470.html>Answer</a>: have it run every time, but return immediately if the desired command line flag isn't present.</p></li><li><p>Sanjoy Das has shared an RFC on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099693.html>adding a callee-saved register verifier</a>. As is clarified later in the thread, the intention is to ensure that code not generated by LLVM (e.g. output from another JIT or hand-written assembly) properly adheres to the calling convention and doesn't clobber registers it shouldn't. The proposed pass would simply add code to check that the test values written to the callee-saved registers aren't modified.</p></li><li><p>In response to questions about pass ordering, Mehdi Amini has written a helpful description of <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099477.html>what exactly happens when you do opt -mymodulepass0 -myfunctionpass -mymodulepass1</a>.</p></li><li><p>Konstantin Vladimirov wonders <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099494.html>if there's an option to force the register allocator to use as many architectural registers as possible to reduce dependencies</a>. The short answer is there isn't currently, but it would be interesting to investigate.</p></li><li><p>Diana Picus has shared an RFC on <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-May/099594.html>modifying llc so it no longer exits after the first error</a>. Generally people are in favour, and the patch should hopefully land soon (it had to be temporarily backed out after exposing some test cases failures in lldb).</p></li><li><p>Nico Weber has noted that now with AVX512, <a href=http://lists.llvm.org/pipermail/cfe-dev/2016-May/048837.html>Clang's intrinsics headers are huge</a>. This can cause compile time issues, for instance Nico reports building all of the v8 JS engine is 6% faster after removing the avx512 includes. The thread participants haven't yet decided on the best way forward to fix this, beyond the potential immediate step of adding include guards so AVX512 intrinsic headers aren't included when not compiling for AVX512 platforms.</p></li></ul><h3>LLVM commits</h3><ul><li><p>The outdated guide on cross-compiling LLVM has been brought up to date. <a href=http://reviews.llvm.org/rL269054>r269054</a>.</p></li><li><p>The WebAssembly backend gained preliminary fast instruction selection (fast-isel) support. <a href=http://reviews.llvm.org/rL269083>r269083</a>, <a href=http://reviews.llvm.org/rL269203>r269203</a>, <a href=http://reviews.llvm.org/rL269273>r269273</a>.</p></li><li><p>Loop unrolling (other than in the case of explicit pragmas) is now disabled at <code>-Os</code> in LLVM. You may recall last week it was enabled for <code>-Os</code> in Clang, but with different thresholds. <a href=http://reviews.llvm.org/rL269124>r269124</a>.</p></li><li><p>A new cost-tracking system has been implemented for the loop unroller. <a href=http://reviews.llvm.org/rL269388>r269388</a>.</p></li><li><p>LLVM's Sparc backend has seen the addition of more LEON-specific features, e.g. signed and unsigned multiply-accumulate. <a href=http://reviews.llvm.org/rL268908>r268908</a>.</p></li><li><p>llc's <code>-run-pass</code> option will now work with any pass known to the pass registry. Previously it would silently do nothing if you specify indirectly added analysis passes or passes not present in the optimisation pipeline. <a href=http://reviews.llvm.org/rL269003>r269003</a>.</p></li><li><p>WebAssembly register stackification and coloring are now run very late in the optimisation pipeline. The commit message suggests it's useful to think of these passes as domain-specific liveness-based compression rather than a conventional optimisation. <a href=http://reviews.llvm.org/rL269012>r269012</a>.</p></li><li><p>When declaring global in textual LLVM IR, you must now assign them with e.g. <code>@0 = global i32 42</code>. <a href=http://reviews.llvm.org/rL269096>r269096</a>.</p></li><li><p>The internal assembler is now enabled by default for 32-bit MIPS targets. <a href=http://reviews.llvm.org/rL269560>r269560</a>.</p></li></ul><h3>Clang commits</h3><ul><li><p>Clang now supports <code>__float128</code>. <a href=http://reviews.llvm.org/rL268898>r268898</a>.</p></li><li><p>Clang gained a new warning that triggers when casting away calling conventions from a function. <a href=http://reviews.llvm.org/rL269116>r269116</a>.</p></li><li><p>The recently developed include-fixer tools now has documentation. <a href=http://reviews.llvm.org/rL269167>r269167</a>.</p></li></ul><h3>Other project commits</h3><ul><li><p>compiler-rt's CMake build system can now build builtins without a full toolchain, allowing you to bootstrap a cross-compiler. <a href=http://reviews.llvm.org/rL268977>r268977</a>.</p></li><li><p>LLD will now sort relocations to optimise dynamic linker performance. <a href=http://reviews.llvm.org/rL269066>r269066</a>.</p></li></ul></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2016/05/llvm-weekly-123-may-9th-2016.html><i class="fa fa-chevron-circle-left"></i> LLVM Weekly - #123, May 9th 2016</a></li><li><a href=https://blog.llvm.org/2016/05/llvm-weekly-125-may-23rd-2016.html>LLVM Weekly - #125, May 23rd 2016 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>