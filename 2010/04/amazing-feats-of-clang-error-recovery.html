<!doctype html><html lang=en>
<head>
<title>Amazing feats of Clang Error Recovery - The LLVM Project Blog</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="LLVM Project News and Details from the Trenches">
<meta name=author content="Chris Lattner"><meta property="og:title" content="Amazing feats of Clang Error Recovery">
<meta property="og:description" content="In addition to parsing and generating machine code for your source files when valid, a compiler frontend's job is also to detect invalid code and give you a hint that explains what is wrong so you can fix the problem.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.llvm.org/2010/04/amazing-feats-of-clang-error-recovery.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2010-04-05T23:20:00+00:00">
<meta property="article:modified_time" content="2010-04-05T23:20:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Amazing feats of Clang Error Recovery">
<meta name=twitter:description content="In addition to parsing and generating machine code for your source files when valid, a compiler frontend's job is also to detect invalid code and give you a hint that explains what is wrong so you can fix the problem.">
<meta name=generator content="Hugo 0.89.4">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://blog.llvm.org/>The LLVM Project Blog</a>
</h1>
<ul id=social-media>
<li>
<a href=https://www.facebook.com/llvmorg title=Facebook>
<i class="fab fa-facebook fa-lg"></i>
</a>
</li>
<li>
<a href=https://github.com/llvm title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/llvmorg title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://www.youtube.com/c/LLVMPROJ title=Youtube>
<i class="fab fa-youtube fa-lg"></i>
</a>
</li>
</ul>
<p><em>LLVM Project News and Details from the Trenches</em></p>
</header>
<nav>
<ul>
<li>
<a href=https://blog.llvm.org/about>
<i class="fa-li fa fa-lg"></i><span>About</span>
</a>
</li>
<li>
<a href=https://blog.llvm.org/posts>
<i class="fa-li fa fa-lg"></i><span>Posts</span>
</a>
</li>
<li>
<a href=https://blog.llvm.org/tags>
<i class="fa-li fa fa-lg"></i><span>Tags</span>
</a>
</li>
<li>
<a href=https://llvm.org/>
<i class="fa-li fa fa-lg"></i><span>llvm.org</span>
</a>
</li>
</ul>
</nav>
<main>
<article>
<h1>Amazing feats of Clang Error Recovery</h1>
<aside>
<ul>
<li>
<time class=post-date datetime=2010-04-05T23:20:00Z>Apr 5, 2010</time>
</li>
<li>
<em>
<a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a>
</em>
</li>
<li>13 minute read</li>
</ul>
</aside>
In addition to parsing and generating machine code for your source files when valid, a compiler frontend's job is also to detect invalid code and give you a hint that explains what is wrong so you can fix the problem. The bug could either be straight-up invalid (an error) or could just be something that is legal but looks really dubious (a warning). These errors and warnings are known as compiler 'diagnostics', and Clang aims to go above and beyond the call of duty to provide a really amazing experience.<br><br>After the break, we show some examples of areas where Clang tries particularly hard. For other examples, the Clang web page also has <a href=http://clang.llvm.org/diagnostics.html>a page on diagnostics</a> and Doug showed how Clang diagnoses two-phase name lookup issues in <a href=http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html>a prior blog post</a>.<br><br><b>Update</b>: Other people are starting to compare their favorite compiler. Here's the <a href=http://labs.hoffmanlabs.com/node/1540>OpenVMS Compiler</a>. Email Chris if you have a comparison you want posted.<br><br><a href=http://softdroid.net/udivitelnye-tryuki-vosstanovleniya-oshibok-clang>Секреты восстановления (Russian Translation)</a>&nbsp;<span style=font-family:helvetica;font-size:12px>&nbsp;provided by&nbsp;</span><a href=http://softdroid.net/ style=font-family:Helvetica;font-size:12px>Softdroid Recovery</a><span style=font-family:helvetica><span style=font-size:12px>.</span></span><br><span style=font-family:helvetica><span style=font-size:12px><a href=http://www.opensourceinitiative.net/edu/llvm/ target=_blank>Ukrainian Translation</a>&nbsp;provided by&nbsp;Sandi Wolfe.</span></span><br><span style=font-family:helvetica><span style=font-size:12px><a href=https://www.autonvaraosatpro.fi/blogi/2018/04/23/hammastav-feats-ukskoik-error-recovery/ rel=nofollow target=_blank>Estonian Translation</a> provided by Johanne Teerink.</span></span><br><span style=font-family:helvetica><span style=font-size:12px><a href=https://studhilfe.de/translations/#Amazing-feats-of-Clang-Error-Recovery:DE>German Translation</a> provided by&nbsp;</span></span><span style=font-family:helvetica><span style=font-size:12px>Philip Egger.</span></span><br><span style=font-family:helvetica><span style=font-size:12px><a href=http://expereb.com/amazing-feats-of-clang-error-recovery/>Spanish Translation</a> provided by&nbsp;</span></span><span style=font-family:helvetica><span style=font-size:12px>Laura Mancini</span></span><br><span style=font-family:helvetica><span style=font-size:12px><br></span></span><br><br><a name=more></a><br><br>These examples use Apple GCC 4.2 as a comparison on these examples, but this isn't meant to bash (an old version of) GCC. Many compilers have these sorts of issues and we strongly encourage you to try the examples on your favorite compiler to see how it does. The examples all shown are necessarily small (reduced) examples that demonstrate a problem, when you see these in real life, they are often much more convincing :).<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=unknown_typenames>Unknown Typenames</a></h2><br>One annoying thing about parsing C and C++ is that you have to know what is a typename in order to parse the code. For example "(x)(y)" can be either a cast of the expression "(y)" to type "x" or it could be a call of the "x" function with the "(y)" argument list, depending on whether x is a type or not. Unfortunately, a common mistake is to forget to include a header file, which means that the compiler really has no idea whether something is a type or not, and therefore has to make a strongly educated guess based on context. Here are a couple examples:<br><br><pre>$ <b>cat t.m</b><br>NSString *P = @"foo";<br>$ <b>clang t.m</b><br>t.m:4:1: error: unknown type name 'NSString'<br>NSString *P = @"foo";<br>^<br>$ <b>gcc t.m</b><br>t.m:4: error: expected '=', ',', ';', 'asm' or '__attribute__' before '*' token<br></pre><br>and:<br><br><pre>$ <b>cat t.c</b><br>int foo(int x, pid_t y) {<br>  return x+y;<br>}<br>$ <b>clang t.c</b><br>t.c:1:16: error: unknown type name 'pid_t'<br>int foo(int x, pid_t y) {<br>               ^<br>$ <b>gcc t.c</b><br>t.c:1: error: expected declaration specifiers or '...' before 'pid_t'<br>t.c: In function 'foo':<br>t.c:2: error: 'y' undeclared (first use in this function)<br>t.c:2: error: (Each undeclared identifier is reported only once<br>t.c:2: error: for each function it appears in.)<br></pre><br>This sort of thing also happens in C if you forget to use 'struct stat' instead of 'stat'. As is a common theme in this post, recovering well by inferring what the programmer meant helps Clang avoid emitting bogus follow-on errors like the three lines GCC emits on line 2. <br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=spell_checker>Spell Checker</a></h2><br>One of the <a href=http://zi.fi/shots/clang.png>more visible</a> things that Clang includes is a spell checker (also <a href=http://www.reddit.com/r/programming/comments/b8ws6/why_you_should_use_clang/>on reddit</a>). The spell checker kicks in when you use an identifier that Clang doesn't know: it checks against other close identifiers and suggests what you probably meant. Here are a few examples:<br><br><pre>$ <b>cat t.c</b><br>#include &lt;inttypes.h&gt;<br>int64 x;<br>$ <b>clang t.c</b><br>t.c:2:1: error: unknown type name 'int64'; did you mean 'int64_t'?<br>int64 x;<br>^~~~~<br>int64_t<br>$ <b>gcc t.c</b><br>t.c:2: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'x'<br></pre><br>another example is:<br><br><pre>$ <b>cat t.c</b><br>#include &lt;sys/stat.h&gt;<br>int foo(int x, struct stat *P) { <br>  return P-&gt;st_blocksize*2;<br>}<br>$ <b>clang t.c</b><br>t.c:4:13: error: no member named 'st_blocksize' in 'struct stat'; did you mean 'st_blksize'?<br>  return P-&gt;st_blocksize*2;<br>            ^~~~~~~~~~~~<br>            st_blksize<br>$ <b>gcc t.c</b><br>t.c: In function ‘foo’:<br>t.c:4: error: 'struct stat' has no member named 'st_blocksize'<br></pre><br>The great thing about the spell checker is that it catches a wide variety of common errors, and it also assists in later recovery. Code that later used 'x', for example, knows that it is declared as an int64_t, so it doesn't lead to other weird follow on errors that don't make any sense. Clang uses the well known <a href=http://en.wikipedia.org/wiki/Levenshtein_distance>Levenshtein distance function</a> to compute the best match out of the possible candidates.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=typedef_tracking>Typedef Tracking</a></h2><br>Clang tracks the typedefs you write in your code carefully so that it can relate errors to the types you use in your code. This allows it to print out error messages in your terms, not in fully resolved and template instantiated compiler terms. It also uses its range information and caret to show you what you wrote instead of trying to print it back out at you. There are several examples of this on the Clang diagnostics page, but one more example can't hurt:<br><br><pre>$ <b>cat t.cc</b><br>namespace foo {<br>  struct x { int y; };<br>}<br>namespace bar {<br>  typedef int y;<br>}<br>void test() {<br>  foo::x a;<br>  bar::y b;<br>  a + b;<br>}<br>$ <b>clang t.cc</b><br>t.cc:10:5: error: invalid operands to binary expression ('foo::x' and 'bar::y' (aka 'int'))<br>  a + b;<br>  ~ ^ ~<br>$ <b>gcc t.cc</b><br>t.cc: In function 'void test()':<br>t.cc:10: error: no match for 'operator+' in 'a + b'<br></pre><br>This shows that clang gives you the source names as you typed them ("foo::x" and "bar::y", respectively) but it also unwraps the y type with "aka" in case the underlying representation is important. Other compilers typically give completely unhelpful information which doesn't really tell you what the problem is. This is a surprisingly concise example from GCC, but it also seems to be missing some critical information (such as why there is no match). Also, if the expression was more than a single "a+b", you can imagine that pretty printing it back at you isn't the most helpful.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=most_vexing_parse>The Most Vexing Parse</a></h2><br>One mistake many beginner programmers mistake is that they accidentally define functions instead of objects on the stack. This is due to an ambiguity in the C++ grammar which is resolved in an arbitrary way. This is an unavoidable part of C++, but at least the compiler should help you understand what is going wrong. Here's a trivial example:<br><br><pre>$ <b>cat t.cc</b><br>#include &lt;vector&gt;<br><br>int foo() {<br>  std::vector&lt;std::vector&lt;int&gt; &gt; X();<br>  return X.size();<br>}<br>$ <b>clang t.cc</b><br>t.cc:5:11: error: base of member reference has function type       'std::vector&lt;std::vector&lt;int&gt; &gt; ()'; perhaps you meant to call this function with '()'?<br>  return X.size();<br>          ^<br>          ()<br>$ <b>gcc t.cc</b><br>t.cc: In function ‘int foo()’:<br>t.cc:5: error: request for member ‘size’ in ‘X’, which is of non-class type ‘std::vector&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt;, std::allocator&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; ()()’<br></pre><br>I run into this thing when I originally declared the vector as taking some arguments (e.g. "10" to specify an initial size) but refactor the code and eliminate that. Of course if you don't remove the parentheses, the code is actually declaring a function, not a variable.<br><br>Here you can see that Clang points out fairly clearly that we've gone and declared a function (it even offers to help you call it in case you forgot ()'s). GCC, on the other hand, is both hopelessly confused about what you're doing, but also spews out a big typename that you didn't write (where did std::allocator come from?). It's sad but true that being an experienced C++ programmer really means that you're adept at decyphering the error messages that your compiler spews at you.<br><br>If you go on to try the more classical example where this bites people, you can see Clang try even harder:<br><br><pre>$ <b>cat t.cc</b><br>#include &lt;fstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;iterator&gt;<br><br>int main() {<br>   std::ifstream ifs("file.txt");<br>   std::vector&lt;char&gt; v(std::istream_iterator&lt;char&gt;(ifs),<br>                       std::istream_iterator&lt;char&gt;());<br>        <br>   std::vector&lt;char&gt;::const_iterator it = v.begin();<br>   return 0;                   <br>}<br>$ <b>clang t.cc</b><br>t.cc:8:23: warning: parentheses were disambiguated as a function declarator<br>   std::vector&lt;char&gt; v(std::istream_iterator&lt;char&gt;(ifs),<br>                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>t.cc:11:45: error: member reference base type 'std::vector&lt;char&gt; (*)(std::istream_iterator&lt;char&gt;, std::istream_iterator&lt;char&gt; (*)())' is not a structure or union<br>   std::vector&lt;char&gt;::const_iterator it = v.begin();<br>                                          ~ ^<br>$ <b>gcc t.cc</b><br>t.cc: In function ‘int main()’:<br>t.cc:11: error: request for member ‘begin’ in ‘v’, which is of non-class type<br>‘std::vector&lt;char, std::allocator&lt;char&gt; &gt; ()(std::istream_iterator&lt;char, char, std::char_traits&lt;char&gt;, long int&gt;, std::istream_iterator&lt;char, char, std::char_traits&lt;char&gt;, long int&gt; (*)())’<br></pre><br>In this case, Clang's second error isn't particularly great (though it does give much more concise type names), but it gives a really critical warning, telling you that the parens in the example are declaring a function, not being used as parens for an argument.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=missing_semicolons>Missing Semicolons</a></h2><br>One error that I frequently make (perhaps due to the wildly inconsistent grammar of C++, or perhaps because I am sloppy and have a short attention span...) is dropping a semicolon. Fortunately these are pretty trivial to fix once you know what is going on, but they can lead to some really confusing error messages from some compilers. This happens even in cases where it is immediately obvious what is going on to a human (if they are paying attention!). For example:<br><br><pre>$ <b>cat t.c</b><br>struct foo { int x; }<br><br>typedef int bar;<br>$ <b>clang t.c</b><br>t.c:1:22: error: expected ';' after struct<br>struct foo { int x; }<br>                     ^<br>                     ;<br>$ <b>gcc t.c</b><br>t.c:3: error: two or more data types in declaration specifiers<br></pre><br>Note that GCC emits the error on the thing that <em>follows the problem</em>. If the struct was the last thing at the end of a header, this means that you'll end up getting the error message <em>in a completely different file</em> than where the problem lies. This problem also compounds itself in C++ (as do many others), for example:<br><br><pre>$ <b>cat t2.cc</b><br>template&lt;class t&gt;<br>class a{}<br><br>class temp{};<br>a&lt;temp&gt; b;<br><br>class b {<br>}<br>$ <b>clang t2.cc</b><br>t2.cc:2:10: error: expected ';' after class<br>class a{}<br>         ^<br>         ;<br>t2.cc:8:2: error: expected ';' after class<br>}<br> ^<br> ;<br>$ <b>gcc t2.c</b><br>t2.cc:4: error: multiple types in one declaration<br>t2.cc:5: error: non-template type ‘a’ used as a template<br>t2.cc:5: error: invalid type in declaration before ‘;’ token<br>t2.cc:8: error: expected unqualified-id at end of input<br></pre><br>In addition to emitting the confusing error "multiple types in one declaration", GCC goes on to confuse itself in other ways.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=dot_arrow_thinko>. vs -> Thinko</a></h2><br>In C++ code, pointers and references often get used fairly interchangeably and it is common to use . where you mean ->. Clang recognizes this common sort of mistake and helps you out:<br><br><pre>$ <b>cat t.cc</b><br>#include &lt;map&gt;<br><br>int bar(std::map&lt;int, float&gt; *X) {<br>  return X.empty();<br>}<br>$ <b>clang t.cc</b><br>t.cc:4:11: error: member reference type 'std::map&lt;int, float&gt; *' is a pointer; maybe you meant to use '-&gt;'?<br>  return X.empty();<br>         ~^<br>          -&gt;<br>$ <b>gcc t.cc</b><br>t.cc: In function ‘int bar(std::map&lt;int, float, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;const int, float&gt; &gt; &gt;*)’:<br>t.cc:4: error: request for member ‘empty’ in ‘X’, which is of non-class type ‘std::map&lt;int, float, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;const int, float&gt; &gt; &gt;*’<br></pre><br>In addition to helpfully informing you that your pointer is a "non-class type", it goes out of its way to spell the full definition of std::map out, which is certainly not helpful.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=scope_typo>:: vs : Typo</a></h2><br>Perhaps it's just me, but I tend to make this mistake quite a bit, again while in a hurry. The C++ :: operator is used to separate nested name specifiers, but somehow I keep typing : instead. Here is a minimal example that shows the idea:<br><br><pre>$ <b>cat t.cc</b><br>namespace x {<br>  struct a { };<br>}<br><br>x:a a2;<br>x::a a3 = a2;<br>$ <b>clang t.cc</b><br>t.cc:5:2: error: unexpected ':' in nested name specifier<br>x:a a2;<br> ^<br> ::<br>$ <b>gcc t.cc</b><br>t.cc:5: error: function definition does not declare parameters<br>t.cc:6: error: ‘a2’ was not declared in this scope<br></pre><br>In addition to getting the error message right (and suggesting a fixit replacement to "::"), Clang "knows what you mean" so it handles the subsequent uses of a2 correctly. GCC, in contrast, gets confused about what the error is which leads it to emit bogus errors on every use of a2. This can be seen with a slightly elaborated example:<br><br><pre>$ <b>cat t2.cc</b><br>namespace x {<br>  struct a { };<br>}<br><br>template &lt;typename t&gt;<br>class foo {<br>};<br><br>foo&lt;x::a&gt; a1;<br>foo&lt;x:a&gt; a2;<br><br>x::a a3 = a2;<br>$ <b>clang t2.cc</b><br>t2.cc:10:6: error: unexpected ':' in nested name specifier<br>foo&lt;x:a&gt; a2;<br>     ^<br>     ::<br>t2.cc:12:6: error: no viable conversion from 'foo&lt;x::a&gt;' to 'x::a'<br>x::a a3 = a2;<br>     ^    ~~<br>t2.cc:2:10: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'foo&lt;x::a&gt;' to 'x::a const' for 1st argument<br>  struct a { };<br>         ^<br>$ <b>gcc t2.cc</b><br>t2.cc:10: error: template argument 1 is invalid<br>t2.cc:10: error: invalid type in declaration before ‘;’ token<br>t2.cc:12: error: conversion from ‘int’ to non-scalar type ‘x::a’ requested<br></pre><br>Here you can see that Clang's second error message is exactly right (and is explained). GCC gives a confusing follow on message about converting an "int" to x::a. Where did "int" come from?<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=near_hopeless>Helping out in near-hopeless situations</a></h2><br>C++ is a power tool that gives you plenty of rope to shoot yourself in the foot as well as mix your multi-paradigmed metaphors. Unfortunately, this power gives you plenty of opportunities to find yourself in a near hopeless situation where you know "something is wrong" but have no idea what the real problem is or how to fix it. Thankfully, Clang tries to be there for you, even in the toughest of times. For example, here's a case involving ambiguous lookup:<br><br><pre>$ <b>cat t.cc</b><br>struct B1 { void f(); };<br>struct B2 { void f(double); };<br><br>struct I1 : B1 { };<br>struct I2 : B1 { };<br><br>struct D: I1, I2, B2 {<br>  using B1::f;  using B2::f;<br>  void g() {<br>    f(); <br>  }<br>};<br>$ <b>clang t.cc</b><br>t.cc:10:5: error: ambiguous conversion from derived class 'D' to base class 'B1':<br>    struct D -&gt; struct I1 -&gt; struct B1<br>    struct D -&gt; struct I2 -&gt; struct B1<br>    f(); <br>    ^<br>$ <b>gcc t.cc</b><br>t.cc: In member function ‘void D::g()’:<br>t.cc:10: error: ‘B1’ is an ambiguous base of ‘D’<br></pre><br>In this case, you can see that not only does clang tell you that there is an ambiguity, it tells you <em>exactly the paths through the inheritance hierarchy that are the problems</em>. When you're dealing with a non-trivial hierarchy, and all the classes aren't in a single file staring at you, this can be a real life saver.<br><br>To be fair, GCC occasionally tries to help out. Unfortunately, when it does so it's not clear if it helps more than it hurts. For example, if you comment out the two using declarations in the example above you get:<br><br><pre>$ <b>clang t.cc</b><br>t.cc:10:5: error: non-static member 'f' found in multiple base-class subobjects of type 'B1':<br>    struct D -&gt; struct I1 -&gt; struct B1<br>    struct D -&gt; struct I2 -&gt; struct B1<br>    f(); <br>    ^<br>t.cc:1:18: note: member found by ambiguous name lookup<br>struct B1 { void f(); };<br>                 ^<br>$ <b>gcc t.cc</b><br>t.cc: In member function ‘void D::g()’:<br>t.cc:10: error: reference to ‘f’ is ambiguous<br>t.cc:2: error: candidates are: void B2::f(double)<br>t.cc:1: error:                 void B1::f()<br>t.cc:1: error:                 void B1::f()<br>t.cc:10: error: reference to ‘f’ is ambiguous<br>t.cc:2: error: candidates are: void B2::f(double)<br>t.cc:1: error:                 void B1::f()<br>t.cc:1: error:                 void B1::f()<br></pre><br>It looks like GCC is trying here, but why is it emitting two errors on line 10 and why is it printing B1::f twice in each? When I get these sort of errors (which is pretty rare, since I don't use multiple inheritance like this often) I really value clarity when unraveling what is going on.<br><br><h2><a href="https://www.blogger.com/blogger.g?blogID=6088150582281556517" name=merge_conflicts>One more thing... Merge Conflicts</a></h2><br>Okay, this may be going a bit far, but how else are you going to fall completely in love with a compiler?<br><br><pre>$ <b>cat t.c</b><br>void f0() {<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>    int x;<br>=======<br>    int y;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; whatever<br>}<br>$ <b>clang t.c</b><br>t.c:2:1: error: version control conflict marker in file<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>^<br>$ <b>gcc t.c</b><br>t.c: In function ‘f0’:<br>t.c:2: error: expected expression before ‘&lt;&lt;’ token<br>t.c:4: error: expected expression before ‘==’ token<br>t.c:6: error: expected expression before ‘&gt;&gt;’ token<br></pre><br>Yep, clang actually detects the merge conflict and parses one side of the conflict. You don't want to get tons of nonsense from your compiler on such a simple error, do you?<br><br>Clang: crafted for real programmers who make might make the occasional mistake. Why settle for less?<br><br>-Chris
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://blog.llvm.org/2010/02/dragonegg-successfully-self-hosts.html><i class="fa fa-chevron-circle-left"></i> Dragonegg Successfully Self-Hosts!</a>
</li>
<li>
<a href=https://blog.llvm.org/2010/04/whats-wrong-with-this-code.html>What's wrong with this code? <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://blog.llvm.org/js/scripts.js></script>
</body>
</html>