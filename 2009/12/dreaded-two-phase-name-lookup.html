<!doctype html><html lang=en><head><title>The Dreaded Two-Phase Name Lookup - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Doug Gregor"><meta property="og:url" content="https://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="The Dreaded Two-Phase Name Lookup"><meta property="og:description" content='C++ has more than its fair share of dark, dank corners, especially where templates are concerned. One of the most vexing is "two-phase name lookup", which involves lookup for any names that occur in the body of a template.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2009-12-18T14:17:00+00:00"><meta property="article:modified_time" content="2009-12-18T14:17:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Dreaded Two-Phase Name Lookup"><meta name=twitter:description content='C++ has more than its fair share of dark, dank corners, especially where templates are concerned. One of the most vexing is "two-phase name lookup", which involves lookup for any names that occur in the body of a template.'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>The Dreaded Two-Phase Name Lookup</h1><aside><ul><li>By Doug Gregor</li><li><time class=post-date datetime=2009-12-18T14:17:00Z>Dec 18, 2009</time></li><li><em><a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>5 minute read</li></ul></aside>C++ has more than its fair share of dark, dank corners, especially where templates are concerned. One of the most vexing is "two-phase name lookup", which involves lookup for any names that occur in the body of a template. As you might expect, there are two different phases of templates:<br><br><br><a name=more></a><br><div><ol><li>Template definition time: when the template is initially parsed, long before it is instantiated, the compiler parses the template and looks up any "non-dependent" names. A name is "non-dependent" if the results of name lookup do not depend on any template parameters, and therefore will be the same from one template instantiation to another.</li><li>Template instantiation time: when the template is instantiated, the compiler looks up any "dependent" names, now that it has the full set of template arguments to perform lookup. The results of this lookup can (and often do!) vary from one template instantiation to another.</li></ol></div><div>Two-phase name lookup is not as complicated as its reputation implies. There are some non-obvious rules in the determination of what is a dependent vs. a non-dependent name, but otherwise the idea is simple. The problem with two-phase name lookup is that current compiler support for this feature is very poor. For example, GCC implements two-phase name lookup relatively well, but occasionally delays lookups that should have been done at template definition time (phase 1) until template instantiation time or performs lookups in both phases when it shouldn't. Visual C++, on the other hand, has a template parsing model that delays nearly every lookup to instantiation time (phase 2). By not implementing two-phase name lookup fully, both compilers tend to accept incorrect template code, and in some cases will end up compiling code differently from the mythical fully-conforming compiler. This is a portability issue, both between those two compilers (Visual C++ is more lenient) and to other, more pedantic compilers.<br></div><div><br></div><div>Like Clang. Clang was designed with complete support for two-phase name lookup, parsing template definitions (phase 1) as completely as possible and only performing name lookup at template instantiation time (phase 2) when required. Since we have chosen to make Clang C++ strict, we end up diagnosing template problems that other compilers miss. While that's generally good---correct code is more portable code---it also means that Clang needs to try extra-hard to produce decent diagnostics. Here's a recent problem Clang found within the LLVM code base (which compiled with GCC):<br></div><div><div></div><blockquote><div>In file included from llvm/lib/Analysis/AliasAnalysisCounter.cpp:16:<br></div><div>In file included from llvm/include/llvm/Pass.h:369:<br></div><div>In file included from llvm/include/llvm/PassAnalysisSupport.h:24:<br></div><div><b>llvm/include/llvm/ADT/SmallVector.h:317:7:</b><b><span style=color:red> error: <span style=color:#000;font-weight:400>use of undeclared identifier 'setEnd'</span></span></b><br></div><div>setEnd(this->end()+1);<br></div><div><span style=color:#3f3>^</span><br></div><div><span style=color:#3f3>this-></span><br></div><div>In file included from llvm/lib/Analysis/AliasAnalysisCounter.cpp:16:<br></div><div>In file included from llvm/include/llvm/Pass.h:369:<br></div><div><b>llvm/include/llvm/PassAnalysisSupport.h:56:14: note: <span style=font-weight:400>in instantiation of member function 'llvm::SmallVectorImpl llvm::PassInfo const *>::push_back' requested here</span></b><br></div><div>Required.push_back(ID);<br></div><div><span style=color:#3f3>^</span><br></div><div>In file included from llvm/lib/Analysis/AliasAnalysisCounter.cpp:16:<br></div><div>In file included from llvm/include/llvm/Pass.h:369:<br></div><div>In file included from llvm/include/llvm/PassAnalysisSupport.h:24:<br></div><div><b>llvm/include/llvm/ADT/SmallVector.h:105:8: note:</b><br></div><div><b>must qualify identifier to find this declaration in dependent base class</b><br></div><div>void setEnd(T *P) { this->EndX = P; }<br></div><div><span style=color:#3f3>^</span><br></div></blockquote><div></div><div>The problem itself is in SmallVectorImpl, in the call to setEnd(). The actual setEnd() function isn't in SmallVectorImpl, but in a base class, so we have a situation that looks like this:<br></div><div><br></div><div></div><blockquote><div>template&lt;typename T><br></div><div>class SmallVectorTemplateCommon {<br></div><div>protected:<br></div><div><span style=white-space:pre></span>void setEnd(T *P);<br></div><div>};<br></div><div></div><div>template&lt;typename T><br></div><div>class SmallVectorImpl : public SmallVectorTemplateCommon&lt;T> {<br></div><div>public:<br></div><div><span style=white-space:pre></span>void push_back(const T& value) {<br></div><div><span style=white-space:pre></span><span style=white-space:pre></span>// ...<br></div><div><span style=white-space:pre></span><span style=white-space:pre></span>setEnd(this->end() + 1);<br></div><div><span style=white-space:pre></span>}<br></div><div>};<br></div></blockquote><div></div><div><br></div><div>If we weren't in a template, this code would be fine, because we would find setEnd in our base class. However, because we're in a template we're dealing with two-phase name lookup. While parsing push_back(), the compiler performs name lookup for the name "setEnd" at phase 1: however, it can't find anything because it isn't allowed to look into the dependent base class SmallVectorTemplateCommon&lt;T>. However, this code is still valid: "setEnd" is taken as the name of a non-member function, which could be found at instantiation time via Argument Dependent Lookup. Unfortunately, when we do get around to instantiating push_back, Argument Dependent Lookup doesn't look into our base class, so Clang gives us a "use of undeclared identifier" error.<br></div><div><br></div><div>By itself, that error would leave the programmer scratching her head. GCC and Visual C++ accepted this code, and setEnd() is <i>obviously</i> in the base class, so what gives? To help out a bit, Clang gives more detail:<br></div><div><ol><li>The note at the very end, which reads "must qualify identifier to find this declaration in dependent base class," tells the programmer what declaration Clang could find... if only she were to qualify the name somehow so that Clang were allowed to look there.</li><li>The original error had a little hint below the caret diagnostic, in green, providing advice on how to fix this particular issue. By adding "this->", we tell the compiler that "setEnd" is in the current class or one of its (possibly dependent) base classes, to be found at template instantiation time.</li></ol></div><div>Clang C++ is designed to be a strict but helpful compiler, following the letter of the C++ standard to help programmers make sure that their code is portable. We also hope to make Clang a friendly compiler, that can use its knowledge of the program and the C++ language to help programmers get past portability problems like this one. And maybe, just maybe, Clang can shine a little light into the dark, scary corners of C++.<br></div></div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2009/12/introduction-to-load-elimination-in-gvn.html><i class="fa fa-chevron-circle-left"></i> Introduction to load elimination in the GVN pass</a></li><li><a href=https://blog.llvm.org/2009/12/advanced-topics-in-redundant-load.html>Advanced Topics in Redundant Load Elimination with a Focus on PHI Translation <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>