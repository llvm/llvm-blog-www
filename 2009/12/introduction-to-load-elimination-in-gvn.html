<!doctype html><html lang=en><head><title>Introduction to load elimination in the GVN pass - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Chris Lattner"><meta property="og:url" content="https://blog.llvm.org/2009/12/introduction-to-load-elimination-in-gvn.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Introduction to load elimination in the GVN pass"><meta property="og:description" content="One very important optimization that the GVN pass (opt -gvn) does is load elimination. Load elimination involves several subsystems (including alias analysis, memory dependence analysis, SSA construction, PHI translation) and has many facets (full vs partial redundancy elimination, value coercion, handling memset/memcpy, etc)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2009-12-17T23:28:00+00:00"><meta property="article:modified_time" content="2009-12-17T23:28:00+00:00"><meta property="article:tag" content="Optimization"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to load elimination in the GVN pass"><meta name=twitter:description content="One very important optimization that the GVN pass (opt -gvn) does is load elimination. Load elimination involves several subsystems (including alias analysis, memory dependence analysis, SSA construction, PHI translation) and has many facets (full vs partial redundancy elimination, value coercion, handling memset/memcpy, etc)."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Introduction to load elimination in the GVN pass</h1><aside><ul><li>By Chris Lattner</li><li><time class=post-date datetime=2009-12-17T23:28:00Z>Dec 17, 2009</time></li><li><em><a href=https://blog.llvm.org/tags/optimization>#optimization</a></em></li><li>4 minute read</li></ul></aside>One very important optimization that the GVN pass (opt -gvn) does is load elimination.&nbsp;Load elimination involves several subsystems (including alias analysis, memory dependence analysis,&nbsp;SSA construction, PHI translation) and&nbsp;has many facets (full vs partial redundancy elimination, value coercion, handling memset/memcpy, etc). &nbsp;In this post, I introduce and motivate the topic, which will let us expand on it in future posts.<br><br><a name=more></a><br><span style=font-size:x-large>Basic Redundant Load Elimination</span><br><br>GVN (which stands for "Global Value Numbering", though this detail has nothing to do with load elimination) is responsible for the&nbsp;form of load elimination&nbsp;known as&nbsp;<b>redundant</b> load elimination. &nbsp;This is the elimination of loads whose values are already available (other forms of load elimination includes deletion of <b>dead</b> loads). &nbsp;A simple example of a redundant load is:<br><br><pre>&nbsp;&nbsp;%x = load i32* %P<br>&nbsp;&nbsp;%y = load i32* %P  ; &lt;- Redundant<br></pre><br>Clearly in this example, we can delete the second load and "replace all uses" of %y with %x, because the value at address %p is already available as the value "i32 %x". Another simple form of redundant elimination comes about from stores, as in:<br><br><pre>&nbsp;&nbsp;store i32 4, i32* %P<br>&nbsp;&nbsp;%a = load i32* %P</pre><br>In this example, we can replace %a with 4. &nbsp;This sort of transformation generalizes to support other operations: the GVN pass can forward memsets to loads, memcpy from constant globals to loads, etc. &nbsp;Note that GVN is not allowed to optimize away volatile loads.<br><br>The implementation of this is pretty straight-forward: GVN (through the memdep class) scans backwards from the load that we are trying to eliminate up through the block until it gets an instruction that provides the value (as in these examples) or until it finds an instruction that might affect the memory in an unknown way like a call. &nbsp;If we find an instruction that potentially clobbers the memory location, we can't eliminate the load.<br><br>However, straight-line code is pretty boring, lets look at more complex examples.<br><br><span style=font-size:x-large>SSA Construction in GVN</span><br><br>GVN can also eliminate non-local loads, which can require PHI node insertion. &nbsp;Here's a simple example:<br><br><pre>BB1:<br>&nbsp;&nbsp;store i32 5, i32* %P<br>&nbsp;&nbsp;br label %Merge<br><br>BB2:<br>&nbsp;&nbsp;%X = load i32* %P<br>&nbsp;&nbsp; ... use %X ...<br>&nbsp;&nbsp; br label %Merge<br><br>Merge:<br>&nbsp;&nbsp;%Y = load i32 *%P<br>&nbsp; ...<br>&nbsp; ... use %Y ...<br></pre><br>In this case, GVN scans for available values of %P within the block (starting at the %Y load), and runs into the top of the %Merge block. &nbsp;Since it got to the top of the block, it starts scanning the predecessor blocks (%BB1 and %BB2) and it finds out that the value of the load is 5 in BB1 and %X in BB2. &nbsp;GVN then renames these values with the SSAUpdater class, producing:<br><br><pre>BB1:<br>&nbsp;&nbsp;store i32 5, i32* %P<br>&nbsp;&nbsp;br label %Merge<br><br>BB2:<br>&nbsp;&nbsp;%X = load i32* %P<br>&nbsp; ... use %X ...<br>&nbsp; br label %Merge<br><br>Merge:<br>&nbsp;&nbsp;%Y = phi i32 [5, %BB1], [%X,&nbsp;%BB2]<br>&nbsp; ...<br>&nbsp; ... use %Y ...<br></pre><br>Replacing a load with a PHI node may not seem like a win, however the cost model we use in the LLVM optimizer assumes that PHI nodes will be coalesced away by the code generator, and are thus free. &nbsp;The logic that does PHI insertion is contained and maintained by the SSAUpdater class, which may be the subject of a future Blog post.<br><br><span style=font-size:x-large>Pros and Cons of Redundant Load Elimination</span><br><br>We always consider it profitable to eliminate a load in the optimizer when possible. Loads can be quite expensive (e.g. if they miss in the cache), and load/store traffic can hide other redundant or further simplifyable logic from the scalar optimizer. &nbsp;One idiom used to test alias analyses usually looks like this:<br><br><pre>&nbsp;&nbsp;%A = <b>load i32* %P</b><br>&nbsp;&nbsp;store i32 1, i32* %Q<br>&nbsp;&nbsp;%B = <b>load i32* %P</b><br><br>&nbsp;&nbsp;%C = sub i32 %A, %B<br>&nbsp;&nbsp;ret i32 %C<br></pre><br>If GVN + instcombine are able to turn this into "<span style="font-family:courier new,Courier,monospace">ret i32 0</span>" then we know that alias analysis was able to prove that P and Q did not alias. &nbsp;While somewhat unlikely in the real world, this is one example that shows a scalar optimization (X-X == 0) that can not be done unless the redundant loads are eliminated.<br><br>The cost of eliminating redundant loads is that it creates longer live ranges that the code generator may not be able to cope with. &nbsp;This is a real issue that we don't currently have a good solution for. &nbsp;The ultimate answer is that improved rematerialization will be able to rematerialize the load further down in the code to reduce register pressure, we don't have great support for this yet though.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2009/12/lit-it.html><i class="fa fa-chevron-circle-left"></i> 'lit' it</a></li><li><a href=https://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html>The Dreaded Two-Phase Name Lookup <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>