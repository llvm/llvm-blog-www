<!doctype html><html lang=en><head><title>Devirtualization in LLVM and Clang - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Piotr Padlewski"><meta property="og:url" content="https://blog.llvm.org/2017/03/devirtualization-in-llvm-and-clang.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Devirtualization in LLVM and Clang"><meta property="og:description" content="This blog post is part of a series of blog posts from students who were funded by the LLVM Foundation to attend the 2016 LLVM Developers' Meeting in San Jose, CA."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-10T13:23:00+00:00"><meta property="article:modified_time" content="2017-03-10T13:23:00+00:00"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Devirtualization in LLVM and Clang"><meta name=twitter:description content="This blog post is part of a series of blog posts from students who were funded by the LLVM Foundation to attend the 2016 LLVM Developers' Meeting in San Jose, CA."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Devirtualization in LLVM and Clang</h1><aside><ul><li>By Piotr Padlewski</li><li><time class=post-date datetime=2017-03-10T13:23:00Z>Mar 10, 2017</time></li><li><em><a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>7 minute read</li></ul></aside><span style=background-color:transparent;color:#000;text-decoration:none;vertical-align:baseline;white-space:pre-wrap><span style=font-weight:400;text-indent:10px;white-space:normal><span style=font-family:arial,helvetica,sans-serif;font-size:small><i>This blog post is part of a series of blog posts from students who were funded by the LLVM Foundation to attend the 2016 LLVM Developers' Meeting in San Jose, CA. Please visit the LLVM Foundation's&nbsp;<a href=http://llvm.org/foundation style=color:purple;text-decoration:none>webpage</a>&nbsp;for more information on our Travel Grants program.&nbsp;</i></span></span></span><br><i style=text-indent:10px><span style=font-family:arial,helvetica,sans-serif><br></span></i><i style=text-indent:10px><span style=font-family:arial,helvetica,sans-serif>This post is from Piotr Padlewski on his work that he presented at the meeting:</span></i><br><div><br></div><span style=font-family:arial,helvetica,sans-serif><span style=font-size:11pt;white-space:pre-wrap>This blogpost will show how C++ devirtualization is performed in current (4.0) clang and LLVM and also ongoing work on -fstrict-vtable-pointers features.</span></span><br><span style=font-family:arial,helvetica,sans-serif><span style=white-space:pre-wrap><br></span><span style=font-weight:400;white-space:pre-wrap><span style=font-size:large>Devirtualization done by the frontend</span></span></span><br><span style=font-family:arial,helvetica,sans-serif><span style=font-size:11pt;white-space:pre-wrap><br></span><span style=white-space:pre-wrap><span style=font-family:inherit>In order to transform a virtual call into a direct call, the frontend must be sure that there are no overrides of vfunction in the program or know the dynamic type of object. Compilation proceeds one translation unit at a time, so, barring LTO, there are only a few cases when the compiler may conclude that there are no overrides:</span></span></span><br><ul><li><span style=font-family:arial,helvetica,sans-serif;white-space:pre-wrap>either the class or virtual method is marked as final</span></li><li><span style=font-family:arial,helvetica,sans-serif;white-space:pre-wrap>the class is defined in an anonymous namespace and has no deriving classes in its translation unit</span></li></ul><span style=font-family:arial,helvetica,sans-serif><br></span><span style=font-size:11pt><span style=font-family:arial,helvetica,sans-serif>The latter is more tricky for clang, which translates the source code in chunks on the fly (see: ASTProducer and ASTConsumer), so is not able to determine if there are any deriving classes later in the source. This could be dealt with in a couple of ways:</span></span><br><ul><li><span style=white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif>give up immediate generation</span></span></li><li><span style=font-family:arial,helvetica,sans-serif;white-space:pre-wrap>run data flow analysis in LLVM to find all the dynamic types passed to function, which has static linkage</span></li><li><span style=font-family:arial,helvetica,sans-serif;white-space:pre-wrap>hope that every use of the virtual function, which is necessarily in the same translation unit, will be inlined by LLVM -- static linkage increases the chances of inlining</span></li></ul><span style=font-family:arial,helvetica,sans-serif><br></span><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap>Store to load propagation in LLVM</span><br><span style=font-family:arial,helvetica,sans-serif><span style=text-align:justify;white-space:pre-wrap><br></span></span><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>In order to devirtualize a virtual call we need:</span><br><ul><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>value of vptr - which virtual table is pointed by it</span></li><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>value of vtable slot - which exact virtual function it is</span></li></ul><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap><br></span><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>Because vtables are constant, the latter value is much easier to get when we have the value of vptr. The only thing we need is vtable definition, which can be achieved by using available_externally linkage.</span><br><span style=text-align:justify;white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif><br></span></span><span style=text-align:justify;white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif>In order to figure out the vptr value, we have to find the store to the same location that defines it. There are 2 analysis responsible for it:</span></span><br><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><br><ul><li><span style=white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif>MemDep (Memory Dependence Analysis) is a simple linear algorithm that for each quered instruction iterates through all instructions above and stops when first dependency is found. Because queries might be performed for each instruction we end up with a quadratic algorithm. Of course quadratic algorithms are not welcome in compilers, so MemDep can only check certain number of instructions.</span></span></li><li><span style=font-family:arial,helvetica,sans-serif><span style=vertical-align:baseline;white-space:pre-wrap>Memory SSA on the other hand has constant complexity because of caching. To find out more, watch “Memory SSA in 5minutes” (</span><a href="https://www.youtube.com/watch?v=bdxWmryoHak" style=text-decoration:none><span style=color:#15c;text-decoration:underline;vertical-align:baseline;white-space:pre-wrap>https://www.youtube.com/watch?v=bdxWmryoHak</span></a><span style=vertical-align:baseline;white-space:pre-wrap>). MemSSA is a pretty new analysis and it doesn’t have all the features MemDep has, therefore MemDep is still widely used.</span></span></li></ul></div><span style=text-align:justify;white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif>The LLVM main pass that does store to load propagation is GVN - Global Value Numbering.</span></span><br><span style=font-family:arial,helvetica,sans-serif><br></span><br><div><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap><br></span><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap>Finding vptr store</span><br><span style=font-family:arial,helvetica,sans-serif><span style=font-family:inherit><span style=font-size:11pt;font-variant-alternates:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal;font-variant-position:normal;text-align:justify;vertical-align:baseline;white-space:pre-wrap><br></span></span></span><span style=font-family:arial,helvetica,sans-serif><span style=font-family:inherit><span style=text-align:justify;vertical-align:baseline;white-space:pre-wrap>In order to figure out the vptr value, we need to see store from constructor. To not rely on constructor's availability or inlining, we decided to use the </span><span style=font-weight:700;text-align:justify;vertical-align:baseline;white-space:pre-wrap>@llvm.assume intrinsic</span><span style=text-align:justify;vertical-align:baseline;white-space:pre-wrap> to indicate the value of vptr. Assume is akin to assert - optimizer seeing call to </span><span style=font-weight:700;text-align:justify;vertical-align:baseline;white-space:pre-wrap>@llvm.assume(i1 %b)</span><span style=text-align:justify;vertical-align:baseline;white-space:pre-wrap> can assume that %b is true after it. We can indicate vptr value by comparing it with the vtable and then call the @llvm.assume with the result of this comparison.</span></span></span><br><h2><b style=font-weight:400><span style=font-family:inherit><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:transparent;color:#000;font-family:courier new;font-size:11pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">call void @_ZN1AC1Ev(%struct.A* %a) ; call ctor</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:transparent;color:#000;font-family:courier new;font-size:11pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">&nbsp;%3 = load {...} %a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load vptr</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:transparent;color:#000;font-family:courier new;font-size:11pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">&nbsp;%4 = icmp eq %3, @_ZTV1A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; compare vptr with vtable</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span id=docs-internal-guid-190e6f9f-a52c-e721-c87c-026c2cef6ffc></span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:transparent;color:#000;font-family:courier new;font-size:11pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">&nbsp;call void @llvm.assume(i1 %4)</span></div></span></b></h2><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap><br></span><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap>Calling multiple virtual functions</span><br><h2><span style=font-family:arial,helvetica,sans-serif;font-size:small;font-weight:400;text-align:justify;white-space:pre-wrap>A non-inlined virtual call will clobber the vptr. In other words, optimizer will have to assume that vfunction might change the vptr in passed object. This sounds like something that never happens because vptr is “const”. The truth is that it is actually weaker than C++ const member, because it changes multiple times during construction of an object (every base type constructor or destructor must set vptrs). But vptr can't be changed during a virtual call, right? Well, what about that?</span></h2><h2><b style=font-weight:400><span style=font-family:inherit><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:700;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>void</span><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap> A::foo() { // virtual</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>static_assert(sizeof(A) == sizeof(Derived));</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap></span><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:700;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>new</span><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>(</span><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:700;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>this</span><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>) Derived;</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-size:11pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>}</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=font-family:inherit;font-size:small;white-space:pre-wrap><br></span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=font-family:arial,helvetica,sans-serif;font-size:small><span style=white-space:pre-wrap>This is call of placement new operator - it doesn’t allocate new memory, it just creates a new object in the provided location. So, by constructing a Derived object in the place where an object of type A was living, we change the vptr to point to Derived’s vtable. Is this code even legal? C++ Standard says yes.</span><span style=font-family:inherit></span></span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=font-family:arial,helvetica,sans-serif;font-size:small;white-space:pre-wrap><br></span></div><div dir=ltr style=display:inline!important;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=font-family:arial,helvetica,sans-serif;font-size:small><span style=background-color:transparent;color:#000;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>However it turns out that if someone called </span><span style=background-color:transparent;color:#000;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>foo</span><span style=background-color:transparent;color:#000;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap> 2 times (with the same object), the second call would be undefined behavior. Standard pretty much says that call or dereference of a pointer to an object whose lifetime has ended is UB, and because the standard agrees that nuking object from inside ends its lifetime, the second call is UB. Be aware that this is only because a zombie pointer is used for the second call. The pointer returned by placement new is considered alive, so performing calls on that pointer is valid. Note that we also silently used that fact with the use of assume.</span></span><br><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap><br></span><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap>(un)clobbering vptr</span></div></span></b></h2><span style=font-family:arial,helvetica,sans-serif><span style=text-align:justify;vertical-align:baseline;white-space:pre-wrap>We need to somehow say that vptr is invariant during its lifetime. We decided to introduce a new metadata for that purpose - !invariant.group. </span><span style=background-color:#fff;text-align:justify;vertical-align:baseline;white-space:pre-wrap>The presence of the invariant.group metadata on the load/store tells the optimizer that every load and store to the same pointer operand within the same invariant group can be assumed to load or store the same value. With </span><span style=background-color:#fff;font-weight:700;text-align:justify;vertical-align:baseline;white-space:pre-wrap>-fstrict-vtable-pointers </span><span style=background-color:#fff;text-align:justify;vertical-align:baseline;white-space:pre-wrap>Clang decorates vtable loads with invariant.group metadana coresponding to caller pointer type.</span><span style=text-align:justify;vertical-align:baseline;white-space:pre-wrap>&nbsp;</span></span><br><span style=font-family:arial,helvetica,sans-serif><span style=text-align:justify;white-space:pre-wrap><br></span><span style=text-align:justify;white-space:pre-wrap>We can enhance the load of virtual function (second load) by decorating it with !invariant.load, which is equivalent of saying “load from this location is always the same”, which is true because vtables never changes. This way we don’t rely on having the definition of vtable.</span></span><br><h2><span style=font-family:inherit><b style=font-weight:400><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-family:arial,helvetica,sans-serif;font-size:small;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>Call like:</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:#fff;color:#000;font-family:courier new;font-size:10.5pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap"><br></span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:#fff;color:#000;font-family:courier new;font-size:10.5pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">void g(A *a) {</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:#fff;color:#000;font-family:courier new;font-size:10.5pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">&nbsp;&nbsp;a->foo();</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:#fff;color:#000;font-family:courier new;font-size:10.5pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">&nbsp;&nbsp;a->foo();</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span id=docs-internal-guid-190e6f9f-a52d-5423-129c-37c542743a2b></span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="background-color:#fff;color:#000;font-family:courier new;font-size:10.5pt;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap">}</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:#fff;color:#000;font-size:10.5pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap><br></span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:#fff;color:#000;font-family:arial,helvetica,sans-serif;font-size:small;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>Will be translated to:</span></div><div dir=ltr style=font-family:inherit;line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:#fff;color:#000;font-size:10.5pt;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap><br></span></div></b></span><span id=docs-internal-guid-190e6f9f-a52d-9190-f702-f45ef470fbc2 style=font-weight:400><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">define void @function(%struct.A* %a) {</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%1 = load {...} %a, !invariant.group !0</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%2 = load {...} %1, !invariant.load !1</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;call void %2(%struct.A* %a)</span></div><br><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%3 = load {...} %a, !invariant.group !0</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%4 = load {...} %4, !invariant.load !1</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;call void %4(%struct.A* %a)</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;ret void</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">}</span></div><br><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">!0 = !{!"_ZTS1A"} ; mangled type name of A</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">!1 = !{}</span></div><div><br></div></span><span style=font-family:inherit><span style=font-family:arial,helvetica,sans-serif;font-size:small;font-weight:400;text-align:justify;white-space:pre-wrap>And now by magic of GVN and MemDep:</span><b style=font-family:inherit;font-weight:400><br></b></span><span id=docs-internal-guid-190e6f9f-a52e-00ef-e518-921d8680d3b9 style=font-weight:400><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap"><br></span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">define void @function(%struct.A* %a) {</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%1 = load {...} %a, !invariant.group !0</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;%2 = load {...} %1, !invariant.load !1</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;call void %2(%struct.A* %a)</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;call void %2(%struct.A* %a)</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">&nbsp;ret void</span></div><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap">}</span></div><div><span style="font-family:courier new;font-size:11pt;vertical-align:baseline;white-space:pre-wrap"><br></span></div></span><span style=font-family:arial,helvetica,sans-serif><b style=font-weight:400><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0;text-align:justify><span style=background-color:transparent;color:#000;font-size:small;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap>With this, llvm-4.0 is be able to devirtualize function calls inside loops.&nbsp;</span><br><span style=font-size:large;white-space:pre-wrap><br></span><span style=font-size:large;white-space:pre-wrap>Barriers</span></div></b></span></h2><span style=font-family:arial,helvetica,sans-serif;font-weight:400;text-align:justify;white-space:pre-wrap>In order to prevent the middle-end from finding load/store with the same !invariant.group metadata, that would come from construction/destruction of dead dynamic object, @llvm.invariant.group.barrier was introduced. It returns another pointer that aliases its argument but is considered different for the purposes of load/store invariant.group metadata. Optimizer won’t be able to figure out that returned pointer is the same because intrinsics don’t have a definition. Barrier must be inserted in all the places where the dynamic object changes:</span><br><ul><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>constructors</span></li><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>destructors</span></li><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>placement new of dynamic object</span></li></ul><span style=font-family:arial,helvetica,sans-serif;font-size:large><span style=white-space:pre-wrap><br></span></span><span style=font-family:arial,helvetica,sans-serif;font-size:large;white-space:pre-wrap>Dealing with barriers</span><br><span style=font-family:arial,helvetica,sans-serif><span style=background-color:transparent;color:#000;font-style:normal;font-weight:400;text-decoration:none;vertical-align:baseline;white-space:pre-wrap><span style=font-family:inherit;font-size:medium><br></span></span><span style=text-align:justify;white-space:pre-wrap>Barriers hinder some other optimizations. Some ideas how it could be fixed:</span></span><br><ul><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>stripping invariant.group metadata and barriers just after devirtualization. Currently it is done before codegen. The problem is that most of the devirtualization comes from GVN, which also does most of the optimizations we would miss with barriers. GVN is expensive therefore it is run only once. It also might make less sense if we are in LTO mode, because that would limit the devirtualization in the link phase.&nbsp;</span></li><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>teaching important passes to look through the barrier. This might be very tricky to preserve the semantics of barrier, but e.g. looking for dependency of load without invariant.group by jumping through the barrier to find a store without invariant.group, is likely to do the trick.</span></li><li><span style=font-family:arial,helvetica,sans-serif;text-align:justify;white-space:pre-wrap>removing invariant.barrier when its argument comes from alloca and is never used etc.</span></li></ul><span style=font-family:arial,helvetica,sans-serif><span style=white-space:pre-wrap>To find out more details about devirtualization check my talk (</span><a href=http://llvm.org/devmtg/2016-11/#talk6 style=white-space:pre-wrap>http://llvm.org/devmtg/2016-11/#talk6</a><span style=white-space:pre-wrap>) from LLVM Dev Meeting 2016.</span></span><br><span style=font-family:arial,helvetica,sans-serif><span style=font-size:11pt;white-space:pre-wrap><br></span></span><span style=color:#434343;font-weight:400;white-space:pre-wrap><span style=font-family:arial,helvetica,sans-serif;font-size:large>About author</span></span><br><h2><span style=font-weight:400><div dir=ltr style=line-height:1.38;margin-bottom:0;margin-top:0><span style=font-family:arial,helvetica,sans-serif;font-size:11pt;vertical-align:baseline;white-space:pre-wrap>Undergraduate student at University of Warsaw, currently working on C++ static analysis in IIIT.</span></div><div><span style=font-family:arial;font-size:11pt;vertical-align:baseline;white-space:pre-wrap><br></span></div></span></h2></div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2017/03/some-news-about-aptllvmorg.html><i class="fa fa-chevron-circle-left"></i> Some news about apt.llvm.org</a></li><li><a href=https://blog.llvm.org/2017/08/llvm-on-windows-now-supports-pdb-debug.html>LLVM on Windows now supports PDB Debug Info <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>