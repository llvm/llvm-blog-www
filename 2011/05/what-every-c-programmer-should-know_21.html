<!doctype html><html lang=en><head><title>What Every C Programmer Should Know About Undefined Behavior #3/3 - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Chris Lattner"><meta property="og:url" content="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="What Every C Programmer Should Know About Undefined Behavior #3/3"><meta property="og:description" content='In Part 1 of the series, we took a look at undefined behavior in C and showed some cases where it allows C to be more performant than "safe" languages.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-05-21T00:48:00+00:00"><meta property="article:modified_time" content="2011-05-21T00:48:00+00:00"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="What Every C Programmer Should Know About Undefined Behavior #3/3"><meta name=twitter:description content='In Part 1 of the series, we took a look at undefined behavior in C and showed some cases where it allows C to be more performant than "safe" languages.'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>What Every C Programmer Should Know About Undefined Behavior #3/3</h1><aside><ul><li><time class=post-date datetime=2011-05-21T00:48:00Z>May 21, 2011</time></li><li><em><a href=https://blog.llvm.org/tags/optimization>#optimization</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>13 minute read</li></ul></aside>In <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>Part 1</a> of the series, we took a look at undefined behavior in C and showed some cases where it allows C to be more performant than "safe" languages. In <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html>Part 2</a>, we looked at the surprising bugs this causes and some widely held misconceptions that many programmers have about C. In this article, we look at the challenges that compilers face in providing warnings about these gotchas, and talk about some of the features and tools that LLVM and Clang provide to help get the performance wins, while taking away some of the surprise.<br><a name=more></a><br>Translation available in: <a href=http://blog-ja.intransient.info/2011/06/c-33.html>Japanese</a><h2>Why can't you warn when optimizing based on undefined behavior?</h2><br>People often ask why the compiler doesn't produce warnings when it is taking advantage of undefined behavior to do an optimization, since any such case might actually be a bug in the user code. The challenges with this approach are that it is 1) likely to generate far too many warnings to be useful - because these optimizations kick in all the time when there is no bug, 2) it is really tricky to generate these warnings only when people want them, and 3) we have no good way to express (to the user) how a series of optimizations combined to expose the opportunity being optimized. Lets take each of these in turn:<br><br><b>It is "really hard" to make it actually useful</b><br><br>Lets look at an example: even though invalid type casting bugs are frequently exposed by type based alias analysis, it would not be useful to produce a warning that "the optimizer is assuming that P and P[i] don't alias" when optimizing "zero_array" (from <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>Part #1 of our series</a>).<br><br><pre>float *P;<br> void zero_array() {<br>   int i;<br>   for (i = 0; i &lt; 10000; ++i)<br>     P[i] = 0.0f;<br>}<br></pre><br>Beyond this "false positive" problem, a logistical problem is that the optimizer doesn't have enough information to generate a reasonable warning. First of all, it is working on an already-abstract representation of the code (<a href=http://llvm.org/docs/LangRef.html>LLVM IR</a>) which is quite different from C, and second, the compiler is highly layered to the point where the optimization trying to "hoist a load from P out of the loop" doesn't know that TBAA was the analysis that resolved the pointer alias query. Yes, this is "the compiler guy whining" part of the article :), but it really is a hard problem.<br><br><b>It is hard to generate these warnings <i>only</i> when people want them</b><br><br>Clang implements numerous warnings for simple and obvious cases of undefined behavior, such as out of range shifts like "x &lt;&lt; 421". You might think that this is a simple and obvious thing, but it turns out that this is hard, because <a href="http://llvm.org/bugs/show_bug.cgi?id=5544">people don't want to get warnings about undefined behavior in dead code</a> (see also <a href="http://llvm.org/bugs/show_bug.cgi?id=6933">the duplicates</a>).<br><br>This dead code can take several forms: a macro that expands out in a funny way when when passed a constant, we've even had complaints that we warn in cases that would require <a href="http://llvm.org/bugs/show_bug.cgi?id=9322">control flow analysis</a> of switch statements to prove that cases are not reachable. This is not helped by the fact that switch statements in C are <a href="http://en.wikipedia.org/wiki/Duff's_device">not necessarily properly structured</a>.<br><br>The solution to this in Clang is a growing infrastructure for handling "runtime behavior" warnings, along with code to prune these out so that they are not reported if we later find out that the block is unexecutable. This is something of an arms race with programmers though, because there are always idioms that we don't anticipate, and doing this sort of thing in the frontend means that it doesn't catch every case people would want it to catch.<br><br><b>Explaining a series of optimizations that exposed an opportunity</b><br><br>If the frontend has challenges producing good warnings, perhaps we can generate them <em>from the optimizer</em> instead! The biggest problem with producing a useful warning here is one of data tracking. A compiler optimizer includes dozens of optimization passes that each change the code as it comes through to canonicalize it or (hopefully) make it run faster. If the inliner decides to inline a function, this may expose other opportunities for <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html#signed_overflow>optimizing away an "X*2/2"</a>, for example.<br><br>While I've given <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html#optimizations>relatively simple and self-contained examples</a> to demonstrate these optimizations, most of the cases where they kick in are in code coming from macro instantiation, inlining, and other abstraction-elimination activities the compiler performs. The reality is that humans don't commonly write such silly things directly. For warnings, this means that in order to relay back the issue to the users code, the warning would have to reconstruct exactly how the compiler got the intermediate code it is working on. We'd need the ability to say something like:<br><br><blockquote><tt><br>warning: after 3 levels of inlining (potentially across files with Link Time Optimization), some common subexpression elimination, after hoisting this thing out of a loop and proving that these 13 pointers don't alias, we found a case where you're doing something undefined. This could either be because there is a bug in your code, or because you have macros and inlining and the invalid code is dynamically unreachable but we can't prove that it is dead.</tt></blockquote><br>Unfortunately, we simply don't have the internal tracking infrastructure to produce this, and even if we did, the compiler doesn't have a user interface good enough to express this to the programmer.<br><br>Ultimately, undefined behavior is valuable to the optimizer because it is saying "this operation is invalid - you can assume it never happens". In a case like "*P" this gives the optimizer the ability to reason that P cannot be NULL. In a case like "*NULL" (say, after some constant propagation and inlining), this allows the optimizer to know that the code must not be reachable. The important wrinkle here is that, because it cannot solve the halting problem, the compiler cannot know whether code is actually dead (as the C standard says it must be) or whether it is a bug that was exposed after a (potentially long) series of optimizations. Because there isn't a generally good way to distinguish the two, almost all of the warnings produced would be false positives (noise).<br><br><h2>Clang's Approach to Handling Undefined Behavior</h2><br>Given the sorry state that we're in when it comes to undefined behavior, you might be wondering what Clang and LLVM are doing to try to improve the situation. I mentioned a couple of them already: the <a href=http://clang-analyzer.llvm.org/>Clang Static Analyzer</a>, <a href=http://klee.llvm.org/>Klee project</a>, and the <tt>-fcatch-undefined-behavior</tt> flag are useful tools for tracking down some classes of these bugs. The problem is that these aren't as widely used as the compiler is, so anything we can do directly in the compiler offers even higher goodness than doing it in these other tools. Keep in mind though that the compiler is limited by not having dynamic information and by being limited to what it can without burning lots of compile time.<br><br>Clang's first step to improve the world's code is to turn on a whole lot more warnings by default than other compilers do. While some developers are disciplined and build with "<tt>-Wall -Wextra</tt>" (for example), many people don't know about these flags or don't bother to pass them. Turning more warnings on by default catches more bugs more of the time.<br><br>The second step is that Clang generates warnings for many classes of undefined behavior (including dereference of null, oversized shifts, etc) that are obvious in the code to catch some common mistakes. Some of the caveats are mentioned above, but these seem to work well in practice.<br><br>The third step is that the LLVM optimizer generally takes much less liberty with undefined behavior than it could. Though the standard says that any instance of undefined behavior has completely unbound effects on the program, this is not a particularly useful or developer friendly behavior to take advantage of. Instead, the LLVM optimizer handles these optimizations in a few different ways (the links describe rules of LLVM IR, not C, sorry!):<br><br><ol><li>Some cases of undefined behavior are silently transformed into implicitly trapping operations if there is a good way to do that. For example, with Clang, this C++ function:<br><br><pre>int *foo(long x) {<br>  return new int[x];<br>}<br></pre><br>compiles into this X86-64 machine code:<br><br><pre>__Z3fool:<br>        movl $4, %ecx<br>        movq %rdi, %rax<br>        mulq %rcx<br>        movq $-1, %rdi        # Set the size to -1 on overflow<br>        cmovnoq %rax, %rdi    # Which causes 'new' to throw std::bad_alloc<br>        jmp __Znam<br></pre><br>instead of the code GCC produces:<br><br><pre>__Z3fool:<br>        salq $2, %rdi<br>        jmp __Znam             # Security bug on overflow!<br></pre><br>The difference here is that we've decided to invest a few cycles in preventing a potentially <a href=http://cert.uni-stuttgart.de/advisories/calloc.php>serious integer overflow bug</a> that can lead to buffer overflows and exploits (operator new is typically fairly expensive, so the overhead is almost never noticable). The GCC folks have been aware of this <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=19351">since at least 2005</a> but haven't fixed this at the time of this writing.</li><li>Arithmetic that <a href=http://llvm.org/docs/LangRef.html#undefvalues>operates on undefined values</a> is considered to produce a undefined value instead of producing undefined behavior. The distinction is that undefined values can't format your hard drive or produce other undesirable effects. A useful refinement happens in cases where the arithmetic would produce the same output bits given any possible instance of the undefined value. For example, the optimizer assumes that the result of "undef & 1" has zeros for its top bits, treating only the low bit as undefined. This means that ((undef & 1) >> 1) is defined to be 0 in LLVM, not undefined.</li><li>Arithmetic that dynamically executes an undefined operation (such as a signed integer overflow) generates a logical <a href=http://llvm.org/docs/LangRef.html#trapvalues>trap value</a> which poisons any computation based on it, but that does not destroy your entire program. This means that logic downstream from the undefined operation may be affected, but that your entire program isn't destroyed. This is why the optimizer ends up deleting code that operates on uninitialized variables, for example.</li><li>Stores to null and calls through null pointers are turned into a __builtin_trap() call (which turns into a trapping instruction like "ud2" on x86). These happen all of the time in optimized code (as the result of other transformations like inlining and constant propagation) and we used to just delete the blocks that contained them because they were "obviously unreachable".<br><br>While (from a pedantic language lawyer standpoint) this is strictly true, we quickly learned that people do occasionally dereference null pointers, and having the code execution just fall into the top of the next function makes it very difficult to understand the problem. From the performance angle, the most important aspect of exposing these is to squash downstream code. Because of this, clang turns these into a runtime trap: if one of these is actually dynamically reached, the program stops immediately and can be debugged. The drawback of doing this is that we slightly bloat code by having these operations and having the conditions that control their predicates.</li><li>The optimizer does go to some effort to "do the right thing" when it is obvious what the programmer meant (such as code that does "*(int*)P" when P is a pointer to float). This helps in many common cases, but you really don't want to rely on this, and there are lots of examples that you might think are "obvious" that aren't after a long series of transformations have been applied to your code.</li><li>Optimizations that don't fall into any of these categories, such the zero_array and set/call examples in Part #1 are optimized as described, silently, without any indication to the user. We do this because we don't have anything useful to say, and it is very uncommon for (buggy) real-world code to be broken by these optimizations.</li></ol><br>One major area of improvement we can make is with respect to trap insertion. I think it would be interesting to add an (off-by-default) warning flag that would cause the optimizer to warn whenever it generates a trap instruction. This would be extremely noisy for some codebases, but could be useful for others. The first limiting factor here is the infrastructure work to make the optimizer produce warnings: it doesn't have useful source code location information unless debugging information is turned on (but this could be fixed).<br><br>The other, more significant, limiting factor is that the warning wouldn't have any of the "tracking" information to be able to explain that an operation is the result of unrolling a loop three times and inlining it through four levels of function calls. At best we'll be able to point out the file/line/column of the original operation, which will be useful in the most trivial cases, but is likely to be extremely confusing in other cases. In any event, this hasn't been a high priority for us to implement because a) it isn't likely to give a good experience b) we won't be able to turn it on by default, and c) is a lot of work to implement.<br><br><h2>Using a Safer Dialect of C (and other options)</h2><br>A final option you have if you don't care about "ultimate performance", is to use various compiler flags to enable dialects of C that eliminate these undefined behaviors. For example, using the <tt>-fwrapv</tt> flag eliminates undefined behavior that results from signed integer overflow (however, note that it does <b>not</b> eliminate possible integer overflow security vulnerabilities). The <tt>-fno-strict-aliasing</tt> flag disables Type Based Alias Analysis, so you are free to ignore these type rules. If there was demand, we could add a flag to Clang that implicitly zeros all local variables, one that inserts an "and" operation before each shift with a variable shift count, etc. Unfortunately, there is no tractable way to <b>completely</b> eliminate undefined behavior from C without breaking the ABI and completely destroying its performance. The other problem with this is that you're not writing C anymore, you're writing a similar, but non-portable dialect of C.<br><br>If writing code in a non-portable dialect of C isn't your thing, then the <tt>-ftrapv</tt> and <tt>-fcatch-undefined-behavior</tt> flags (along with the other tools mentioned before) can be useful weapons in your arsenal to track down these sorts of bugs. Enabling them in your debug builds can be a great way to find related bugs early. These flags can also be useful in production code if you are building security critical applications. While they provide no guarantee that they will find all bugs, they do find a useful subset of bugs.<br><br>Ultimately, the real problem here is that C just isn't a "safe" language and that (despite its success and popularity) many people do not really understand how the language works. In its decades of evolution prior to standardization in 1989, C migrated from being a "low level systems programming language that was a tiny layer above PDP assembly" to being a "low level systems programming language, trying to provide decent performance by <em>breaking many people's expectations</em>". On the one hand, these C "cheats" almost always work and code is generally more performant because of it (and in some cases, <em>much</em> more performant). On the other hand, the places where C cheats are often some of the most surprising to people and typically strike at the worst possible time.<br><br>C is much more than a portable assembler, sometimes in very surprising ways. I hope this discussion helps explain some of the issues behind undefined behavior in C, at least from a compiler implementer's viewpoint.<br><br>-<a href=http://nondot.org/sabre/>Chris Lattner</a></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html><i class="fa fa-chevron-circle-left"></i> What Every C Programmer Should Know About Undefined Behavior #2/3</a></li><li><a href=https://blog.llvm.org/2011/05/c-at-google-here-be-dragons.html>C++ at Google: Here Be Dragons <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>