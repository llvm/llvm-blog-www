<!doctype html><html lang=en><head><title>What Every C Programmer Should Know About Undefined Behavior #2/3 - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Chris Lattner"><meta property="og:url" content="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="What Every C Programmer Should Know About Undefined Behavior #2/3"><meta property="og:description" content='In Part 1 of our series, we discussed what undefined behavior is, and how it allows C and C++ compilers to produce higher performance applications than "safe" languages. This post talks about how "'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2011-05-14T12:33:00+00:00"><meta property="article:modified_time" content="2011-05-14T12:33:00+00:00"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="What Every C Programmer Should Know About Undefined Behavior #2/3"><meta name=twitter:description content='In Part 1 of our series, we discussed what undefined behavior is, and how it allows C and C++ compilers to produce higher performance applications than "safe" languages. This post talks about how "'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>What Every C Programmer Should Know About Undefined Behavior #2/3</h1><aside><ul><li>By Chris Lattner</li><li><time class=post-date datetime=2011-05-14T12:33:00Z>May 14, 2011</time></li><li><em><a href=https://blog.llvm.org/tags/optimization>#optimization</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>10 minute read</li></ul></aside>In <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>Part 1</a>
of our series, we discussed what undefined behavior is, and how it allows C and C++ compilers
to produce higher performance applications than "safe" languages. This post talks about how
"unsafe" C really is, explaining some of the highly surprising effects that undefined behavior
can cause. In <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html>Part
#3</a>, we talk about what friendly compilers can do to mitigate some of the surprise, even
if they aren't required to.<br><br>I like to call this "<b>Why undefined behavior is often a scary and terrible thing for C
programmers</b>". :-)<br><br><a name=more></a><br>Translation available in: <a href=http://blog-ja.intransient.info/2011/05/c-23.html>Japanese</a>,
and <a href=https://chicksx.com/blog/c-programmer-part-2>Spanish</a>a>.<h2>Interacting Compiler Optimizations Lead to Surprising Results</h2><br>A modern compiler optimizer contains many optimizations that are run in specific orders, sometimes iterated, and change as the compiler evolves over time (e.g. new releases come out). Also, different compilers often have substantially different optimizers. Because optimizations run at different stages, emergent effects can occur due to previous optimizations changing the code.<br><br>Lets take a look at a silly example (simplified from an exploitable bug that was found in the Linux Kernel) to make this more concrete:<br><br><pre>void contains_null_check(int *P) {<br>  int dead = *P;<br>  if (P == 0)<br>    return;<br>  *P = 4;<br>}<br></pre><br>In this example, the code "clearly" checks for the null pointer. If the compiler happens to run "Dead Code Elimination" before a "Redundant Null Check Elimination" pass, then we'd see the code evolve in these two steps:<br><br><pre>void contains_null_check_after_DCE(int *P) {<br>  <strike>//int dead = *P;</strike>     // deleted by the optimizer.<br>  if (P == 0)<br>    return;<br>  *P = 4;<br>}<br></pre><br>and then:<br><br><pre>void contains_null_check_after_DCE_and_RNCE(int *P) {<br>  if (P == 0)   // Null check not redundant, and is kept.<br>    return;<br>  *P = 4;<br>}<br></pre><br>However, if the optimizer happens to be structured differently, it could run RNCE before DCE. This would give us these two steps:<br><br><pre>void contains_null_check_after_RNCE(int *P) {<br>  int dead = *P;<br>  if (<b>false</b>)  // P was dereferenced by this point, so it can't be null <br>    return;<br>  *P = 4;<br>}<br></pre><br>and then dead code elimination runs:<br><br><pre>void contains_null_check_after_RNCE_and_DCE(int *P) {<br>  <strike>//int dead = *P;</strike><br>  <strike>//if (false)</strike><br>  <strike>//  return;</strike><br>  *P = 4;<br>}<br></pre><br>To many (reasonable!) programmers, deleting the null check from this function would be very surprising (and they'd probably file a bug against the compiler :). However, both "contains_null_check_after_DCE_and_RNCE" and "contains_null_check_after_RNCE_and_DCE" are perfectly valid optimized forms of "contains_null_check" according to the standard, and both of the optimizations involved are important for the performance of various applications.<br><br>While this is intentionally a simple and contrived example, this sort of thing happens all the time with inlining: inlining a function often exposes a number of secondary optimization opportunities. This means that if the optimizer decides to inline a function, a variety of local optimizations can kick in, which change the behavior of the code. This is both perfectly valid according to the standard, and important for performance in practice.<br><br><h2>Undefined Behavior and Security Don't Mix Well</h2><br>The C family of programming languages is used to write a wide range of security critical code, such as kernels, setuid daemons, web browsers, and much more. This code is exposed to hostile input and bugs can lead to all sorts of exploitable security problems. One of the widely cited advantages of C is that it is relatively easy to understand what is going on when you read the code.<br><br>However, undefined behavior takes this property away. After all, most programmers would think that "contains_null_check" would do a null check above. While this case isn't too scary (the code will probably crash in the store if passed a null check, which is relatively easy to debug) there are a wide range of <i>very reasonable</i> looking C fragments that are completely invalid. This problem has bit many projects (including the Linux Kernel, OpenSSL, glibc, etc) and even led to CERT issuing a <a href=http://www.kb.cert.org/vuls/id/162289>vulnerability note</a> against GCC (though my personal belief is that all widely-used optimizing C compilers are vulnerable to this, not just GCC).<br><br>Lets look at an example. Consider this carefully written C code:<br><br><pre>void process_something(int size) {<br>  // Catch integer overflow.<br>  if (size &gt; size+1)<br>    abort();<br>  ...<br>  // Error checking from this code elided.<br>  char *string = malloc(size+1);<br>  read(fd, string, size);<br>  string[size] = 0;<br>  do_something(string);<br>  free(string);<br>}<br></pre>This code is checking to make sure that the malloc is big enough to hold the data read from the file (because a nul terminator byte needs to be added), bailing out if an integer overflow error occurs. However, this is <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html#signed_overflow>exactly the example we gave before</a> in which the compiler is allowed to (validly) optimize out the check. This means that it is perfectly possible for the compiler to turn this into:<br><br><pre>void process_something(int *data, int size) {<br>  char *string = malloc(size+1);<br>  read(fd, string, size);<br>  string[size] = 0;<br>  do_something(string);<br>  free(string);<br>}<br></pre><br>When being built on a 64-bit platform, it is quite likely that this is an exploitable bug when "size" is INT_MAX (perhaps the size of a file on disk). Lets consider how terrible this is: a code auditor reading the code would very reasonably think that a proper overflow check is happening. Someone testing the code would find no problem unless they specifically tested that error path. The secure code seems to work, until someone goes ahead and exploits the vulnerability. All in all, this is a surprising and quite scary class of bugs. Fortunately, the fix is simple in this case: just use "size == INT_MAX" or similar.<br><br>As it turns out, integer overflow is a security problem for many reasons. Even if you are using fully defined integer arithmetic (either by using <tt>-fwrapv</tt> or by using unsigned integers), there is a <a href=http://en.wikipedia.org/wiki/Integer_overflow#Security_ramifications>wholly different class</a> of integer overflow bug possible. Fortunately, this class is visible in the code and knowledgable security auditors are usually aware of the problem.<br><br><br><h2>Debugging Optimized Code May Not Make Any Sense</h2>Some people (for example, low level embedded programmers who like to look at generated machine code) do all of their development with optimizations turned on. Because code <b>frequently</b> has bugs when it is being developed, these folks end up seeing a disproportionate number of surprising optimizations that can lead to difficult-to-debug behaviors at runtime. For example, accidentally leaving out the "i = 0" in the "zero_array" example from the first article allows the compiler to completely discard the loop (compiling zero_array into "return;") because it is a use of an uninitialized variable.<br><br>Another interesting case that bit someone recently happened when they had a (global) function pointer. A simplified example looks like this:<br><br><pre>static void (*FP)() = 0;<br>static void impl() {<br>  printf("hello\n");<br>}<br>void set() {<br>  FP = impl;<br>}<br>void call() {<br>  FP();<br>}<br></pre>which clang optimizes into:<br><br><pre>void set() {}<br>void call() {<br>  printf("hello\n");<br>}<br></pre>It is allowed to do this because calling a null pointer is undefined, which permits it to assume that set() must be called before call(). In this case, the developer forgot to call "set", did not crash with a null pointer dereference, and their code broke when someone else did a debug build.<br><br>The upshot is that it is a fixable issue: if you suspect something weird is going on like this, try building at -O0, where the compiler is much less likely to be doing any optimizations at all.<br><br><br><h2>"Working" code that uses undefined behavior can "break" as the compiler evolves or changes</h2>We've seen many cases where applications that "appear to be work" suddenly break when a newer LLVM is used to build it, or when the application was moved from GCC to LLVM. While LLVM does occasionally have a bug or two itself :-), this is most often because of latent bugs in the application that are now being exposed by the compiler. This can happen all sorts different ways, two examples are:<br><br>1. an uninitialized variable which was zero initialized by luck "before", and now it shares some other register that isn't zero. This is commonly exposed by register allocation changes.<br><br>2. an array overflow on the stack which starts clobbering a variable that actually matters, instead of something that was dead. This is exposed when the compiler rearranges how it packs things on the stack, or gets more aggressive about sharing stack space for values with non-overlapping lifetimes.<br><br>The important and scary thing to realize is that just about *any* optimization based on undefined behavior can start being triggered on buggy code at any time in the future. Inlining, loop unrolling, memory promotion and other optimizations will keep getting better, and a significant part of their reason for existing is to expose secondary optimizations like the ones above.<br><br>To me, this is deeply dissatisfying, partially because the compiler inevitably ends up getting blamed, but also because it means that huge bodies of C code are land mines just waiting to explode. This is even worse because...<br><br><h2>There is No Reliable Way to Determine if a Large Codebase Contains Undefined Behavior</h2>Making the landmine a much much worse place to be is the fact that there is <b>no good way</b> to determine whether a large scale application is free of undefined behavior, and thus not susceptible to breaking in the future. There are many useful tools that can help find <b>some</b> of the bugs, but nothing that gives full confidence that your code won't break in the future. Lets look at some of these options, along with their strengths and weaknesses:<br><br>1. The <a href=http://valgrind.org/>Valgrind</a> <a href=http://valgrind.org/info/tools.html#memcheck>memcheck tool</a> is a fantastic way to find all sorts of uninitialized variables and other memory bugs. Valgrind is limited because it is quite slow, it can only find bugs that still exist in the generated machine code (so it <a href=http://blog.regehr.org/archives/519>can't find things the optimizer removes</a>), and doesn't know that the source language is C (so it can't find shift-out-of-range or signed integer overflow bugs).<br><br>2. Clang has an experimental <tt>-fcatch-undefined-behavior</tt> mode that inserts runtime checks to find violations like shift amounts out of range, some simple array out of range errors, etc. This is limited because it slows down the application's runtime and it can't help you with random pointer dereferences (like Valgrind can), but it can find other important bugs. Clang also fully supports the <tt>-ftrapv</tt> flag (not to be confused with <tt>-fwrapv</tt>) which causes signed integer overflow bugs to trap at runtime (GCC also has this flag, but it is completely unreliable/buggy in my experience). Here is a quick demo of <tt>-fcatch-undefined-behavior</tt>:<br><br><pre>$ cat t.c<br>int foo(int i) {<br>  int x[2];<br>  x[i] = 12;<br>  return x[i];<br>}<br><br>int main() {<br>  return foo(2);<br>}<br>$ clang t.c <br>$ ./a.out <br>$ clang t.c -fcatch-undefined-behavior <br>$ ./a.out <br>Illegal instruction<br></pre>3. Compiler warning messages are good for finding some classes of these bugs, like uninitialized variables and simple integer overflow bugs. It has two primary limitations: 1) it has no dynamic information about your code as it executes, and 2) it must run very quickly because any analysis it does slows down compile time.<br><br>4. <a href=http://clang-analyzer.llvm.org/>The Clang Static Analyzer</a> performs a much deeper analysis to try to find bugs (including use of undefined behavior, like null pointer dereferences). You can think of it as generating souped up compiler warning messages, because it is not bound by the compile time constraints of normal warnings. The primary disadvantages of the static analyzer is that it 1) doesn't have dynamic information about your program as it runs, and 2) is not integrated into normal workflows for many developers (though its integration into <a href=http://developer.apple.com/technologies/mac/snowleopard/static.html>Xcode 3.2 and later</a> is fantastic).<br><br>5. The <a href=http://klee.llvm.org/>LLVM "Klee" Subproject</a> uses symbolic analysis to "try every possible path" through a piece of code to find bugs in the code and it <b>produces a testcase</b>. It is a great little project that is mostly limited by not being practical to run on large-scale applications.<br><br>6. While I have never tried it, the <a href=http://code.google.com/p/c-semantics/>C-Semantics tool</a> by Chucky Ellison and Grigore Rosu is a very interesting tool that can apparently find some classes of bugs (such as sequence point violations). It is still a research prototype, but may be useful for finding bugs in (small and self-contained) programs. I recommend reading <a href=http://blog.regehr.org/archives/523>John Regehr's post about it</a> for more information.<br><br>The end result of this is that we have lots of tools in the toolbox to find some bugs, but no good way to prove that an application is free of undefined behavior. Given that there are lots of bugs in real world applications and that C is used for a broad range of critical applications, this is pretty scary. In our <a href=http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html>final article</a>, I look at various options that C compilers have when dealing with undefined behavior, with a specific focus on <a href=http://clang.llvm.org/>Clang</a>.<br><br>-<a href=http://nondot.org/sabre/>Chris Lattner</a></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html><i class="fa fa-chevron-circle-left"></i> What Every C Programmer Should Know About Undefined Behavior #1/3</a></li><li><a href=https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html>What Every C Programmer Should Know About Undefined Behavior #3/3 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>