<!doctype html><html lang=en><head><title>DragonFFI: FFI/JIT for the C language using Clang/LLVM - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Adrien Guinet"><meta property="og:url" content="https://blog.llvm.org/2018/03/dragonffi-ffijit-for-c-language-using.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="DragonFFI: FFI/JIT for the C language using Clang/LLVM"><meta property="og:description" content='IntroductionA foreign function interface is "a mechanism by which a program written in one programming language can call routines or make use of services written in another".
In the case of DragonFFI, we expose a library that allows calling C functions and using C structures from any languages.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-13T07:45:00+00:00"><meta property="article:modified_time" content="2018-03-13T07:45:00+00:00"><meta property="article:tag" content="Clang"><meta property="article:tag" content="LLVM"><meta name=twitter:card content="summary"><meta name=twitter:title content="DragonFFI: FFI/JIT for the C language using Clang/LLVM"><meta name=twitter:description content='IntroductionA foreign function interface is "a mechanism by which a program written in one programming language can call routines or make use of services written in another".
In the case of DragonFFI, we expose a library that allows calling C functions and using C structures from any languages.'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>DragonFFI: FFI/JIT for the C language using Clang/LLVM</h1><aside><ul><li>By Adrien Guinet</li><li><time class=post-date datetime=2018-03-13T07:45:00Z>Mar 13, 2018</time></li><li><em><a href=https://blog.llvm.org/tags/clang>#Clang</a>
,
<a href=https://blog.llvm.org/tags/llvm>#llvm</a></em></li><li>15 minute read</li></ul></aside><style type=text/css>pre.address{margin-bottom:0;margin-top:0;font:inherit}li{text-indent:0}pre.code .ln{color:grey}pre.code,code{text-indent:0;background-color:#eee}pre.code .comment,code .comment{color:#5c6576}pre.code .keyword,code .keyword{color:#3b0d06;font-weight:700}pre.code .literal.string,code .literal.string{color:#0c5404}pre.code .name.builtin,code .name.builtin{color:#352b84}pre.code .deleted,code .deleted{background-color:#deb0a1}pre.code .inserted,code .inserted{background-color:#a3d289}span.classifier{font-family:sans-serif;font-style:oblique}span.classifier-delimiter{font-family:sans-serif;font-weight:700}span.interpreted{font-family:sans-serif}span.option{white-space:nowrap}span.pre{white-space:pre}span.problematic{color:red}span.section-subtitle{font-size:80%}</style><br><h3>Introduction</h3>A <a href=https://en.wikipedia.org/wiki/Foreign_function_interface target=_blank>foreign function interface</a> is "a mechanism by which a program written in one programming language can call routines or make use of services written in another".<br>In the case of DragonFFI, we expose a library that allows calling C functions and using C structures from any languages. Basically, we want to be able to do this, let's say in Python:<br><pre class="code python literal-block"><span class="keyword namespace">import</span> <span class="name namespace">pydffi</span><br><span class=name>CU</span> <span class=operator>=</span> <span class=name>pydffi</span><span class=operator>.</span><span class=name>FFI</span><span class=punctuation>()</span><span class=operator>.</span><span class=name>cdef</span><span class=punctuation>(</span><span class="literal string double">"int puts(const char* s);"</span><span class=punctuation>);</span><br><span class=name>CU</span><span class=operator>.</span><span class=name>funcs</span><span class=operator>.</span><span class=name>puts</span><span class=punctuation>(</span><span class="literal string double">"hello world!"</span><span class=punctuation>)</span><br></pre>or, in a more advanced way, for instance to use <a href=https://www.libarchive.org/>libarchive</a> directly from Python:<br><pre class="code python literal-block"><span class="keyword namespace">import</span> <span class="name namespace">pydffi</span><br><span class=name>pydffi</span><span class=operator>.</span><span class=name>dlopen</span><span class=punctuation>(</span><span class="literal string double">"/path/to/libarchive.so"</span><span class=punctuation>)</span><br><span class=name>CU</span> <span class=operator>=</span> <span class=name>pydffi</span><span class=operator>.</span><span class=name>FFI</span><span class=punctuation>()</span><span class=operator>.</span><span class=name>cdef</span><span class=punctuation>(</span><span class="literal string double">"#include &lt;archive.h&gt;"</span><span class=punctuation>)</span><br><span class=name>a</span> <span class=operator>=</span> <span class=name>funcs</span><span class=operator>.</span><span class=name>archive_read_new</span><span class=punctuation>()</span><br><span class=keyword>assert</span> <span class=name>a</span><br><span class=operator>...</span><br></pre>This blog post presents related works, their drawbacks, then how Clang/LLVM is used to circumvent these drawbacks, the inner working of DragonFFI and further ideas.<br>The code of the project is available on GitHub: <a href=https://github.com/aguinet/dragonffi>https://github.com/aguinet/dragonffi</a>. Python 2/3 wheels are available for Linux/OSX x86/x64. Python 3.6 wheels are available for Windows x64. On all these architectures, just use:<br><pre class="code bash literal-block">$ pip install pydffi<br></pre>and play with it :)<br><br>See below for more information.<br><br><h3>Related work</h3><tt class="docutils literal">libffi</tt> is the reference library that provides a FFI for the C language. <tt class="docutils literal">cffi</tt>&nbsp;is a Python binding around this library that also uses <tt class="docutils literal">PyCParser</tt>to be able to easily declare interfaces and types. Both these libraries have limitations, among them:<br><ul class=simple><li><tt class="docutils literal">libffi</tt> does not support the Microsoft x64 ABI under Linux x64. It isn't that trivial to add a new ABI (hand-written ABI, get the ABI right, ...), while a lot of effort have already been put into compilers to get these ABIs right.</li><li><tt class="docutils literal">PyCParser</tt> only supports a very limited subset of C (no includes, function attributes, ...).</li></ul>Moreover, in 2014, Jordan Rose and John McCall from Apple made a <a href=https://llvm.org/devmtg/2014-10/Slides/Skip%20the%20FFI.pdf>talk</a> at the LLVM developer meeting of San José about how Clang can be used for C interoperability. This talk also shows various ABI issues, and has been a source of inspiration for DragonFFI at the beginning.<br><br>Somehow related, Sean Callanan, who worked on <tt class="docutils literal">lldb</tt>, gave a <a href=http://llvm.org/devmtg/2017-10/#talk5>talk</a> in 2017 at the LLVM developer meeting of San José on how we could use parts of Clang/LLVM to implement some kind of <tt class="docutils literal">eval()</tt> for C++. What can be learned from this talk is that debuggers like <tt class="docutils literal">lldb</tt>&nbsp;must also be able to call an arbitrary C function, and uses debug information among other things to solve it (what we also do, see below :)).<br><br>DragonFFI is based on Clang/LLVM, and thanks to that it is able to get around these issues:<br><ul class=simple><li>it uses Clang to parse header files, allowing direct usage of a C library headers without adaptation;</li><li>it support as many calling conventions and function attributes as Clang/LLVM do;</li><li>as a bonus, Clang and LLVM allows on-the-fly compilation of C functions, without relying on the presence of a compiler on the system (you still need the headers of the system's libc thought, or MSVCRT headers under Windows);</li><li>and this is a good way to have fun with Clang and LLVM! :)</li></ul>Let's dive in!<br><h3>Creating an FFI library for C</h3><h4>Supporting C ABIs</h4>A C function is always compiled for a given C ABI. The C ABI isn't defined per the official C standards, and is system/architecture-dependent. Lots of things are defined by these ABIs, and it can be quite error prone to implement.<br><br>To see how ABIs can become complex, let's compile this C code:<br><br><pre class="code c literal-block"><span class=keyword>typedef</span> <span class=keyword>struct</span> <span class=punctuation>{</span><br>  <span class="keyword type">short</span> <span class=name>a</span><span class=punctuation>;</span><br>  <span class="keyword type">int</span> <span class=name>b</span><span class=punctuation>;</span><br><span class=punctuation>}</span> <span class=name>A</span><span class=punctuation>;</span><br><br><span class="keyword type">void</span> <span class="name function">print_A</span><span class=punctuation>(</span><span class=name>A</span> <span class=name>s</span><span class=punctuation>)</span> <span class=punctuation>{</span><br>  <span class=name>printf</span><span class=punctuation>(</span><span class="literal string">"%d %d</span><span class="literal string escape">\n</span><span class="literal string">"</span><span class=punctuation>,</span> <span class=name>s</span><span class=punctuation>.</span><span class=name>a</span><span class=punctuation>,</span> <span class=name>s</span><span class=punctuation>.</span><span class=name>b</span><span class=punctuation>);</span><br><span class=punctuation>}</span><br></pre><br>Compiled for Linux x64, it gives this LLVM IR:<br><pre class="code llvm literal-block"><span class=keyword><br></span></pre><pre class="code llvm literal-block"><span class=keyword>target</span> <span class=keyword>datalayout</span> <span class=punctuation>=</span> <span class="literal string">"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span><br><span class=keyword>target</span> <span class=keyword>triple</span> <span class=punctuation>=</span> <span class="literal string">"x86_64-pc-linux-gnu"</span><br><br><span class="name variable global">@.str</span> <span class=punctuation>=</span> <span class=keyword>private</span> <span class=keyword>unnamed_addr</span> <span class=keyword>constant</span> <span class=punctuation>[</span><span class="literal number">7</span> <span class=keyword>x</span> <span class=keyword>i8</span><span class=punctuation>]</span> <span class=keyword>c</span><span class="literal string">"%d %d\0A\00"</span><span class=punctuation>,</span> <span class=keyword>align</span> <span class="literal number">1</span><br><br><span class=keyword>define</span> <span class="keyword type">void</span> <span class="name variable global">@print_A</span><span class=punctuation>(</span><span class=keyword>i64</span><span class=punctuation>)</span> <span class=keyword>local_unnamed_addr</span> <span class=punctuation>{</span><br>  <span class="name variable anonymous">%2</span> <span class=punctuation>=</span> <span class=keyword>trunc</span> <span class=keyword>i64</span> <span class="name variable anonymous">%0</span> <span class=keyword>to</span> <span class=keyword>i32</span><br>  <span class="name variable anonymous">%3</span> <span class=punctuation>=</span> <span class=keyword>lshr</span> <span class=keyword>i64</span> <span class="name variable anonymous">%0</span><span class=punctuation>,</span> <span class="literal number">32</span><br>  <span class="name variable anonymous">%4</span> <span class=punctuation>=</span> <span class=keyword>trunc</span> <span class=keyword>i64</span> <span class="name variable anonymous">%3</span> <span class=keyword>to</span> <span class=keyword>i32</span><br>  <span class="name variable anonymous">%5</span> <span class=punctuation>=</span> <span class=keyword>shl</span> <span class=keyword>i32</span> <span class="name variable anonymous">%2</span><span class=punctuation>,</span> <span class="literal number">16</span><br>  <span class="name variable anonymous">%6</span> <span class=punctuation>=</span> <span class=keyword>ashr</span> <span class=keyword>exact</span> <span class=keyword>i32</span> <span class="name variable anonymous">%5</span><span class=punctuation>,</span> <span class="literal number">16</span><br>  <span class="name variable anonymous">%7</span> <span class=punctuation>=</span> <span class=keyword>tail</span> <span class=keyword>call</span> <span class=keyword>i32</span> <span class=punctuation>(</span><span class=keyword>i8</span><span class=punctuation>*,</span> <span class=punctuation>...)</span> <span class="name variable global">@printf</span><span class=punctuation>(</span><span class=keyword>i8</span><span class=punctuation>*</span> <span class=keyword>getelementptr</span> <span class=keyword>inbounds</span> <span class=punctuation>([</span><span class="literal number">7</span> <span class=keyword>x</span> <span class=keyword>i8</span><span class=punctuation>],</span> <span class=punctuation>[</span><span class="literal number">7</span> <span class=keyword>x</span> <span class=keyword>i8</span><span class=punctuation>]*</span> <span class="name variable global">@.str</span><span class=punctuation>,</span> <span class=keyword>i64</span> <span class="literal number">0</span><span class=punctuation>,</span> <span class=keyword>i64</span> <span class="literal number">0</span><span class=punctuation>),</span> <span class=keyword>i32</span> <span class="name variable anonymous">%6</span><span class=punctuation>,</span> <span class=keyword>i32</span> <span class="name variable anonymous">%4</span><span class=punctuation>)</span><br>  <span class=keyword>ret</span> <span class="keyword type">void</span><br><span class=punctuation>}</span><br></pre><br>What happens here is what is called <i>structure coercion</i>. To optimize some function calls, some ABIs pass structure values through registers. For instance, an <tt class="docutils literal"><span class=pre>llvm::ArrayRef</span></tt> object, which is basically a structure with a pointer and a size (see <a href=https://github.com/llvm-mirror/llvm/blob/release_60/include/llvm/ADT/ArrayRef.h#L51>https://github.com/llvm-mirror/llvm/blob/release_60/include/llvm/ADT/ArrayRef.h#L51</a>), is passed through registers (though this optimization isn't guaranteed by any standard).<br><br>It is important to understand that ABIs are complex things to implement and we don't want to redo this whole work by ourselves, particularly when LLVM/Clang already know how.<br><h4>Finding the right type abstraction</h4>We want to list every types that is used in a parsed C file. To achieve that goal, various information are needed, among which:<br><ul class=simple><li>the function types, and their calling convention</li><li>for structures: field offsets and names</li><li>for union/enums: field names (and values)</li></ul>On one hand, we have seen in the previous section that the LLVM IR is too Low Level (as in <b>Low Level</b> Virtual Machine) for this. On the other hand, Clang's AST is too high level. Indeed, let's print the Clang AST of the code above:<br><pre class="code bash literal-block"><span class=operator>[</span>...<span class=operator>]</span><br><span class=punctuation>|</span>-RecordDecl 0x5561d7f9fc20 &lt;a.c:1:9, line:4:1&gt; line:1:9 struct definition<br><span class=punctuation>|</span> <span class=punctuation>|</span>-FieldDecl 0x5561d7ff4750 &lt;line:2:3, col:9&gt; col:9 referenced a <span class="literal string single">'short'</span><br><span class=punctuation>|</span> <span class="literal string backtick">`</span>-FieldDecl 0x5561d7ff47b0 &lt;line:3:3, col:7&gt; col:7 referenced b <span class="literal string single">'int'</span><br></pre>We can see that there is no information about the structure layout (padding, ...). There's also no information about the size of standard C types. As all of this depends on the backend used, it is not surprising that these informations are not present in the AST.<br><br>The right abstraction appears to be the LLVM metadata produced by Clang to emit DWARF or PDB structures. They provide structure fields offset/name, various basic type descriptions, and function calling conventions. Exactly what we need! For the example above, this gives (at the LLVM IR level, with some inline comments):<br><br><pre class="code llvm literal-block"><span class=keyword>target</span> <span class=keyword>triple</span> <span class=punctuation>=</span> <span class="literal string">"x86_64-pc-linux-gnu"</span><br><span class="name variable">%struct.A</span> <span class=punctuation>=</span> <span class=keyword>type</span> <span class=punctuation>{</span> <span class=keyword>i16</span><span class=punctuation>,</span> <span class=keyword>i32</span> <span class=punctuation>}</span><br><span class="name variable global">@.str</span> <span class=punctuation>=</span> <span class=keyword>private</span> <span class=keyword>unnamed_addr</span> <span class=keyword>constant</span> <span class=punctuation>[</span><span class="literal number">7</span> <span class=keyword>x</span> <span class=keyword>i8</span><span class=punctuation>]</span> <span class=keyword>c</span><span class="literal string">"%d %d\0A\00"</span><span class=punctuation>,</span> <span class=keyword>align</span> <span class="literal number">1</span><br><br><span class=keyword>define</span> <span class="keyword type">void</span> <span class="name variable global">@print_A</span><span class=punctuation>(</span><span class=keyword>i64</span><span class=punctuation>)</span> <span class=keyword>local_unnamed_addr</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!7</span> <span class=punctuation>{</span><br>  <span class="name variable anonymous">%2</span> <span class=punctuation>=</span> <span class=keyword>trunc</span> <span class=keyword>i64</span> <span class="name variable anonymous">%0</span> <span class=keyword>to</span> <span class=keyword>i32</span><br>  <span class="name variable anonymous">%3</span> <span class=punctuation>=</span> <span class=keyword>lshr</span> <span class=keyword>i64</span> <span class="name variable anonymous">%0</span><span class=punctuation>,</span> <span class="literal number">32</span><br>  <span class="name variable anonymous">%4</span> <span class=punctuation>=</span> <span class=keyword>trunc</span> <span class=keyword>i64</span> <span class="name variable anonymous">%3</span> <span class=keyword>to</span> <span class=keyword>i32</span><br>  <span class=keyword>tail</span> <span class=keyword>call</span> <span class="keyword type">void</span> <span class="name variable global">@llvm.dbg.value</span><span class=punctuation>(</span><span class="keyword type">metadata</span> <span class=keyword>i32</span> <span class="name variable anonymous">%4</span><span class=punctuation>,</span> <span class=keyword>i64</span> <span class="literal number">0</span><span class=punctuation>,</span> <span class="keyword type">metadata</span> <span class="name variable anonymous">!18</span><span class=punctuation>,</span> <span class="keyword type">metadata</span> <span class="name variable anonymous">!19</span><span class=punctuation>),</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!20</span><br>  <span class=keyword>tail</span> <span class=keyword>call</span> <span class="keyword type">void</span> <span class="name variable global">@llvm.dbg.declare</span><span class=punctuation>(</span><span class="keyword type">metadata</span> <span class="name variable">%struct.A</span><span class=punctuation>*</span> <span class=keyword>undef</span><span class=punctuation>,</span> <span class="keyword type">metadata</span> <span class="name variable anonymous">!18</span><span class=punctuation>,</span> <span class="keyword type">metadata</span> <span class="name variable anonymous">!21</span><span class=punctuation>),</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!20</span><br>  <span class="name variable anonymous">%5</span> <span class=punctuation>=</span> <span class=keyword>shl</span> <span class=keyword>i32</span> <span class="name variable anonymous">%2</span><span class=punctuation>,</span> <span class="literal number">16</span><span class=punctuation>,</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!22</span><br>  <span class="name variable anonymous">%6</span> <span class=punctuation>=</span> <span class=keyword>ashr</span> <span class=keyword>exact</span> <span class=keyword>i32</span> <span class="name variable anonymous">%5</span><span class=punctuation>,</span> <span class="literal number">16</span><span class=punctuation>,</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!22</span><br>  <span class="name variable anonymous">%7</span> <span class=punctuation>=</span> <span class=keyword>tail</span> <span class=keyword>call</span> <span class=keyword>i32</span> <span class=punctuation>(</span><span class=keyword>i8</span><span class=punctuation>*,</span> <span class=punctuation>...)</span> <span class="name variable global">@printf</span><span class=punctuation>(</span><span class=keyword>i8</span><span class=punctuation>*</span> <span class=keyword>getelementptr</span> <span class=keyword>inbounds</span> <span class=punctuation>([...]</span> <span class="name variable global">@.str</span><span class=punctuation>,</span> <span class=keyword>i64</span> <span class="literal number">0</span><span class=punctuation>,</span> <span class=keyword>i64</span> <span class="literal number">0</span><span class=punctuation>),</span> <span class=keyword>i32</span> <span class="name variable anonymous">%6</span><span class=punctuation>,</span> <span class=keyword>i32</span> <span class="name variable anonymous">%4</span><span class=punctuation>),</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!23</span><br>  <span class=keyword>ret</span> <span class="keyword type">void</span><span class=punctuation>,</span> <span class="name variable">!dbg</span> <span class="name variable anonymous">!24</span><br><span class=punctuation>}</span><br><br><span class=punctuation>[...]</span><br><span class=comment>; DISubprogram defines (in our case) a C function, with its full type<br></span><span class="name variable anonymous">!7</span> <span class=punctuation>=</span> <span class=keyword>distinct</span> <span class="name variable">!DISubprogram</span><span class=punctuation>(</span><span class="name label">name:</span> <span class="literal string">"print_A"</span><span class=punctuation>,</span> <span class="name label">scope:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">file:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">line:</span> <span class="literal number">6</span><span class=punctuation>,</span> <span class="name label">type:</span> <span class="name variable anonymous">!8</span><span class=punctuation>,</span> [...]<span class=punctuation>,</span> <span class="name label">variables:</span> <span class="name variable anonymous">!17</span><span class=punctuation>)</span><br><span class=comment>; This defines the type of our subprogram<br></span><span class="name variable anonymous">!8</span> <span class=punctuation>=</span> <span class="name variable">!DISubroutineType</span><span class=punctuation>(</span><span class="name label">types:</span> <span class="name variable anonymous">!9</span><span class=punctuation>)</span><br><span class=comment>; We have the "original" types used for print_A, with the first one being the<br>; return type (null =&gt; void), and the other ones the arguments (in !10)<br></span><span class="name variable anonymous">!9</span> <span class=punctuation>=</span> <span class=punctuation>!{</span><span class=keyword>null</span><span class=punctuation>,</span> <span class="name variable anonymous">!10</span><span class=punctuation>}</span><br><span class="name variable anonymous">!10</span> <span class=punctuation>=</span> <span class="name variable">!DIDerivedType</span><span class=punctuation>(</span><span class="name label">tag:</span> <span class=error>DW_TAG_typedef</span><span class=punctuation>,</span> <span class="name label">name:</span> <span class="literal string">"A"</span><span class=punctuation>,</span> <span class="name label">file:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">line:</span> <span class="literal number">4</span><span class=punctuation>,</span> <span class="name label">baseType:</span> <span class="name variable anonymous">!11</span><span class=punctuation>)</span><br><span class=comment>; This defines our structure, with its various fields<br></span><span class="name variable anonymous">!11</span> <span class=punctuation>=</span> <span class=keyword>distinct</span> <span class="name variable">!DICompositeType</span><span class=punctuation>(</span><span class="name label">tag:</span> <span class=error>DW_TAG_structure_</span><span class=keyword>type</span><span class=punctuation>,</span> <span class="name label">file:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">line:</span> <span class="literal number">1</span><span class=punctuation>,</span> <span class="name label">size:</span> <span class="literal number">64</span><span class=punctuation>,</span> <span class="name label">elements:</span> <span class="name variable anonymous">!12</span><span class=punctuation>)</span><br><span class="name variable anonymous">!12</span> <span class=punctuation>=</span> <span class=punctuation>!{</span><span class="name variable anonymous">!13</span><span class=punctuation>,</span> <span class="name variable anonymous">!15</span><span class=punctuation>}</span><br><span class=comment>; We have here the size and name of the member "a". Offset is 0 (default value)<br></span><span class="name variable anonymous">!13</span> <span class=punctuation>=</span> <span class="name variable">!DIDerivedType</span><span class=punctuation>(</span><span class="name label">tag:</span> <span class=error>DW_TAG_member</span><span class=punctuation>,</span> <span class="name label">name:</span> <span class="literal string">"a"</span><span class=punctuation>,</span> <span class="name label">scope:</span> <span class="name variable anonymous">!11</span><span class=punctuation>,</span> <span class="name label">file:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">line:</span> <span class="literal number">2</span><span class=punctuation>,</span> <span class="name label">baseType:</span> <span class="name variable anonymous">!14</span><span class=punctuation>,</span> <span class="name label">size:</span> <span class="literal number">16</span><span class=punctuation>)</span><br><span class="name variable anonymous">!14</span> <span class=punctuation>=</span> <span class="name variable">!DIBasicType</span><span class=punctuation>(</span><span class="name label">name:</span> <span class="literal string">"short"</span><span class=punctuation>,</span> <span class="name label">size:</span> <span class="literal number">16</span><span class=punctuation>,</span> <span class="name label">encoding:</span> <span class=error>DW_ATE_signed</span><span class=punctuation>)</span><br><span class=comment>; We have here the size, offset and name of the member "b"<br></span><span class="name variable anonymous">!15</span> <span class=punctuation>=</span> <span class="name variable">!DIDerivedType</span><span class=punctuation>(</span><span class="name label">tag:</span> <span class=error>DW_TAG_member</span><span class=punctuation>,</span> <span class="name label">name:</span> <span class="literal string">"b"</span><span class=punctuation>,</span> <span class="name label">scope:</span> <span class="name variable anonymous">!11</span><span class=punctuation>,</span> <span class="name label">file:</span> <span class="name variable anonymous">!1</span><span class=punctuation>,</span> <span class="name label">line:</span> <span class="literal number">3</span><span class=punctuation>,</span> <span class="name label">baseType:</span> <span class="name variable anonymous">!16</span><span class=punctuation>,</span> <span class="name label">size:</span> <span class="literal number">32</span><span class=punctuation>,</span> <span class="name label">offset:</span> <span class="literal number">32</span><span class=punctuation>)</span><br><span class="name variable anonymous">!16</span> <span class=punctuation>=</span> <span class="name variable">!DIBasicType</span><span class=punctuation>(</span><span class="name label">name:</span> <span class="literal string">"int"</span><span class=punctuation>,</span> <span class="name label">size:</span> <span class="literal number">32</span><span class=punctuation>,</span> <span class="name label">encoding:</span> <span class=error>DW_ATE_signed</span><span class=punctuation>)</span><br><span class=punctuation>[...]</span><br></pre><h4>Internals</h4>DragonFFI first parses the debug information included by Clang in the LLVM IR it produces, and creates a custom type system to represent the various function types, structures, enumerations and typedefs of the parsed C file. This custom type system has been created for two reasons:<br><ul class=simple><li>create a type system that gathers only the necessary informations from the metadata tree (we don't need the whole debug informations)</li><li>make the public headers of the DragonFFI library free from any LLVM headers (so that the whole LLVM headers aren't needed to use the library)</li></ul>Once we've got this type system, the DragonFFI API for calling C functions is this one:<br><br><pre class="code cpp literal-block"><span class=name>DFFI</span> <span class="name function">FFI</span><span class=punctuation>([...]);</span><br><span class="comment single">// This will declare puts as a function that returns int and takes a const<br></span></pre><pre class="code cpp literal-block"><span class="comment single">// char* as an argument. We could also create this function type by hand.<br></span><span class=name>CompilationUnit</span> <span class=name>CU</span> <span class=operator>=</span> <span class=name>FFI</span><span class=punctuation>.</span><span class=name>cdef</span><span class=punctuation>(</span><span class="literal string">"int puts(const char* s);"</span><span class=punctuation>,</span> <span class=punctuation>[...]);</span><br><span class=name>NativeFunc</span> <span class=name>F</span> <span class=operator>=</span> <span class=name>CU</span><span class=punctuation>.</span><span class=name>getFunction</span><span class=punctuation>(</span><span class="literal string">"puts"</span><span class=punctuation>);</span><br><span class=keyword>const</span> <span class="keyword type">char</span><span class=operator>*</span> <span class=name>s</span> <span class=operator>=</span> <span class="literal string">"hello world!"</span><span class=punctuation>;</span><br><span class="keyword type">void</span><span class=operator>*</span> <span class=name>Args</span><span class=punctuation>[]</span> <span class=operator>=</span> <span class=punctuation>{</span><span class=operator>&amp;</span><span class=name>s</span><span class=punctuation>};</span><br><span class="keyword type">int</span> <span class=name>Ret</span><span class=punctuation>;</span><br><span class=name>F</span><span class=punctuation>.</span><span class=name>call</span><span class=punctuation>(</span><span class=operator>&amp;</span><span class=name>Ret</span><span class=punctuation>,</span> <span class=name>Args</span><span class=punctuation>);</span><br></pre><br>So, basically, a pointer to the returned data and an array of <tt class="docutils literal">void*</tt> is given to DragonFFI. Each <tt class="docutils literal">void*</tt> value is a pointer to the data that must be passed to the underlying function. So the last missing piece of the puzzle is the code that takes this array of <tt class="docutils literal">void*</tt> (and pointer to the returned data) and calls <tt class="docutils literal">puts</tt>, so a function like this:<br><pre class="code cpp literal-block"><span class="keyword type"><br></span></pre><pre class="code cpp literal-block"><span class="keyword type">void</span> <span class="name function">call_puts</span><span class=punctuation>(</span><span class="keyword type">void</span><span class=operator>*</span> <span class=name>Ret</span><span class=punctuation>,</span> <span class="keyword type">void</span><span class=operator>**</span> <span class=name>Args</span><span class=punctuation>)</span> <span class=punctuation>{</span><br>  <span class=operator>*</span><span class=punctuation>((</span><span class="keyword type">int</span><span class=operator>*</span><span class=punctuation>)</span><span class=name>Ret</span><span class=punctuation>)</span> <span class=operator>=</span> <span class=name>puts</span><span class=punctuation>((</span><span class=keyword>const</span> <span class="keyword type">char</span><span class=operator>*</span><span class=punctuation>)</span> <span class=name>Args</span><span class=punctuation>[</span><span class="literal number integer">0</span><span class=punctuation>]);</span><br><span class=punctuation>}</span><br></pre><br>We call these "function wrappers" (how original! :)). One advantage of this signature is that it is a generic signature, which can be used in the implementation of DragonFFI. Supposing we manage to compile at run-time this function, we can then call it trivially as in the following:<br><br><pre class="code cpp literal-block"><span class=keyword>typedef</span> <span class="name function">void</span><span class=punctuation>(</span><span class=operator>*</span><span class=name>puts_call_ty</span><span class=punctuation>)(</span><span class="keyword type">void</span><span class=operator>*</span><span class=punctuation>,</span> <span class="keyword type">void</span><span class=operator>**</span><span class=punctuation>);</span><br><span class=name>puts_call_ty</span> <span class=name>Wrapper</span> <span class=operator>=</span> <span class="comment multiline">/* pointer to the compiled wrapper function */;</span><br><span class=name>Wrapper</span><span class=punctuation>(</span><span class=name>Ret</span><span class=punctuation>,</span> <span class=name>Args</span><span class=punctuation>);</span><br></pre><pre class="code cpp literal-block"><span class=punctuation><br></span></pre>Generating and compiling a function like this is something Clang/LLVM is able to do. For the record, this is also what <tt class="docutils literal">libffi</tt> mainly does, by generating the necessary assembly <i>by hand</i>. We optimize the number of these wrappers in DragonFFI, by generating them for each different function type. So, the actual wrapper that would be generated for <tt class="docutils literal">puts</tt> is actually this one:<br><br><pre class="code cpp literal-block"><span class="keyword type">void</span> <span class="name function">__dffi_wrapper_0</span><span class=punctuation>(</span><span class="keyword type">int32_t</span><span class=punctuation>(</span> <span class=name>__attribute__</span><span class=punctuation>((</span><span class=name>cdecl</span><span class=punctuation>))</span> <span class=operator>*</span><span class=name>__FPtr</span><span class=punctuation>)(</span><span class="keyword type">char</span> <span class=operator>*</span><span class=punctuation>),</span> <span class="keyword type">int32_t</span> <span class=operator>*</span><span class=name>__Ret</span><span class=punctuation>,</span> <span class="keyword type">void</span><span class=operator>**</span> <span class=name>__Args</span><span class=punctuation>)</span> <span class=punctuation>{</span><br>  <span class=operator>*</span><span class=name>__Ret</span> <span class=operator>=</span> <span class=punctuation>(</span><span class=name>__FPtr</span><span class=punctuation>)(</span><span class=operator>*</span><span class=punctuation>((</span><span class="keyword type">char</span> <span class=operator>**</span><span class=punctuation>)</span><span class=name>__Args</span><span class=punctuation>[</span><span class="literal number integer">0</span><span class=punctuation>]));</span><br><span class=punctuation>}</span><br></pre><pre class="code cpp literal-block"><span class=punctuation><br></span></pre>For now, all the necessary wrappers are generated when the <tt class="docutils literal"><span class=pre>DFFI::cdef</span></tt> or <tt class="docutils literal"><span class=pre>DFFI::compile</span></tt> APIs are used. The only exception where they are generated on-the-fly (when calling <tt class="docutils literal"><span class=pre>CompilationUnit::getFunction</span></tt>) is for variadic arguments. One possible evolution is to let the user chooses whether he wants this to happen on-the-fly or not for every declared function.<br><h3>Issues with Clang</h3>There is one major issue with Clang that we need to hack around in order to have the <tt class="docutils literal"><span class=pre>DFFI::cdef</span></tt> functionality: unused declarations aren't emitted by Clang (even when using <tt class="docutils literal"><span class=pre>-g</span> <span class=pre>-femit-all-decls</span></tt>).<br><br>Here is an example, produced from the following C code:<br><br><pre class="code c literal-block"><span class=keyword>typedef</span> <span class=keyword>struct</span> <span class=punctuation>{</span><br>  <span class="keyword type">short</span> <span class=name>a</span><span class=punctuation>;</span><br>  <span class="keyword type">int</span> <span class=name>b</span><span class=punctuation>;</span><br><span class=punctuation>}</span> <span class=name>A</span><span class=punctuation>;</span><br><br><span class="keyword type">void</span> <span class="name function">print_A</span><span class=punctuation>(</span><span class=name>A</span> <span class=name>s</span><span class=punctuation>);</span><br></pre><pre class="code sh literal-block">$ clang -S -emit-llvm -g -femit-all-decls -o - a.c <span class=punctuation>|</span>grep print_A <span class=punctuation>|</span>wc -l<br><span class="literal number">0</span><br></pre><br>The produced LLVM IR does not contain a function named <tt class="docutils literal">print_A</tt>! The hack we temporarily use parses the clang AST and generates temporary functions that looks like this:<br><pre class="code cpp literal-block"><span class="keyword type"><br></span></pre><pre class="code cpp literal-block"><span class="keyword type">void</span> <span class="name function">__dffi_force_decl_print_A</span><span class=punctuation>(</span><span class=name>A</span> <span class=name>s</span><span class=punctuation>)</span> <span class=punctuation>{</span> <span class=punctuation>}</span><br></pre><br>This forces LLVM to generate an empty function named <tt class="docutils literal">__dffi_force_decl_print_A</tt> with the good arguments (and associated debug informations).<br><br>This is why DragonFFI proposes another API, <tt class="docutils literal"><span class=pre>DFFI::compile</span></tt>. This API does not force declared-only functions to be present in the LLVM IR, and will only expose functions that end up naturally in the LLVM IR after optimizations.<br><br>If someone has a better idea to handle this, please let us know!<br><h3>Python bindings</h3>Python bindings were the first ones to have been written, simply because it's the "high level" language I know best. &nbsp;Python provides its own set of challenges, but we will save that for another blog post. &nbsp;These Python bindings are built using <a href=https://github.com/pybind/pybind11>pybind11</a>, and provides their own set of C types. Lots of example of what can be achieved can be found <a href=https://github.com/aguinet/dragonffi/tree/dffi-0.2.1/examples>here</a> and <a href=https://github.com/aguinet/dragonffi/tree/dffi-0.2.1/bindings/python/tests>here</a>.<br><h3>Project status</h3>DragonFFI currently supports Linux, OSX and Windows OSes, running on Intel 32 and 64-bits CPUs. Travis is used for continuous integration, and every changes is validated on all these platforms before being integrated.<br><br>The project will go from alpha to beta quality when the 0.3 version will be out (which will bring Travis and Appveyor CI integration and support for variadic functions). The project will be considered stable once these things happen:<br><ul class=simple><li>user and developer documentations exist!</li><li>another foreign language is supported (JS? Ruby?)</li><li>the DragonFFI main library API is considered stable</li><li>a non negligible list of tests have been added</li><li>all the things in the <tt class="docutils literal">TODO</tt> file have been done :)</li></ul><h3>Various ideas for the future</h3>Here are various interesting ideas we have for the future. We don't know yet when they will be implemented, but we think some of them could be quite nice to have.<br><h4>Parse embedded DWARF information</h4>As the entry point of DragonFFI are DWARF informations, we could imagine parsing these debug informations from shared libraries that embed them (or provide them in a separate file). The main advantage is that all the necessary information for doing the FFI right are in one file, the header files are no longer required. The main drawback is that debug informations tend to take a lot of space (for instance, DWARF informations take 1.8Mb for <tt class="docutils literal">libarchive</tt> 3.32 compiled in release mode, for an original binary code size of 735Kb), and this brings us to the next idea.<br><h4>Lightweight debug info?</h4>The DWARF standard allows to define lots of information, and we don't need all of them in our case. We could imagine embedding only the necessary DWARF objects, that is just the necessary types to call the exported functions of a shared library. One experiment of this is available here: <a href=https://github.com/aguinet/llvm-lightdwarf>https://github.com/aguinet/llvm-lightdwarf</a>. This is an LLVM optimisation pass that is inserted at the end of the optimisation pipeline, and parse metadata to only keep the relevant one for DragonFFI. More precisely, it only keeps the dwarf metadata related to <b>exported</b> and <b>visible</b> functions, with the associated types. It also keeps debug information of global variables, even thought these ones aren't supported yet in DragonFFI. It also does some unconventional things, like replacing every file and directory by "_", to save space. "Fun" fact, to do this, it borrows some code from the LLVM bitcode "obfuscator" included in recent Apple's clang version, that is used to anonymize some information from the LLVM bitcode that is sent with tvOS/iOS applications (see <a href=http://lists.llvm.org/pipermail/llvm-dev/2016-February/095588.html>http://lists.llvm.org/pipermail/llvm-dev/2016-February/095588.html</a> for more information).<br><br>Enough talking, let's see some preliminary results (on Linux x64):<br><ul class=simple><li>on libarchive 3.3.2, DWARF goes from 1.8Mb to 536Kb, for an original binary code size of 735Kb</li><li>on zlib 1.2.11, DWARF goes from 162Kb to 61Kb, for an original binary code size of 99Kb</li></ul>The instructions to reproduce this are available in the README of the LLVM pass repository.<br>We can conclude that defining this "light" DWARF format could be a nice idea. One other thing that could be done is defining a new binary format, that would be thus more space-efficient, but there are drawbacks going this way:<br><ul class=simple><li>debug informations are well supported on every platform nowadays: tools exist to parse them, embed/extract them from binary, and so on</li><li>we already got DWARD and PDB: <a href=https://xkcd.com/927/>https://xkcd.com/927/</a></li></ul>Nevertheless, it still could be a nice experiment to try and do this, figuring out the space won and see if this is worth it!<br><br>As a final note, these two ideas would also benefit to <tt class="docutils literal">libffi</tt>, as we could process these formats and create <tt class="docutils literal">libffi</tt> types!<br><h4>JIT code from the final language (like Python) to native function code</h4>One advantage of embedding a full working C compiler is that we could JIT the code from the final language glue to the final C function call, and thus limit the performance impact of this glue code.<br>Indeed, when a call is issued from Python, the following things happen:<br><ul class=simple><li>arguments are converted from Python to C according to the function type</li><li>the function pointer and wrapper and gathered from DragonFFI</li><li>the final call is made</li></ul>All this process involves basically a loop on the types of the arguments of the called function, which contains a big switch case. This loop generates the array of <tt class="docutils literal">void*</tt> values that represents the C arguments, which is then passed to the wrapper. We could JIT a specialised version of this loop for the function type, inline the already-compiled wrapper and apply classical optimisation on top of the resulting IR, and get a straightforward conversion code specialized for the given function type, directly from Python to C.<br><br>One idea we are exploring is combining <a href=https://github.com/jmmartinez/easy-just-in-time>easy::jit</a>&nbsp;(hello fellow Quarkslab teammates!) with <a href=http://www.llpe.org/>LLPE</a> to achieve this goal.<br><h4>Reducing DragonFFI library size</h4>The DragonFFI shared library embed statically compiled versions of LLVM and Clang. The size of the final shared library is about 55Mb (stripped, under Linux x64). This is really really huge, compared for instance to the 39Kb of libffi (also stripped, Linux x64)!<br><br>Here are some idea to try and reduce this footprint:<br><ul class=simple><li>compile DragonFFI, Clang and LLVM using (Thin) LTO, with visibility hidden for both Clang and LLVM. This could have the effect of removing code from Clang/LLVM that isn't used by DragonFFI.</li><li>make DragonFFI more modular: - one core module that only have the parts from CodeGen that deals with ABIs. If the types and function prototypes are defined "by hand" (without <tt class="docutils literal"><span class=pre>DFFI::cdef</span></tt>), that's more or less the only part that is needed (with LLVM obviously) - one optional module that includes the full clang compiler (to provide the <tt class="docutils literal"><span class=pre>DFFI::cdef</span></tt> and <tt class="docutils literal"><span class=pre>DFFI::compile</span></tt> APIs)</li></ul>Even with all of this, it seems to be really hard to match the 39Kb of <tt class="docutils literal">libffi</tt>, even if we remove the <tt class="docutils literal">cdef</tt>/<tt class="docutils literal">compile</tt> API from DragonFFI. As always, pick the right tool for your needs :)<br><h3>Conclusion</h3>Writing the first working version of DragonFFI has been a fun experiment, that made me discover new parts of Clang/LLVM :) The current goal is to try and achieve a first stable version (see above), and experiment with the various cited ideas.<br><br>It's a really long road, so feel free to come on <tt class="docutils literal">#dragonffi</tt> on FreeNode for any questions/suggestions you might have, (inclusive) or if you want to contribute!<br><h3>Acknowledgments</h3>Thanks to Serge «sans paille» Guelton for the discussions around the Python bindings, and for helping me finding the name of the project :) (one of the most difficult task). Thanks also to him, <a href=https://twitter.com/_kamino_/>Fernand Lone-Sang</a> and <a href=https://twitter.com/wiskitki>Kévin Szkudlapski</a> for their review of this blog post!</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2018/03/international-womens-day-celebrating.html><i class="fa fa-chevron-circle-left"></i> International Women's Day: Celebrating all the women in the LLVM Community!</a></li><li><a href=https://blog.llvm.org/2018/08/2018-llvm-foundations-women-in.html>2018 LLVM Foundation's Women in Compilers and Tools Workshop <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>