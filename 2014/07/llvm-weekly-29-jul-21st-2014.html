<!doctype html><html lang=en><head><title>LLVM Weekly - #29, Jul 21st 2014 - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Alex Bradbury"><meta property="og:url" content="https://blog.llvm.org/2014/07/llvm-weekly-29-jul-21st-2014.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="LLVM Weekly - #29, Jul 21st 2014"><meta property="og:description" content="Welcome to the twenty-ninth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects.LLVM Weekly is brought to you by Alex Bradbury."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-07-21T03:31:00+00:00"><meta property="article:modified_time" content="2014-07-21T03:31:00+00:00"><meta property="article:tag" content="Llvmweekly"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM Weekly - #29, Jul 21st 2014"><meta name=twitter:description content="Welcome to the twenty-ninth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects.LLVM Weekly is brought to you by Alex Bradbury."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>LLVM Weekly - #29, Jul 21st 2014</h1><aside><ul><li><time class=post-date datetime=2014-07-21T03:31:00Z>Jul 21, 2014</time></li><li><em><a href=https://blog.llvm.org/tags/llvmweekly>#llvmweekly</a></em></li><li>12 minute read</li></ul></aside><p>Welcome to the twenty-ninth issue of LLVM Weekly, a weekly newsletter (published every Monday) covering developments in LLVM, Clang, and related projects.LLVM Weekly is brought to you by <a href=http://asbradbury.org>Alex Bradbury</a>.Subscribe to future issues at <a href=http://llvmweekly.org>http://llvmweekly.org</a> and pass it on to anyone else you think may be interested. Please send any tips or feedback to <a href=mailto:asb@asbradbury.org>asb@asbradbury.org</a>, or <a href=https://twitter.com/llvmweekly>@llvmweekly</a> or <a href=https://twitter.com/asbradbury>@asbradbury</a> on Twitter.</p><p>This is a special extended issue which I'm choosing to subtitle "LLVM Weekly visits the GNU Tools Cauldron". The <a href=https://gcc.gnu.org/wiki/cauldron2014>event</a> took place over the weekend and had a wide range of interesting talks. You can find my notes at the end of this newsletter. Talks were recorded and the videos should be made available in the next month or two.</p><p>The canonical home for this issue <a href=http://llvmweekly.org/issue/29>can be found here at llvmweekly.org</a>.</p><a name=more></a><h3>News and articles from around the web</h3><p>The eighth annual LLVM Developers meeting has been <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74893>announced</a> and will take place on October 28th and 29th in San Jose, CA. It is looking for sponsors and talk/poster submissions.</p><p>A new blog post as been published on the LLVM Blog giving <a href=http://blog.llvm.org/2014/07/ftl-webkits-llvm-based-jit.html>more details on FTL: WebKit's LLVM-based JIT</a>.</p><p>A tentative <a href=http://article.gmane.org/gmane.comp.compilers.clang.devel/37785>schedule for the release of LLVM/Clang 3.5</a> has been posted.</p><p>Botond Ballo has posted a <a href=http://botondballo.wordpress.com/2014/07/17/trip-report-c-standards-committee-meeting-in-rapperswil-june-2014/>summary of June's C++ Standards Committee Meeting</a>.</p><h3>On the mailing lists</h3><ul><li><p>Hal Finkel has posted an <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74941>RFC on adding an IR-level intrinsic to LLVM to represent invariants</a>. These are conditions that the optimizer is allowed to assume will be valid during the execution of the program. The post also comes with a complete set of patches implementing the concept. An issue raised by Philip Reames is that by representing the invariant as an IR instruction, this may affect profitability heuristics in optimisation passes. Chandler Carruth followed up with a <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74946>clear description of the trade-offs</a> which it seems people mostly agree with.</p></li><li><p>Yuri Gribov has re-opened a previously discussed issue, that <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74863>LLVM and GCC set the frame pointer to point to different stack slots on ARM</a>. Renato Golin <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74908>responded</a> with an explanation of how GCC ended up doing things differently. The AddressSanitizer people would prefer things to be unified so they can use knowledge of the layout to perform unwinding without using tables (a speed optimisation). It doesn't seem likely that either LLVM or GCC will be changing though.</p></li><li><p>Diego Novillo is <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74881>soliciting feedback on integrating his autofdo tool into LLVM</a>. AutoFDO is a tool that converts data collected from Linux perf to a format that can be used by LLVM.</p></li><li><p>Philip Reames <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74887>asks whether anyone has implemented a framework for asking liveness questions for SSA values in the IR</a>. The lack of an immediate answer suggests they have not, though Andrew Trick points to <a href=http://hal.inria.fr/docs/00/58/53/03/PDF/RR-7503.pdf>Computing Liveness Sets for SSA-Form Programs</a> while Dibyendu Das points to <a href=http://hal.inria.fr/docs/00/64/73/69/PDF/ramakrishna_taco.pdf>Efficient Liveness Computation Using Merge Sets and DJ-Graphs</a> which is along the same lines.</p></li><li><p>Tim Northover has written an RFC suggesting that <a href=http://article.gmane.org/gmane.comp.compilers.clang.devel/37777>llvm.convert.to.fp16 and related intrinsics should be dropped</a>. Instead the 'half' type can be used in combination with fpext/fptrunc.</p></li><li><p>Chandler Carruth has written an RFC regarding <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/75018>legalizing operations and post-legalization DAG combining</a>. It's only just been posted so there's no feedback yet.</p></li><li><p>Andrew Kaylor has <a href=http://article.gmane.org/gmane.comp.compilers.llvm.devel/74930>proposed</a> that Lang Hames take over from him as code owner for MCJIT, RuntimeDyld, and JIT event listener. This was agreed and <code>CODE_OWNERS.txt</code> has been updated appropriately.</p></li></ul><h3>LLVM commits</h3><ul><li><p>A dereferenceable attribute was added. This indicates that the parameter or return pointer is dereferenceable (i.e. can be loaded from speculatively without a risk of trapping). This is subtly different to the nonnull attribute which doesn't necessarily imply dereferenceability (you might for instance have a pointer to one element past the end of an array). <a href=http://reviews.llvm.org/rL213385>r213385</a>.</p></li><li><p>A new subtarget hook was added to allow targets to opt-out of register coalescing.<a href=http://reviews.llvm.org/rL213078>r213078</a>, <a href=http://reviews.llvm.org/rL213188>r213188</a>.</p></li><li><p>A MergedLoadStoreMotion pass was added. <a href=http://reviews.llvm.org/rL213396>r213396</a>.</p></li><li><p>RegionInfo has been templatified to it works on MachineBasicBlocks. <a href=http://reviews.llvm.org/rL213456>r213456</a>.</p></li><li><p>A monster patch from Nvidia adds a whole bunch of surface/texture intrinsics to the NVPTX backend. <a href=http://reviews.llvm.org/rL213256>r213256</a>.</p></li><li><p>Support was added for emitting warnings if vectorization is forced and fails. <a href=http://reviews.llvm.org/rL213110>r213110</a>.</p></li><li><p>Improvements to FastISel continue with the implementation of the FastLowerCall hook for X86. This actually reproduces what was already being done in X86, but is refactored against the target independent call lowering. <a href=http://reviews.llvm.org/rL213049>r213049</a>.</p></li><li><p>The ARM dmb, dsb and isb intrinsics have been implemented for AARch64. <a href=http://reviews.llvm.org/rL213247>r213247</a>.</p></li></ul><h3>Clang commits</h3><ul><li><p>Clang's rewrite engine is now a core feature (i.e. it can not be disabled at configure time). <a href=http://reviews.llvm.org/rL213171>r213171</a>.</p></li><li><p>Error recovery when the programmer mistypes <code>::</code> as <code>:</code> was improved. <a href=http://reviews.llvm.org/rL213120>r213120</a>.</p></li><li><p>The AARch64 Clang CLI interface proposal for <code>-march</code> has been implemented. See the commit message for details. <a href=http://reviews.llvm.org/rL213353>r213353</a>.</p></li><li><p>OpenMP work continues with the addition of initial parsing and semantic analysis for the <code>final</code>, <code>untied</code> and other clauses, and the <code>master</code> directive. <a href=http://reviews.llvm.org/rL213232>r213232</a>, <a href=http://reviews.llvm.org/rL213257>r213257</a>, <a href=http://reviews.llvm.org/rL213237>r213237</a>, and more.</p></li></ul><h3>Other project commits</h3><ul><li>The 'Kalimba' platform is now supported by lldb (presumably this refers to the CSR processor). <a href=http://reviews.llvm.org/rL213158>r213158</a>.</li></ul><h3>LLVM Weekly at the GNU Tools Cauldron</h3><p>For full details on the conference and details on the speakers for the talks I've summarised below see the <a href=https://gcc.gnu.org/wiki/cauldron2014>GNU Tools Cauldron 2014 web page</a>. Apologies for any inaccuracies, please do get in touch if you spot anything I may have noted incorrectly. LLVM followers may be particularly interested in Renato Golin's talk on collaboration between the GCC and LLVM communities.</p><h4>Glibc BoF</h4><ul><li>2.20 is in "slushy" freeze mode. What else is left? fmemopen, fd locking, some <code>-Wundef</code> work</li><li>Anyone planning to check in something big for 2.21?<ul><li>Mentor Graphics planning to check in a NIOS II port. They won't be accepted until Linux kernel patches are in a kernel release.</li><li>A desire for AArch64 ILP32 ABI to get in. Kernel patches currently in review, compiler work is ready.</li><li>OpenRISC</li><li>NaCl (nptl)</li></ul></li><li>Benchmarking glibc? Does anyone have a good approach. There is a preload library approach (see notes from Ondrej's talk).</li><li>Glibc has been built with AddressSanitizer, help needed to get it integrated into the build system. There was a comment this would be nice to get in to distributions.</li><li>Red Hat are working on supporting alternate libm implementations, including a low-precision and high-precision implementation. Intel are looking to add math functions that work on small vectors.</li></ul><h4>Abigail: toward ABI taming</h4><ul><li>Want to determine if changes to your shared library break apps for users, and users want to know whether an updated library remains compatible with their code. The bidiff tool will tell you the differences in terms of ABI given two object files as its input.</li><li>libabi consists of modules such as a DWARF reader, the comparison engine. Tools such as bidiff are built on this API</li><li>What's next for libabigail?<ul><li>bicompat will help application authors determine whether their application A is still compatibile with an updated version of a given library L by examining the undefined symbols of A that are resolved by L.</li><li>More amenable to automation (such as integration into build systems)</li><li>Support for un-instantiated templates. This would require declarations of uninstantiated templates to be represented in DWARF.</li></ul></li><li>A first official release (though source is available at <a href=https://sourceware.org/libabigail/>https://sourceware.org/libabigail/</a>)</li></ul><h4>Writing VMs in Java and debugging them with GDB</h4><ul><li>Oracle Labs have been working on various dynamic language implementations in Java (e.g. Ruby, Python, R, JS, ...).</li><li>FastR is a reimplementation of R in Java featuring an interpreter (Truffle) and dynamic compiler (Graal).</li><li>Truffle and Graal starts with an AST interpreter. The first time a node is evaluated it is specialised to the type that was seen at runtime. Later the tree is compiled using partial evaluation.</li><li>It may be deployed on standard HotSpot (no compilation), GraalVM, or the SubstrateVM (SVM) which uses Graal to ahead-of-time compile the language implementation. Debugging the SVM is difficult as Java debugging tools are not available. The solution is to generate DWARF information in the SVM's output.</li><li>Truffle and Graal are open source, the SubstrateVM is not (yet?).</li></ul><h4>GCC and LLVM collaboration</h4><ul><li>Good news: license issues, personal grudges and performance are off-topic.</li><li>Users should be protected from whatever disagreements take place. In the future we should have more pro-active discussions on various issues as opposed to reactive discussions regarding e.g. compiler flags that have been noticed to be arbitrarily different after the fact.</li><li>Renato lists common projects that we may collaborate on: binutils, glibc, sanitizers. Sanitizers are a collaboration success story.</li><li>Can we agree on a (new?) common user interface?</li><li>There's a surprising amount of confusion about <code>-march</code>, <code>-mtune</code>, and <code>-mcpu</code> considering we're in a room of compiler developers. It sounds like there's not much support for re-engineering the set of compiler flags as the potential gain is not seen as being great enough.</li><li>Can we agree to standardise on attributes, C/C++ extensions, builtins, ASM, the linker API?</li><li>GCC docs have just been rewritten, so some criticisms about how difficult it is to dig in are no longer valid.</li></ul><h4>Machine Guided Energy Efficient Compilation</h4><ul><li>Initial investigations in 2012 found that compiler flags can have a meaningful effect on energy consumption. This raises the question of how to determine which flags to use.</li><li>MAGEEC will target both GCC and LLVM initially. It is implemented as a compiler plugin which performs feature extraction and allows the output of the machine learning algorithm to change the sequence of passes which are run. Fractional Factorial Design is used to reduce the optimisation space to explore.</li><li>Turning passes on/off arbitrarily can often result in internal compiler errors. Should the machine learning algorithm learn this, or should GCC better document pass requirements?</li><li>It would be useful to MAGEEC if the (currently internal) plugin API could be stabilized. They also currently have to use a hacked up Clang as it doesn't provide plugin hooks.</li><li>The project has produced a low cost energy measurement board as well as their own benchmark suite (Bristol/Embecosm Embedded Benchmark Suite, or BEEBS). BEEBS 2.0 is schedule for release by 31st August 2014 with a much wider range of benchmarks (currently 93). Jeremy showed a rather pleasing live demo where you can run a benchmark on a microcontroller development board and immediately find the number of mJ consumed in running it.</li><li>The current state of the project has it not achieving better results than GCC O2, but this is expected to change over the coming months.</li></ul><h4>Just-in-time compilation using GCC</h4><ul><li><a href=https://gcc.gnu.org/wiki/JIT>libgccjit.so</a> is an experimental branch of GCC which allows you to build GCC as a shared library and embed it in other programs in order to allow in-process code generation at runtime.</li><li>A dedicated API for JIT will allow better stability guarantees. It provides a high-level API designed for ease of use.</li><li>The API doesn't offer solutions for type inference, escape analysis, unboxing, inline caching, etc.</li><li>It has a C++ API wich includes some cunning operator overloading to massively reduce verbosity, and a Python API.</li><li>David Malcolm has written <a href=https://github.com/davidmalcolm/coconut>Coconut</a>, a JIT compiler for Python using libgccjit.so. It is incomplete and experimental.</li><li>Drawback: currently have to write out a .s to a file and invoke gcc on it.<br>Some might make a cheeky comment about the benefits of architecting a compiler so it can be used as a library, but I of course wouldn't dare. The good news is the speaker is actively looking at what would be needed to use GAS and GNU ld as a library.</li></ul><h4>Introduction to new Intel SIMD ISA and its impact on GCC</h4><ul><li>AVX-512 offers 64 simple precision or 32 double precision floating point operations per cycle. It also has 8x64-bit mask registers.</li><li>Rounding modes can be set on a per-instruction process</li><li>Basic support is available from GCC 4.9.x.</li></ul><h4>News from Sanitizers</h4><ul><li>MemorySanitizer detects use of uninitialized memory. Increases CPU by about 2.5x and RAM by 2x. Was released in LLVM in 2013. It is currently Linux/x86-64 only.</li><li>History growth is limited by limiting the history depth and the number of new history nodes per stack trace.</li><li>MSan has found hundreds of bugs across Google internal code, Chromium, LLVM, etc. It was more challenging for Chromium due to the number of system libs that had to be rebuilt.</li><li>AddressSanitizer annotations allows you to detect access to the regions of e.g. <code>std::vector&lt;></code> which has been allocated as part of its capacity but not yet been used (i.e. will start to be used in the next <code>push_back</code>). Next is to do the same for <code>std::string</code> and <code>std::deque</code>.</li><li>Glibc uses GNU-C instead of ANSI C which currently prevents compilation with Clang (nested functions in particular are problematic). It can however be built with ASan by GCC.</li><li>Evgeniy comments that the lack of standardisation between Clang and GCC for things like <code>__has_feature(address_sanitizer)</code> vs <code>__SANITIZE_ADDRESS__</code> is irritating. This is just the sort of thing Renato was talking about yesterday of course.</li></ul><h4>glibc performance tuning</h4><ul><li>Use memset as an example. Look at 3 variants.</li><li>Writing a useful benchmark is more difficult than you might think. Simply running <code>memset</code> many times in a loop is not a good benchmark when using the same memory locations due to the processor's load-store forwarding. Even when fixing this, the branch predictor may perform much better than it would when memset is used in a real world scenario and lead to unrepresentative results.</li><li>To move beyond microbenchmarks, Ondrej has been using <code>LD_PRELOAD</code> to link against instrumented versions of the functions which record details about the time taken.</li><li>See <a href=http://kam.mff.cuni.cz/~ondra/benchmark_string/i7_nehalem/memset_profile/results_gcc/result.html>here</a>for memset benchmarks and <a href=http://kam.mff.cuni.cz/~ondra/benchmark_string/i7_nehalem/memset_profile/results_gcc/doc/properties.html>here</a> for more background.</li><li>strcmp was the most frequently called glibc function in Ondrej's testing (when running Firefox).</li></ul><h4>Devirtualization in GCC</h4><ul><li>This is a special case of indirect call removal, and although the talk is given in the context of C++ the techniques apply to other languages too. Some basic cases are handled in the front-end and even specified by the language standard.</li><li>It is a special case of constant propagation across aggregates, which is already done by Global Value Numbering and Interprocedural Constant Propagation. But these passes only catch a tiny number of possible cases.</li><li>Loss of information between the frontend and middle end can make some cases almost impossible. The intermediate language can be extended with explicit representations of base types, locations of virtual table pointers, and vtables. Also annotate polymorphic calls specifying instance and polymorphic call type and flags to denote constructors/destructors.</li><li>I'm not able to summarise details on the GCC devirt implementation better than the slides do. Hopefully they'll be made available online.</li><li>A particular challenge is to match types between different compilation units. The C++ One Definition Rule is used.</li><li>It can be used to strengthen unreachable function removal.</li><li>Feedback-directed devirtualization was extended in GCC 4.9 to work inter-module with LTO.</li></ul></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2014/07/ftl-webkits-llvm-based-jit.html><i class="fa fa-chevron-circle-left"></i> FTL: WebKit’s LLVM based JIT</a></li><li><a href=https://blog.llvm.org/2014/07/llvm-weekly-30-jul-28th-2014.html>LLVM Weekly - #30, Jul 28th 2014 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>