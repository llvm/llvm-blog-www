<!doctype html><html lang=en><head><title>New Loop Vectorizer - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Nadav Rotem"><meta property="og:url" content="https://blog.llvm.org/2012/12/new-loop-vectorizer.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="New Loop Vectorizer"><meta property="og:description" content="I would like to give a brief update regarding the development of the Loop Vectorizer. LLVM now has two vectorizers: The Loop Vectorizer, which operates on Loops, and the Basic Block Vectorizer, which optimizes straight-line code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-12-07T10:12:00+00:00"><meta property="article:modified_time" content="2012-12-07T10:12:00+00:00"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Codegen"><meta property="article:tag" content="New-in-Llvm-3.3"><meta name=twitter:card content="summary"><meta name=twitter:title content="New Loop Vectorizer"><meta name=twitter:description content="I would like to give a brief update regarding the development of the Loop Vectorizer. LLVM now has two vectorizers: The Loop Vectorizer, which operates on Loops, and the Basic Block Vectorizer, which optimizes straight-line code."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>New Loop Vectorizer</h1><aside><ul><li>By Nadav Rotem</li><li><time class=post-date datetime=2012-12-07T10:12:00Z>Dec 7, 2012</time></li><li><em><a href=https://blog.llvm.org/tags/optimization>#optimization</a>
,
<a href=https://blog.llvm.org/tags/codegen>#codegen</a>
,
<a href=https://blog.llvm.org/tags/new-in-llvm-3.3>#new-in-llvm-3.3</a></em></li><li>5 minute read</li></ul></aside>I would like to give a brief update regarding the development of the Loop Vectorizer. LLVM now has two vectorizers: The Loop Vectorizer, which operates on Loops, and the <a href=http://llvm.org/devmtg/2012-04-12/Slides/Hal_Finkel.pdf>Basic Block Vectorizer</a>, which optimizes straight-line code. These vectorizers focus on different optimization opportunities and use different techniques. The BB vectorizer merges multiple scalars that are found in the code into vectors while the Loop Vectorizer widens instructions in the original loop to operate on multiple consecutive loop iterations.<br><a name=more></a><br>LLVM’s Loop Vectorizer is now available and will be useful for many people. It is not enabled by default, but can be enabled through clang using the command line flag <b>"-mllvm -vectorize-loops"</b>. We plan to enable the Loop Vectorizer by default as part of the LLVM 3.3 release.<br><br>The Loop Vectorizer can boost the performance of many loops, including some loops that are not vectorizable by GCC. In one benchmark, Linpack-pc, the Loop Vectorizer boosts the performance of gaussian elimination of single precision matrices from 984 MFlops to 2539 MFlops - a 2.6X boost in performance. The vectorizer also boosts the “GCC vectorization examples” <a href=http://llvm.org/viewvc/llvm-project/test-suite/trunk/SingleSource/UnitTests/Vectorizer/>benchmark</a> by a geomean of 2.15X.<br><br>The LLVM Loop Vectorizer has a number of features that allow it to vectorize complex loops. Most of the features described in this post are available as part of the LLVM 3.2 release, but some features were added after the cutoff date. Here is one small example of a loop that the LLVM Loop Vectorizer can vectorize.<br><pre style=background:#fff;color:#000><br><span style=color:maroon;font-weight:700>int</span> foo<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span>A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span>B<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> n<span style=color:#808030>)</span> <span style=color:purple>{</span><br>  <span style=color:maroon;font-weight:700>unsigned</span> sum <span style=color:#808030>=</span> <span style=color:#008c00>0</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>for</span> <span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> i <span style=color:#808030>=</span> <span style=color:#008c00>0</span><span style=color:purple>;</span> i <span style=color:#808030>&lt;</span> n<span style=color:purple>;</span> <span style=color:#808030>+</span><span style=color:#808030>+</span>i<span style=color:#808030>)</span><br>    <span style=color:maroon;font-weight:700>if</span> <span style=color:#808030>(</span>A<span style=color:#808030>[</span>i<span style=color:#808030>]</span> <span style=color:#808030>&gt;</span> B<span style=color:#808030>[</span>i<span style=color:#808030>]</span><span style=color:#808030>)</span><br>      sum <span style=color:#808030>+</span><span style=color:#808030>=</span> A<span style=color:#808030>[</span>i<span style=color:#808030>]</span> <span style=color:#808030>+</span> <span style=color:#008c00>5</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>return</span> sum<span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre><br>In this example, the Loop Vectorizer uses a number of non-trivial features to vectorize the loop. The ‘sum’ variable is used by consecutive iterations of the loop. Normally, this would prevent vectorization, but the vectorizer can detect that ‘sum’ is a reduction variable. The variable ‘sum’ becomes a vector of integers, and at the end of the loop the elements of the array are added together to create the correct result. We support a number of different reduction operations, such as multiplication.<br><br>Another challenge that the Loop Vectorizer needs to overcome is the presence of control flow in the loop. The Loop Vectorizer is able to "flatten" the IF statement in the code and generate a single stream of instructions. Another important feature is the vectorization of loops with an unknown trip count. In this example, ‘n’ may not be a multiple of the vector width, and the vectorizer has to execute the last few iterations as scalar code. Keeping a scalar copy of the loop increases the code size.<br>The loop above is compiled into the ARMv7s assembly sequence below. Notice that the IF structure is replaced by the "vcgt" and "vbsl" instructions.<br><br><pre style=color:#000;background:#fff><span style=color:#e34adc>LBB0_3:</span><br>    vld1.32      <span style=color:#808030>{</span>d26<span style=color:#808030>,</span> d27<span style=color:#808030>}</span><span style=color:#808030>,</span> <span style=color:#808030>[</span>r3<span style=color:#808030>]</span><br>    vadd.i32     q12<span style=color:#808030>,</span> q8<span style=color:#808030>,</span> q9<br>    subs         r2<span style=color:#808030>,</span> #<span style=color:#008c00>4</span><br>    add.w        r3<span style=color:#808030>,</span> r3<span style=color:#808030>,</span> #<span style=color:#008c00>16</span><br>    vcgt.s32     q0<span style=color:#808030>,</span> q13 <span style=color:#808030>,</span> q10<br>    vmla.i32     q12<span style=color:#808030>,</span> q13<span style=color:#808030>,</span> q11<br>    vbsl         q0<span style=color:#808030>,</span> q12<span style=color:#808030>,</span> q8<br>    vorr         q8<span style=color:#808030>,</span> q0<span style=color:#808030>,</span> q0<br>    bne    <span style=color:#e34adc>LBB0_3</span><br></pre><br>In the second example below, the Loop Vectorizer must use two more features in order to vectorize the loop. In the loop below, the iteration start and finish points are unknown, and the Loop Vectorizer has a mechanism to vectorize loops that do not start at zero. This feature is important for loops that are converted from Fortran, because Fortran loops start at 1.<br>Another major challenge in this loop is memory safety. In our example, if the pointers A and B point to consecutive addresses, then it is illegal to vectorize the code because some elements of A will be written before they are read from array B.<br><br>Some programmers use the 'restrict' keyword to notify the compiler that the pointers are disjointed, but in our example, the Loop Vectorizer has no way of knowing that the pointers A and B are unique. The Loop Vectorizer handles this loop by placing code that checks, at runtime, if the arrays A and B point to disjointed memory locations. If arrays A and B overlap, then the scalar version of the loop is executed.<br><pre style=background:#fff;color:#000><br><span style=color:maroon;font-weight:700>void</span> bar<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>float</span> <span style=color:#808030>*</span>A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>float</span> <span style=color:#808030>*</span>B<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>float</span> K<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> start<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> end<span style=color:#808030>)</span> <span style=color:purple>{</span><br>&nbsp;<span style=color:maroon;font-weight:700>for</span> <span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> i <span style=color:#808030>=</span> start<span style=color:purple>;</span> i <span style=color:#808030>&lt;</span> end<span style=color:purple>;</span> <span style=color:#808030>+</span><span style=color:#808030>+</span>i<span style=color:#808030>)</span><br>&nbsp; &nbsp;A<span style=color:#808030>[</span>i<span style=color:#808030>]</span> <span style=color:#808030>*</span><span style=color:#808030>=</span> B<span style=color:#808030>[</span>i<span style=color:#808030>]</span> <span style=color:#808030>+</span> K<span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre><br>The loop above is compiled into this X86 assembly sequence. Notice the use of the 8-wide YMM registers on systems that support AVX.<br><br><pre style=background:#fff;color:#000><br><span style=color:#e34adc>LBB1_4:</span><br>    vmovups <span style=color:#808030>(</span><span style=color:#808030>%</span>rdx<span style=color:#808030>)</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm2<br>    vaddps &nbsp;<span style=color:#808030>%</span>ymm1<span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm2<span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm2<br>    vmovups <span style=color:#808030>(</span><span style=color:#808030>%</span>rax<span style=color:#808030>)</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm3<br>    vmulps &nbsp;<span style=color:#808030>%</span>ymm2<span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm3<span style=color:#808030>,</span> <span style=color:#808030>%</span>ymm2<br>    vmovups <span style=color:#808030>%</span>ymm2<span style=color:#808030>,</span> <span style=color:#808030>(</span><span style=color:#808030>%</span>rax<span style=color:#808030>)</span><br>    addq &nbsp;  <span style=color:green>$32</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>rax<br>    addq &nbsp;  <span style=color:green>$32</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>rdx<br>    addq &nbsp;  $<span style=color:#008c00>-8</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>r1<span style=color:#008c00>1</span><br><span style=color:maroon;font-weight:700>    jne</span> <span style=color:#e34adc>LBB1_4</span><br></pre><br>In the last example, we don’t see a loop because it is hidden inside the "accumulate" function of the standard c++ library. This loop uses c++ iterators, which are pointers, and not integer indices, like we saw in the previous examples. The Loop Vectorizer detects pointer induction variables and can vectorize this loop. This feature is important because many C++ programs use iterators.<br><pre style=background:#fff;color:#000><br><span style=color:maroon;font-weight:700>int</span> baz<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span>A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> n<span style=color:#808030>)</span> <span style=color:purple>{</span><br>  <span style=color:maroon;font-weight:700>return</span> std<span style=color:purple>::</span>accumulate<span style=color:#808030>(</span>A<span style=color:#808030>,</span> A <span style=color:#808030>+</span> n<span style=color:#808030>,</span> <span style=color:#008c00>0</span><span style=color:#808030>)</span><span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre>The loop above is compiled into this x86 assembly sequence.<br><pre style=background:#fff;color:#000><br><span style=color:#e34adc>LBB2_8:</span><br>    vmovdqu <span style=color:#808030>(</span><span style=color:#808030>%</span>rcx<span style=color:#808030>,</span><span style=color:#808030>%</span>rdx<span style=color:#808030>,</span><span style=color:#008c00>4</span><span style=color:#808030>)</span><span style=color:#808030>,</span> <span style=color:#808030>%</span><span style=color:navy>xmm1</span><br>    vpaddd  <span style=color:#808030>%</span><span style=color:navy>xmm0</span><span style=color:#808030>,</span> <span style=color:#808030>%</span><span style=color:navy>xmm1</span><span style=color:#808030>,</span> <span style=color:#808030>%</span><span style=color:navy>xmm0</span><br>    addq    <span style=color:green>$4</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>rdx<br>    cmpq    <span style=color:#808030>%</span>rdx<span style=color:#808030>,</span> <span style=color:#808030>%</span>rsi<br><span style=color:maroon;font-weight:700>    jne</span> <span style=color:#e34adc>LBB2_8</span><br></pre><br>The Loop Vectorizer is a target independent IR-level optimization that depends on target-specific information from the different backends. It needs to select the optimal vector width and to decide if vectorization is worthwhile. Users can force a certain vector width using the command line flag <b>"-mllvm -force-vector-width=X"</b>, where X is the number of vector elements. At the moment, only the X86 backend provides detailed cost information, while other targets use a less accurate method.<br>The work on the Loop Vectorizer is not complete and the vectorizer has a long way to go. We plan to add additional vectorization features such as automatic alignment of buffers, vectorization of function calls and support for user pragmas. We also plan to improve the quality of the generated code.<br><br></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2012/12/llvm-developer-meeting-2012.html><i class="fa fa-chevron-circle-left"></i> LLVM Developer Meeting 2012</a></li><li><a href=https://blog.llvm.org/2013/03/instruction-relationship-framework-in.html>Instruction Relationship Framework in LLVM <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>