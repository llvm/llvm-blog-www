<!doctype html><html lang=en><head><title>Using clang for Chrome production builds on Linux - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Nico Weber"><meta property="og:url" content="https://blog.llvm.org/2015/01/using-clang-for-chrome-production.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Using clang for Chrome production builds on Linux"><meta property="og:description" content="Chrome 38 was released early October 2014. It is the first release where the Linux binaries shipped to users are built by clang. Previously, this was done by gcc 4."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-01-05T10:39:00+00:00"><meta property="article:modified_time" content="2015-01-05T10:39:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Clang"><meta property="article:tag" content="Products"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using clang for Chrome production builds on Linux"><meta name=twitter:description content="Chrome 38 was released early October 2014. It is the first release where the Linux binaries shipped to users are built by clang. Previously, this was done by gcc 4."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Using clang for Chrome production builds on Linux</h1><aside><ul><li>By Nico Weber</li><li><time class=post-date datetime=2015-01-05T10:39:00Z>Jan 5, 2015</time></li><li><em><a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a>
,
<a href=https://blog.llvm.org/tags/products>#Products</a>
,
<a href=https://blog.llvm.org/tags/linux>#Linux</a></em></li><li>6 minute read</li></ul></aside><div dir=ltr style=text-align:left trbidi=on><div><span style=font-family:inherit>Chrome 38 was released early October 2014. It is the first release where the Linux binaries shipped to users are built by clang. Previously, this was done by gcc 4.6. As you can read in the <a href=http://lists.cs.uiuc.edu/pipermail/cfe-dev/2014-November/039929.html>announcement email</a>, the switch happened without many issues. Performance stayed roughly the same, binary size decreased by about 8%. In this post I'd like to discuss the motivation for this switch.</span></div><h3 style=text-align:left><span style=font-family:inherit>Motivation</span></h3><span style=font-family:inherit>There are two reasons for the switch.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>1. Many Chromium developers already used clang on Linux. We've supported <a href=https://code.google.com/p/chromium/wiki/Clang>opting in</a> to clang for since <a href=http://llvm.org/devmtg/2011-11/Weber_Wennborg_UsingClangInChromium.pdf>before clang supported C++</a>&nbsp;– because of this, we have a process in place for shipping new clang binaries to all developers and bots every few weeks. Because of clang's good diagnostics (<a href=http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20110530/042515.html>some</a> of <a href=http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20120227/054412.html>which</a> we <a href=http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20110613/042785.html>added</a> due to bugs in Chromium we thought the compiler should catch), speed, and because of our <a href=http://www.chromium.org/developers/coding-style/chromium-style-checker-errors>Chromium-specific clang plugin</a>, many Chromium developers switched to clang over the years. Making clang the default compiler removes a stumbling block for people new to the project.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>2. We want to use modern C++ features in Chromium. This requires a recent toolchain – we figured we needed at least gcc 4.8. For Chrome for Android and Chrome for Chrome OS, we updated our gcc compilers to 4.8 (and then 4.9) – easy since these ports use a non-system gcc already. Chrome for Mac has been using Chromium's clang since Chrome 15 and was already in a good state. Chrome for iOS uses Xcode 5's clang, which is also new enough. Chrome for Windows uses Visual Studio 2013 Update 4. On Linux, switching to clang was the easiest way forward.</span><br><h3 style=text-align:left>Keeping up with C++'s evolution in a large, multi-platform project</h3><span style=font-family:inherit>C++ had been static for many years. C++11 is the first real update to the C++ language since the original C++ standard (approved on July 27 1998). C++98 predated the founding of Google, YouTube, Facebook, Twitter, the releases of Mac OS X and Windows XP, and x86 SSE instructions. The time between the two standards saw the rise and fall of the iPod, several waves of social networks, and the smartphone explosion.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>The time between C++11 and C++14 was three years, and the next major iteration of the language is speculated to be finished in 2017, three years from C++14. This is a dramatic change, and it has repercussions on how to build and ship C++ programs. It took us 3+ years to get to a state where we can use C++11 in Chromium; C++14 will hopefully take us less long. (If you're targeting fewer platforms, you'll have an easier time.)</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>There are two parts to C++11: New language features, and new library features. The language features just require a modern compiler at build time on build machines, the library features need a new standard library at runtime on the user's machine.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>Deploying a new compiler is conceptually relatively simple. If your developers are on Ubuntu LTS releases and you make them use the newest LTS release, they get new compilers every two years – so just using the default system compiler means you're up to two years behind. There needs to be some process to relatively transparently deploy new toolchains to your developers – an "evergreen compiler". We now have this in place for Chromium – on Linux, by using clang. (We still accept patches to keep Chromium buildable with gccs >= 4.8 for people who prefer compiling locally over using precompiled binaries, and we still use gcc as the target compiler for Chrome for Android and Chrome OS.)</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>The library situation is slightly more tricky: On Linux and Mac OS X, programs are usually linked against the system C++ library. Chrome wants to support Mac OS X 10.6 a bit longer (our users seem to love this OS X release), and the only C++ library this ships with is libstdc++ 4.2 – which doesn't have any C++11 bits. Similarly, Ubuntu Precise only has libstdc++ 4.6. It seems that with C++ updating more often, products will have to either stop supporting older OS versions (even if they still have many users on these old versions), adopt new C++ features very slowly, or ship with a bundled C++ standard library. The latter implies that system libraries shouldn't have a C++ interface for ABI reasons – luckily, this is mostly already the case.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>To make things slightly more complicated, gcc and libstdc++ expect to be updated at the same time. gcc 4.8 links to libstdc++ 4.8, so upgrading gcc 4.8 while still linking to Precise's libstdc++ 4.6 isn't easy. clang <a href=http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20140630/109151.html>explicitly supports</a> building with older libstdc++ versions.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>For Chromium, we opted to enable C++11 language features now, and then allow C++11 library features later once we have figured out the story there. This allows us to <a href=https://groups.google.com/a/chromium.org/forum/#!msg/chromium-dev/xMscQuYBwyc>incrementally adopt</a> <a href=http://chromium-cpp.appspot.com/>C++11 features in Chromium</a>,&nbsp;but it's not without risks:</span>&nbsp;<span style="font-family:Courier New,Courier,monospace">vector&lt;int> v0{42}</span> for example means something different with an old C++ library and a new C++ library that has a <span style="font-family:Courier New,Courier,monospace">vector</span> constructor taking an <span style="font-family:Courier New,Courier,monospace">initializer_list</span>. We disallow using uniform initialization for now because of this.<br><br>Since bundling a C++ library seems to become more common with this new C++ update cadence, it would be nice if compiler drivers helped with this. Just statically linking libstdc++ / libc++ isn't enough if you're shipping a product consisting of several executables or shared libraries – they need to dynamically link to a shared C++ library with the right rpaths, the C++ library probably needs mangled symbol names that don't conflict with the system C++ library which might be loaded into the same process due to other system libraries using it internally (for example, maybe using an inline namespace with an application-specific name), etc.<br><h3 style=text-align:left>Future directions</h3>As mentioned above, we're trying to figure out the C++ library situation. The tricky cases are Chrome for Android (which currently uses STLport) and Chrome for Mac. We're hoping to switch Chrome for Android to libc++ (while still using gcc as compiler). On Mac, we'll likely bundle libc++ with Chrome too.<br><br>We're <a href=http://blog.llvm.org/2014/07/clangllvm-on-windows-update.html>working</a> <a href=http://llvm.org/devmtg/2014-10/#talk15>on</a> making clang <a href=http://llvm.org/devmtg/2014-04/PDFs/Talks/clang-cl.pdf>usable</a> for compiling Chrome for Windows. The main motivations for this are using <a href=http://llvm.org/devmtg/2014-10/Slides/ASan%20for%20Windows.pdf>AddressSanitizer</a>, providing a compiler with great diagnostics for developers, and getting our <a href=https://code.google.com/p/chromium/wiki/ClangToolRefactoring>tooling infrastructure</a> working on Windows (used for example&nbsp;<a href=http://crbug.com/417463>automated large-scale cross-OS refactoring</a>&nbsp;and for building our <a href="https://code.google.com/p/chromium/codesearch#chromium/src/apps/launcher.h&amp;sq=package:chromium&amp;type=cs&amp;l=18&amp;rcl=1419953261">code search index</a>&nbsp;– try clicking a few class names; at the moment only code built on Linux is hyperlinked). We won't use clang as a production compiler on Windows unless it produces a chrome binary that's competitive with Visual Studio's on both binary size and performance. (From an open-source perspective, it <i>is</i> nice being able to use an open-source compiler to compile an open-source program.)<br><br>You can reach us at&nbsp;clang@chromium.org</div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2015/01/llvm-weekly-53-jan-5th-2015.html><i class="fa fa-chevron-circle-left"></i> LLVM Weekly - #53, Jan 5th 2015</a></li><li><a href=https://blog.llvm.org/2015/01/llvm-weekly-54-jan-12th-2015.html>LLVM Weekly - #54, Jan 12th 2015 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>