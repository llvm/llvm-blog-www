---
author: Unknown
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-982481207523081293
blogger_orig_url: http://blog.llvm.org/2016/05/llvm-weekly-124-may-16th-2016.html
date: "2016-05-16T04:26:00Z"
modified_time: "2016-05-16T04:26:45.660-07:00"
tags: ["llvmweekly"]
title: 'LLVM Weekly - #124, May 16th 2016'
aliases:
 - /2016/05/llvm-weekly-124-may-16th-2016.html
---

<p>Welcome to the one hundred and twenty-fourth issue of LLVM Weekly, a weekly  newsletter (published every Monday) covering developments in LLVM, Clang, and  related projects. LLVM Weekly is brought to you by <a href="http://asbradbury.org">Alex  Bradbury</a>. Subscribe to future issues at  <a href="http://llvmweekly.org">http://llvmweekly.org</a> and pass it on to anyone else you think may be   interested. Please send any tips or feedback to <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#97;&#115;&#98;&#64;&#97;&#115;&#98;&#114;&#97;&#100;&#98;&#117;&#114;&#121;&#46;&#111;&#114;&#103;">&#97;&#115;&#98;&#64;&#97;&#115;&#98;&#114;&#97;&#100;&#98;&#117;&#114;&#121;&#46;&#111;&#114;&#103;</a>, or <a href="https://twitter.com/llvmweekly">@llvmweekly</a> or <a    href="https://twitter.com/asbradbury">@asbradbury</a> on Twitter.</p>  <p>The canonical home for this issue <a href="http://llvmweekly.org/issue/124">can be found here at llvmweekly.org</a>. </p> <a name='more'></a> <h3>News and articles from around the web</h3><p>The main news this week is the announcement of  <a href="http://www.scala-native.org/">Scala-native</a>, an ahead-of-time compiler for  Scala using LLVM. Jos Dirkens has written a <a href="http://www.smartjava.org/content/getting-started-scala-native">getting started  guide</a> if you  want to compile it and try it out. There's also more information in the  <a href="https://github.com/densh/talks/blob/master/2016-05-11-scala-goes-native.pdf">slides from the announcement  talk</a>.</p><h3>On the mailing lists</h3><ul><li><p>More of the students taking part in Google Summer of Code with LLVM-related  projects have introduced themselves and their plans. Vivek Pandya will be  working on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099492.html">interprocedural register  allocation</a>. Scott Egerton will be working on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099704.html">capture tracking  improvements</a>. Jie Chen will be working on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099573.html">better alias analysis, specifically improving  cfl-aa</a>. Matthias Reisinger will be working on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099471.html">enabling polyhedral optimisations in  Julia</a>, and  Zhengyan Liu has plans for <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099600.html">SAFECode memory  hardening</a>.</p></li><li><p>Renato Golin kicked off a discussion about <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099541.html">whether LLVM's release process  could be better aligned with downstream  users</a>. This  thread covered a broad range of topics and triggered a lot of discussion, but  luckily there's no need to summarise it as Renato has <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099706.html">done the job for  us</a>.</p></li><li><p>Nicolai HÃ¤hnle notes that currently libLLVM.so <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099398.html">contains about 1.7MB in its  .data.rel.ro  section</a>, of  which about 1.3MB comes from the MCInstrDesc tables created by tablegen  representing a massive number of pointers to be relocated. He suggests  reducing this by using offsets instead. Reducing the relocations will both  reduce binary size and increase the portion of the binary that can be mapped  as shared. So far, responses to the thread are supportive of the idea.</p></li><li><p>James Knight has written a detailed post on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099490.html">how it's not really possible to  write an LL/SC loop guaranteed to make forward progress in LLVM IR right  now</a>. There are  restrictions on what you can do between a load-linked and a store-conditional  instruction that the code generator may not meet.</p></li><li><p>A public  <a href="http://lists.llvm.org/cgi-bin/mailman/listinfo/llvm-foundation">llvm-foundation</a>  mailing list has been  <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099574.html">announced</a>,  which to facilitate discussions related to the Foundation.</p></li><li><p>As well as the long, technically detailed and precise threads each week it's  nice to highlight cases where a simple question has a simple answer. How do  you register a pass as being opt-in based on a command-line flag? <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099470.html">Answer</a>: have  it run every time, but return immediately if the desired command line flag  isn't present.</p></li><li><p>Sanjoy Das has shared an RFC on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099693.html">adding a callee-saved register  verifier</a>. As  is clarified later in the thread, the intention is to ensure that code not  generated by LLVM (e.g. output from another JIT or hand-written assembly)  properly adheres to the calling convention and doesn't clobber registers it  shouldn't. The proposed pass would simply add code to check that the test  values written to the callee-saved registers aren't modified.</p></li><li><p>In response to questions about pass ordering, Mehdi Amini has written a  helpful description of <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099477.html">what exactly happens when you do opt -mymodulepass0  -myfunctionpass  -mymodulepass1</a>.</p></li><li><p>Konstantin Vladimirov wonders <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099494.html">if there's an option to force the register  allocator to use as many architectural registers as possible to reduce  dependencies</a>. The short answer is there isn't currently, but it would be interesting to  investigate.</p></li><li><p>Diana Picus has shared an RFC on <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-May/099594.html">modifying llc so it no longer exits after  the first  error</a>. Generally people are in favour, and the patch should hopefully land soon (it  had to be temporarily backed out after exposing some test cases failures in  lldb).</p></li><li><p>Nico Weber has noted that now with AVX512, <a href="http://lists.llvm.org/pipermail/cfe-dev/2016-May/048837.html">Clang's intrinsics headers are  huge</a>. This can  cause compile time issues, for instance Nico reports building all of the v8 JS  engine is 6% faster after removing the avx512 includes. The thread  participants haven't yet decided on the best way forward to fix this, beyond  the potential immediate step of adding include guards so AVX512 intrinsic  headers aren't included when not compiling for AVX512 platforms.</p></li></ul><h3>LLVM commits</h3><ul><li><p>The outdated guide on cross-compiling LLVM has been brought up to date. <a href="http://reviews.llvm.org/rL269054">r269054</a>.</p></li><li><p>The WebAssembly backend gained preliminary fast instruction selection  (fast-isel) support. <a href="http://reviews.llvm.org/rL269083">r269083</a>,  <a href="http://reviews.llvm.org/rL269203">r269203</a>,  <a href="http://reviews.llvm.org/rL269273">r269273</a>.</p></li><li><p>Loop unrolling (other than in the case of explicit pragmas) is now disabled  at <code>-Os</code> in LLVM. You may recall last week it was enabled for <code>-Os</code> in Clang,  but with different thresholds. <a href="http://reviews.llvm.org/rL269124">r269124</a>.</p></li><li><p>A new cost-tracking system has been implemented for the loop unroller. <a href="http://reviews.llvm.org/rL269388">r269388</a>.</p></li><li><p>LLVM's Sparc backend has seen the addition of more LEON-specific features,  e.g. signed and unsigned multiply-accumulate. <a href="http://reviews.llvm.org/rL268908">r268908</a>.</p></li><li><p>llc's <code>-run-pass</code> option will now work with any pass known to the pass  registry. Previously it would silently do nothing if you specify indirectly  added analysis passes or passes not present in the optimisation pipeline. <a href="http://reviews.llvm.org/rL269003">r269003</a>.</p></li><li><p>WebAssembly register stackification and coloring are now run very late in  the optimisation pipeline. The commit message suggests it's useful to think of  these passes as domain-specific liveness-based compression rather than a  conventional optimisation. <a href="http://reviews.llvm.org/rL269012">r269012</a>.</p></li><li><p>When declaring global in textual LLVM IR, you must now assign them with e.g. <code>@0 = global i32 42</code>. <a href="http://reviews.llvm.org/rL269096">r269096</a>.</p></li><li><p>The internal assembler is now enabled by default for 32-bit MIPS targets. <a href="http://reviews.llvm.org/rL269560">r269560</a>.</p></li></ul><h3>Clang commits</h3><ul><li><p>Clang now supports <code>__float128</code>. <a href="http://reviews.llvm.org/rL268898">r268898</a>.</p></li><li><p>Clang gained a new warning that triggers when casting away calling  conventions from a function. <a href="http://reviews.llvm.org/rL269116">r269116</a>.</p></li><li><p>The recently developed include-fixer tools now has documentation. <a href="http://reviews.llvm.org/rL269167">r269167</a>.</p></li></ul><h3>Other project commits</h3><ul><li><p>compiler-rt's CMake build system can now build builtins without a full  toolchain, allowing you to bootstrap a cross-compiler. <a href="http://reviews.llvm.org/rL268977">r268977</a>.</p></li><li><p>LLD will now sort relocations to optimise dynamic linker performance. <a href="http://reviews.llvm.org/rL269066">r269066</a>.</p></li></ul>
