<!doctype html><html lang=en><head><title>LLVM 3.3 Vectorization Improvements - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Nadav Rotem"><meta property="og:url" content="https://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="LLVM 3.3 Vectorization Improvements"><meta property="og:description" content="I would like to give a brief update regarding vectorization in LLVM. When LLVM 3.2 was released, it featured a new experimental loop vectorizer that was disabled by default. Since LLVM 3."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-05-28T07:05:00+00:00"><meta property="article:modified_time" content="2013-05-28T07:05:00+00:00"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="New-in-Llvm-3.3"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM 3.3 Vectorization Improvements"><meta name=twitter:description content="I would like to give a brief update regarding vectorization in LLVM. When LLVM 3.2 was released, it featured a new experimental loop vectorizer that was disabled by default. Since LLVM 3."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>LLVM 3.3 Vectorization Improvements</h1><aside><ul><li><time class=post-date datetime=2013-05-28T07:05:00Z>May 28, 2013</time></li><li><em><a href=https://blog.llvm.org/tags/optimization>#optimization</a>
,
<a href=https://blog.llvm.org/tags/new-in-llvm-3.3>#new-in-llvm-3.3</a></em></li><li>4 minute read</li></ul></aside>I would like to give a brief update regarding vectorization in LLVM. When LLVM 3.2 was released, it featured a new experimental <a href=http://blog.llvm.org/2012/12/new-loop-vectorizer.html>loop vectorizer</a> that was disabled by default. Since LLVM 3.2 was released, we have continued to work hard on improving vectorization, and we have some news to share. First, the loop vectorizer has new features and is now enabled by default on -O3. Second, we have a new SLP vectorizer. And finally, we have new clang command line flags to control the vectorizers.<br><h4><a name=more></a>Loop Vectorizer</h4>The LLVM Loop Vectorizer has a number of new features that allow it to vectorize even more complex loops with better performance. One area that we focused on is the vectorization "cost model". When LLVM estimates if a loop may benefit from vectorization it uses a detailed description of the processor that can estimate the cost of various instructions. We improved both the X86 and ARM cost models. Improving the cost models helped the compiler to detect benefitting loops and improve the performance of many programs. During the analysis of vectorized programs, we also found and optimized many vector code sequences.<br><br>Another important improvement to the loop vectorizer is the ability to unroll during vectorization. When the compiler unrolls loops it generates more independent instructions that modern out-of-order processors can execute in parallel. The loop below adds all of the numbers in the array. When compiling this loop, LLVM creates two independent chains of calculations that can be executed in parallel.<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br><span style=color:maroon;font-weight:700>int</span> sum_elements<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span>A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> n<span style=color:#808030>)</span> <span style=color:purple>{</span><br>  <span style=color:maroon;font-weight:700>int</span> sum <span style=color:#808030>=</span> <span style=color:#008c00>0</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>for</span> <span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> i <span style=color:#808030>=</span> <span style=color:#008c00>0</span><span style=color:purple>;</span> i <span style=color:#808030>&lt;</span> n<span style=color:purple>;</span> <span style=color:#808030>+</span><span style=color:#808030>+</span>i<span style=color:#808030>)</span><br>    sum <span style=color:#808030>+</span><span style=color:#808030>=</span> A<span style=color:#808030>[</span>i<span style=color:#808030>]</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>return</span> sum<span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre></body></html></pre>The innermost loop of the program above is compiled into the X86 assembly sequence below, which processes 8 elements at once, in two parallel chains of computations. The vector registers XMM0 and XMM1 are used to store the partial sum of different parts of the array. This allows the processor to load two values and add two values simultaneously.<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br>LBB0<span style=color:#808030>_</span>4<span style=color:#808030>:</span><br>  movdqu    <span style=color:#008c00>16</span><span style=color:#808030>(</span><span style=color:#808030>%</span>rdi<span style=color:#808030>,</span><span style=color:#808030>%</span>rax<span style=color:#008c00>,4</span><span style=color:#808030>)</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>xmm2<br>  paddd     <span style=color:#808030>%</span>xmm2<span style=color:#808030>,</span> <span style=color:#808030>%</span>xmm1<br>  movdqu    <span style=color:#808030>(</span><span style=color:#808030>%</span>rdi<span style=color:#808030>,</span><span style=color:#808030>%</span>rax<span style=color:#008c00>,4</span><span style=color:#808030>)</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>xmm2<br>  paddd     <span style=color:#808030>%</span>xmm2<span style=color:#808030>,</span> <span style=color:#808030>%</span>xmm0<br>  addq      $<span style=color:#008c00>8</span><span style=color:#808030>,</span> <span style=color:#808030>%</span>rax<br>  cmpq      <span style=color:#808030>%</span>rax<span style=color:#808030>,</span> <span style=color:#808030>%</span>rcx<br>  jne       LBB0<span style=color:#808030>_</span>4<br></pre></body></html></pre><br>Another important improvement is the support for loops that contain IFs, and the detection of the popular min/max patterns. LLVM is now able to vectorize the code below:<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br><span style=color:maroon;font-weight:700>int</span> fins_max<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span>A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> n<span style=color:#808030>)</span> <span style=color:purple>{</span><br>  <span style=color:maroon;font-weight:700>int</span> mx <span style=color:#808030>=</span> A<span style=color:#808030>[</span><span style=color:#008c00>0</span><span style=color:#808030>]</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>for</span> <span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> i <span style=color:#808030>=</span> <span style=color:#008c00>0</span><span style=color:purple>;</span> i <span style=color:#808030>&lt;</span> n<span style=color:purple>;</span> <span style=color:#808030>+</span><span style=color:#808030>+</span>i<span style=color:#808030>)</span><br>    <span style=color:maroon;font-weight:700>if</span> <span style=color:#808030>(</span>mx <span style=color:#808030>&gt;</span> A<span style=color:#808030>[</span>i<span style=color:#808030>]</span><span style=color:#808030>)</span><br>      mx <span style=color:#808030>=</span> A<span style=color:#808030>[</span>i<span style=color:#808030>]</span><span style=color:purple>;</span><br>  <span style=color:maroon;font-weight:700>return</span> mx<span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre></body></html></pre>In the last release, the loop vectorizer was able to vectorize many, but not all, loops that contained floating point arithmetic. Floating point operations are not associative due to the unique rounding rules. This means that the expression (a + b) + c is not always equal to a + (b + c). The compiler flag -ffast-math tells the compiler not to worry about rounding errors and to optimize for speed. One of the new features of the loop vectorizer is the vectorization of floating point calculations when -ffast-math mode is used. Users who decide to use the -ffast-math flag will notice that many more loops get vectorized with the upcoming 3.3 release of LLVM.<br><h4>SLP Vectorizer</h4>The SLP vectorizer (short for superword-level parallelism) is a new vectorization pass. Unlike the loop vectorizer, which vectorizes consecutive loop iterations, the SLP vectorizer combines similar independent instructions in a straight-line code.<br>The SLP Vectorizer is now available and will be useful for many people.<br>The SLP Vectorizer can boost the performance of many programs in the LLVM test suite. In one benchmark, "Olden/Power", the SLP Vectorizer boosts the performance of the program by 16%. Here is one small example of a function that the SLP Vectorizer can vectorize.<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br><span style=color:maroon;font-weight:700>void</span> foo<span style=color:#808030>(</span><span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span> restrict A<span style=color:#808030>,</span> <span style=color:maroon;font-weight:700>int</span> <span style=color:#808030>*</span> restrict B<span style=color:#808030>)</span> <span style=color:purple>{</span><br>  A<span style=color:#808030>[</span><span style=color:#008c00>0</span><span style=color:#808030>]</span> <span style=color:#808030>=</span> <span style=color:#008c00>7</span><span style=color:#808030>+</span><span style=color:#808030>(</span>B<span style=color:#808030>[</span><span style=color:#008c00>0</span><span style=color:#808030>]</span> <span style=color:#808030>*</span> <span style=color:#008c00>11</span><span style=color:#808030>)</span><span style=color:purple>;</span><br>  A<span style=color:#808030>[</span><span style=color:#008c00>1</span><span style=color:#808030>]</span> <span style=color:#808030>=</span> <span style=color:#008c00>6</span><span style=color:#808030>+</span><span style=color:#808030>(</span>B<span style=color:#808030>[</span><span style=color:#008c00>1</span><span style=color:#808030>]</span> <span style=color:#808030>*</span> <span style=color:#008c00>12</span><span style=color:#808030>)</span><span style=color:purple>;</span><br>  A<span style=color:#808030>[</span><span style=color:#008c00>2</span><span style=color:#808030>]</span> <span style=color:#808030>=</span> <span style=color:#008c00>5</span><span style=color:#808030>+</span><span style=color:#808030>(</span>B<span style=color:#808030>[</span><span style=color:#008c00>2</span><span style=color:#808030>]</span> <span style=color:#808030>*</span> <span style=color:#008c00>13</span><span style=color:#808030>)</span><span style=color:purple>;</span><br>  A<span style=color:#808030>[</span><span style=color:#008c00>3</span><span style=color:#808030>]</span> <span style=color:#808030>=</span> <span style=color:#008c00>4</span><span style=color:#808030>+</span><span style=color:#808030>(</span>B<span style=color:#808030>[</span><span style=color:#008c00>3</span><span style=color:#808030>]</span> <span style=color:#808030>*</span> <span style=color:#008c00>14</span><span style=color:#808030>)</span><span style=color:purple>;</span><br><span style=color:purple>}</span><br></pre></body></html></pre>The code above is compiled into the ARMv7s assembly sequence below. Notice that the 4 additions and 4 multiplication operations became a single Multiply-Accumulate instruction "vmla".<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br><span style=color:#808030>_</span>foo<span style=color:#808030>:</span><br>  adr       r2<span style=color:#808030>,</span> LCPI0<span style=color:#808030>_</span>0<br>  adr       r3<span style=color:#808030>,</span> LCPI0<span style=color:#808030>_</span>1<br>  vld1<span style=color:#008c00>.32</span>   <span style=color:#808030>{</span>d18<span style=color:#808030>,</span> d19<span style=color:#808030>}</span><span style=color:#808030>,</span> <span style=color:#808030>[</span>r1<span style=color:#808030>]</span><br>  vld1<span style=color:#008c00>.64</span>   <span style=color:#808030>{</span>d16<span style=color:#808030>,</span> d17<span style=color:#808030>}</span><span style=color:#808030>,</span> <span style=color:#808030>[</span>r3<span style=color:#808030>:</span><span style=color:#008c00>128</span><span style=color:#808030>]</span> <br>  vld1<span style=color:#008c00>.64</span>   <span style=color:#808030>{</span>d20<span style=color:#808030>,</span> d21<span style=color:#808030>}</span><span style=color:#808030>,</span> <span style=color:#808030>[</span>r2<span style=color:#808030>:</span><span style=color:#008c00>128</span><span style=color:#808030>]</span><br>  vmla<span style=color:#008c00>.</span>i32  q10<span style=color:#808030>,</span> q9<span style=color:#808030>,</span> q8            <br>  vst1<span style=color:#008c00>.32</span>   <span style=color:#808030>{</span>d20<span style=color:#808030>,</span> d21<span style=color:#808030>}</span><span style=color:#808030>,</span> <span style=color:#808030>[</span>r0<span style=color:#808030>]</span><br>  bx        lr<br></pre></body></html></pre><h4>Command Line Flags</h4>We've also added new command line flags to clang to control the vectorizers. The loop vectorizer is enabled by default for -O3, and it can be enabled or disabled for other optimization levels using the command line flags:<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br>$ clang <span style=color:#808030>.</span><span style=color:#808030>.</span><span style=color:#808030>.</span> <span style=color:#808030>-</span>fvectorize <span style=color:#808030>/</span> <span style=color:#808030>-</span>fno<span style=color:#808030>-</span>vectorize   file<span style=color:#008c00>.</span>c<br></pre></body></html></pre>The SLP vectorizer is disabled by default, and it can be enabled using the command line flags:<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br>$ clang <span style=color:#808030>.</span><span style=color:#808030>.</span><span style=color:#808030>.</span> <span style=color:#808030>-</span>fslp<span style=color:#808030>-</span>vectorize file<span style=color:#008c00>.</span>c<br></pre></body></html></pre>LLVM has a second basic block vectorization phase which is more compile-time intensive (BB vectorizer). This optimization can be enabled through clang using the command line flag:<br><pre style=background:#fff;color:#000><html><body style=background:#fff;color:#000><pre><br>$ clang <span style=color:#808030>.</span><span style=color:#808030>.</span><span style=color:#808030>.</span> <span style=color:#808030>-</span>fslp<span style=color:#808030>-</span>vectorize<span style=color:#808030>-</span>aggressive file<span style=color:#008c00>.</span>c<br></pre></body></html></pre>We've made huge progress in improving vectorization during the development of LLVM 3.3. Special thanks to all of the people who contributed to this effort.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2013/05/eurollvm-2013-paris-france.html><i class="fa fa-chevron-circle-left"></i> EuroLLVM 2013, Paris, France</a></li><li><a href=https://blog.llvm.org/2013/06/llvm-33-released.html>LLVM 3.3 Released! <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>