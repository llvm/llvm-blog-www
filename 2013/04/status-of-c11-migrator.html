<!doctype html><html lang=en><head><title>Status of the C++11 Migrator - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Edwin Vane"><meta property="og:url" content="https://blog.llvm.org/2013/04/status-of-c11-migrator.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Status of the C++11 Migrator"><meta property="og:description" content="Since the design document for cpp11-migrate, the C++11 migrator tool, was first proposed in early December 2012 development has been making steady progress. In this article I'll talk about what's been implemented in cpp11-migrate so far, what's coming up, and how you can get involved."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-04-15T05:53:00+00:00"><meta property="article:modified_time" content="2013-04-15T05:53:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Status of the C++11 Migrator"><meta name=twitter:description content="Since the design document for cpp11-migrate, the C++11 migrator tool, was first proposed in early December 2012 development has been making steady progress. In this article I'll talk about what's been implemented in cpp11-migrate so far, what's coming up, and how you can get involved."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Status of the C++11 Migrator</h1><aside><ul><li>By Edwin Vane</li><li><time class=post-date datetime=2013-04-15T05:53:00Z>Apr 15, 2013</time></li><li><em><a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>6 minute read</li></ul></aside>Since the <a href="https://docs.google.com/document/d/1xXfpLPxXIlp3pUpASXC547sQFF-vvHhnQkRBogM9wX0/edit?usp=sharing" target=_blank>design document</a> for cpp11-migrate, the C++11 migrator tool, was first proposed in <a href="http://www.phoronix.com/scan.php?page=news_item&amp;px=MTI0Mzc" target=_blank>early December 2012</a> development has been making steady progress. In this article I'll talk about what's been implemented in cpp11-migrate so far, what's coming up, and how you can get involved.<br><br>The purpose of the C++11 Migrator is to do source-to-source translation to migrate existing C++ code to use C++11 features to enhance maintainability, readability, runtime performance, and compile-time performance. Development is still early and transforms fall mostly into the first two categories. The migrator is based on Clang's <a href=http://clang.llvm.org/docs/LibTooling.html target=_blank>LibTooling</a> and the&nbsp;<a href=http://clang.llvm.org/docs/LibASTMatchers.html target=_blank>AST Matching library</a>.<br><br>Most of the development so far has been carried out by a small core group at Intel. Our focus so far has been to set up project infrastructure and testing, implement a few basic transforms, and make sure those transforms work well. Our aim is to make this tool useful to the community so we're always listening for transform ideas and feedback.<br><h2><a name=more></a>How to Get cpp11-migrate</h2>cpp11-migrate is located in the Extra Clang Tools repository. To build cpp11-migrate, you will need the LLVM and Clang sources as well. Follow the directions in Clang's <a href=http://clang.llvm.org/get_started.html target=_blank>Getting Started instructions</a>&nbsp;making sure to perform the optional step of checking out the Extra Clang Tools repository. Once checked out into the correct directory the build system, after a reconfiguration, will automatically include the extra Clang tools as part of the next full build. If you're using the CMake build system, you can build just cpp11-migrate with the&nbsp;<span style="font-family:Courier New,Courier,monospace">cpp11-migrate</span><span style=font-family:inherit> target</span><span style="font-family:Courier New,Courier,monospace">.</span>&nbsp;The <span style="font-family:Courier New,Courier,monospace">check-clang-tools</span> target provided by CMake will run all regression tests for extra Clang tools, including cpp11-migrate.<br><h2>The Transforms So Far</h2>The C++11 Migrator currently supports four features of C++11:<br><ul><li>Range-based for loops</li><li>The <span style="font-family:Courier New,Courier,monospace">nullptr</span><span style=font-family:inherit>&nbsp;</span>literal for null pointers</li><li>The <span style="font-family:Courier New,Courier,monospace">auto</span><span style=font-family:inherit> </span>type specifier</li><li><span style="font-family:Courier New,Courier,monospace">override</span><span style=font-family:inherit> </span>virtual specifier</li></ul><span style=font-size:large>The range-based for-loop transform</span> once existed as a stand-alone tool called <span style="font-family:Courier New,Courier,monospace">loop-convert</span><span style=font-family:inherit>&nbsp;contributed by Sam Panzer. When development on more transforms started, the idea became to pull all transforms under the jurisdiction of a single tool and </span><span style="font-family:Courier New,Courier,monospace">cpp11-migrate</span><span style=font-family:inherit> was born. The range-based for-loop transform replaces for-loops used in one of the following three common situations:</span><br><ol><li>Loops over containers using iterators</li><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#406080>&gt;</span> myVec<span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#406080>&gt;</span><span style=color:#406080>::</span><span style=color:#003060>iterator</span> I <span style=color:#308080>=</span> myVec<span style=color:#308080>.</span>begin<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#308080>,</span><br>                                E <span style=color:#308080>=</span> myVec<span style=color:#308080>.</span>end<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br>     I <span style=color:#308080>!</span><span style=color:#308080>=</span> E<span style=color:#406080>;</span> <span style=color:#308080>+</span><span style=color:#308080>+</span>I<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> <span style=color:#308080>*</span>I<span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#406080>&gt;</span> myVec<span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>auto</span> <span style=color:#308080>&amp;</span> elem <span style=color:#406080>:</span> myVec<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> elem<span style=color:#406080>;</span><br></pre></div></div><li>Loops over statically allocated arrays</li><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>int</span> arr<span style=color:#308080>[</span><span style=color:#308080>]</span> <span style=color:#308080>=</span> <span style=color:#406080>{</span><span style=color:#008c00>1</span><span style=color:#308080>,</span><span style=color:#008c00>2</span><span style=color:#308080>,</span><span style=color:#008c00>3</span><span style=color:#308080>,</span><span style=color:#008c00>4</span><span style=color:#308080>,</span><span style=color:#008c00>5</span><span style=color:#406080>}</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>int</span> i <span style=color:#308080>=</span> <span style=color:#008c00>0</span><span style=color:#406080>;</span> i <span style=color:#308080>&lt;</span> <span style=color:#008c00>5</span><span style=color:#406080>;</span> <span style=color:#308080>+</span><span style=color:#308080>+</span>i<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> arr<span style=color:#308080>[</span>i<span style=color:#308080>]</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>int</span> arr<span style=color:#308080>[</span><span style=color:#308080>]</span> <span style=color:#308080>=</span> <span style=color:#406080>{</span><span style=color:#008c00>1</span><span style=color:#308080>,</span><span style=color:#008c00>2</span><span style=color:#308080>,</span><span style=color:#008c00>3</span><span style=color:#308080>,</span><span style=color:#008c00>4</span><span style=color:#308080>,</span><span style=color:#008c00>5</span><span style=color:#406080>}</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>auto</span> <span style=color:#308080>&amp;</span> elem <span style=color:#406080>:</span> arr<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> elem<span style=color:#406080>;</span><br></pre></div></div><li>Loops over array-like containers using operator[] or at().</li><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#406080>&gt;</span> myVec<span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>int</span> i <span style=color:#308080>=</span> <span style=color:#008c00>0</span><span style=color:#406080>;</span> i <span style=color:#308080>&lt;</span> myVec<span style=color:#308080>.</span>size<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span> <span style=color:#308080>+</span><span style=color:#308080>+</span>i<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> v<span style=color:#308080>[</span>i<span style=color:#308080>]</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#406080>&gt;</span> myVec<span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>auto</span> <span style=color:#308080>&amp;</span> elem <span style=color:#406080>:</span> myVec<span style=color:#308080>)</span><br>  llvm<span style=color:#406080>::</span>outs<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#308080>&lt;</span><span style=color:#308080>&lt;</span> elem<span style=color:#406080>;</span><br></pre></div></div></ol><span style=font-size:large>The nullptr transform</span> uses the new <span style="font-family:Courier New,Courier,monospace">nullptr</span> literal where pointers are being initialized with or assigned a null value. In cases where an explicit cast is used, the explicit cast is left behind to avoid introducing ambiguities into the code.<br><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>void</span> foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>int</span> <span style=color:#308080>*</span>arg<span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>void</span> foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>float</span> <span style=color:#308080>*</span>arg<span style=color:#308080>)</span><span style=color:#406080>;</span><br><br><span style=color:#200080;font-weight:700>int</span> <span style=color:#308080>*</span>IntPtr <span style=color:#308080>=</span> <span style=color:#008c00>0</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>float</span> <span style=color:#308080>*</span>FloatPtr <span style=color:#308080>=</span> <span style=color:#7d0045>NULL</span><span style=color:#406080>;</span><br>foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>static_cast</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#308080>*</span><span style=color:#406080>&gt;</span><span style=color:#308080>(</span><span style=color:#008c00>0</span><span style=color:#308080>)</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>void</span> foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>int</span> <span style=color:#308080>*</span>arg<span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>void</span> foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>float</span> <span style=color:#308080>*</span>arg<span style=color:#308080>)</span><span style=color:#406080>;</span><br><br><span style=color:#200080;font-weight:700>int</span> <span style=color:#308080>*</span>IntPtr <span style=color:#308080>=</span> nullptr<span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>float</span> <span style=color:#308080>*</span>FloatPtr <span style=color:#308080>=</span> nullptr<span style=color:#406080>;</span><br>foo<span style=color:#308080>(</span><span style=color:#200080;font-weight:700>static_cast</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#308080>*</span><span style=color:#406080>&gt;</span><span style=color:#308080>(</span>nullptr<span style=color:#308080>)</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div></div><br><span style=font-size:large>The auto type specifier transform</span> replaces the type specifier for variable declarations with the new <span style="font-family:Courier New,Courier,monospace">auto</span> keyword. In general, such a replacement can be done whenever the type of the variable declaration matches the type of its initializer. However, the transform targets only a few specific useful situations with readability and maintainability in mind:<br><ol><li>When the variable is an iterator for an STL container.</li><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>pair</span><span style=color:#406080>&lt;</span><span style=color:#200080;font-weight:700>int</span><span style=color:#308080>,</span> <span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>string</span><span style=color:#406080>&gt;</span> <span style=color:#406080>&gt;</span><span style=color:#406080>::</span><span style=color:#003060>iterator</span> NameAgeI <span style=color:#308080>=</span> People<span style=color:#308080>.</span>begin<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#06e>std</span><span style=color:#406080>::</span><span style=color:#003060>vector</span><span style=color:#406080>&lt;</span>MyType<span style=color:#406080>&gt;</span><span style=color:#406080>::</span><span style=color:#003060>iterator</span> I <span style=color:#308080>=</span> Container<span style=color:#308080>.</span>begin<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#308080>,</span><br>                                   E <span style=color:#308080>=</span> Container<span style=color:#308080>.</span>end<span style=color:#406080>;</span><br>     I <span style=color:#308080>!</span><span style=color:#308080>=</span> E<span style=color:#406080>;</span> <span style=color:#308080>+</span><span style=color:#308080>+</span>I<span style=color:#308080>)</span> <span style=color:#406080>{</span><br>  <span style=color:#595979>// ...</span><br><span style=color:#406080>}</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>auto</span> NameAgeI <span style=color:#308080>=</span> People<span style=color:#308080>.</span>begin<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>for</span> <span style=color:#308080>(</span><span style=color:#200080;font-weight:700>auto</span> I <span style=color:#308080>=</span> Container<span style=color:#308080>.</span>begin<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#308080>,</span><br>                                  E <span style=color:#308080>=</span> Container<span style=color:#308080>.</span>end<span style=color:#406080>;</span><br>     I <span style=color:#308080>!</span><span style=color:#308080>=</span> E<span style=color:#406080>;</span> <span style=color:#308080>+</span><span style=color:#308080>+</span>I<span style=color:#308080>)</span> <span style=color:#406080>{</span><br>  <span style=color:#595979>// ...</span><br><span style=color:#406080>}</span><br></pre></div></div><li>When the initializer is an allocation using the&nbsp;<span style="font-family:Courier New,Courier,monospace">new</span><span style=font-family:inherit> operator.</span></li><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020>MyType <span style=color:#308080>*</span>VarPtr <span style=color:#308080>=</span> <span style=color:#200080;font-weight:700>new</span> MyType<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br>MyType <span style=color:#308080>*</span> <span style=color:#200080;font-weight:700>const</span> VarCPtr <span style=color:#308080>=</span> <span style=color:#200080;font-weight:700>new</span> MyType<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>auto</span> VarPtr <span style=color:#308080>=</span> <span style=color:#200080;font-weight:700>new</span> MyType<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>auto</span> <span style=color:#200080;font-weight:700>const</span> VarCPtr <span style=color:#308080>=</span> <span style=color:#200080;font-weight:700>new</span> MyType<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div></div></ol>Support for a third situation is in development: creating objects with factory functions.<br><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020>MyType <span style=color:#308080>*</span>FooPtr <span style=color:#308080>=</span> makeObject<span style=color:#406080>&lt;</span>MyType<span style=color:#406080>&gt;</span><span style=color:#308080>(</span><span style=color:#595979>/*...*/</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br>MyType <span style=color:#308080>*</span>BarPtr <span style=color:#308080>=</span> MyType<span style=color:#406080>::</span>create<span style=color:#308080>(</span><span style=color:#595979>/*...*/</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>auto</span> FooPtr <span style=color:#308080>=</span> makeObject<span style=color:#406080>&lt;</span>MyType<span style=color:#406080>&gt;</span><span style=color:#308080>(</span><span style=color:#595979>/*...*/</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#200080;font-weight:700>auto</span> BarPtr <span style=color:#308080>=</span> MyType<span style=color:#406080>::</span>create<span style=color:#308080>(</span><span style=color:#595979>/*...*/</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br></pre></div></div>In each situation, the deduced type for the declared variable should be obvious to the reader. Iterators for standard containers are created by functions with specific names and are used in specific situations. For factory functions and operator <span style="font-family:Courier New,Courier,monospace">new</span><span style=font-family:inherit>, </span>the type is spelled out in the initializer so repeating it in the variable declaration is not necessary.<br><br><span style=font-size:large>The <span style=font-family:inherit>override&nbsp;</span>virtual specifier transform</span>, contributed by Philip Dunstan,&nbsp;is the migrator's fourth transform and the first to be contributed from outside the core group at Intel. This transform detects virtual member functions in derived classes that override member functions from parent classes and adds the <span style="font-family:Courier New,Courier,monospace">override</span> virtual specifier to the function.<br><div style=text-indent:0;vertical-align:middle><div style=display:inline-block;vertical-align:middle;width:50%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>class</span> Parent <span style=color:#406080>{</span><br><span style=color:#200080;font-weight:700>public</span><span style=color:#e34adc>:</span><br>  <span style=color:#200080;font-weight:700>virtual</span> <span style=color:#200080;font-weight:700>int</span> getNumChildren<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#406080>}</span><span style=color:#406080>;</span><br><br><span style=color:#200080;font-weight:700>class</span> Child <span style=color:#406080>{</span><br><span style=color:#200080;font-weight:700>public</span><span style=color:#e34adc>:</span><br>  <span style=color:#200080;font-weight:700>virtual</span> <span style=color:#200080;font-weight:700>int</span> getNumChildren<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#406080>}</span><span style=color:#406080>;</span><br></pre></div><div style=display:inline-block;font-size:x-large;vertical-align:middle>â‡’</div><div style=display:inline-block;vertical-align:middle;width:45%><pre style=background:#f6f8ff;color:#000020><span style=color:#200080;font-weight:700>class</span> Parent <span style=color:#406080>{</span><br><span style=color:#200080;font-weight:700>public</span><span style=color:#e34adc>:</span><br>  <span style=color:#200080;font-weight:700>virtual</span> <span style=color:#200080;font-weight:700>int</span> getNumChildren<span style=color:#308080>(</span><span style=color:#308080>)</span><span style=color:#406080>;</span><br><span style=color:#406080>}</span><span style=color:#406080>;</span><br><br><span style=color:#200080;font-weight:700>class</span> Child <span style=color:#406080>{</span><br><span style=color:#200080;font-weight:700>public</span><span style=color:#e34adc>:</span><br>  <span style=color:#200080;font-weight:700>virtual</span> <span style=color:#200080;font-weight:700>int</span> getNumChildren<span style=color:#308080>(</span><span style=color:#308080>)</span> <span style=color:#200080;font-weight:700>override</span><span style=color:#406080>;</span><br><span style=color:#406080>}</span><span style=color:#406080>;</span><br></pre></div></div><br>More details on these transforms, what they can and can't do, how to adjust their behaviour, and known limitations can be found in the <a href=http://clang.llvm.org/extra/cpp11-migrate.html target=_blank>cpp11-migrate User's Manual</a>.<br><h2>Testing on Real Projects</h2><div>What better way to test the C++11 Migrator than to run it on entire real projects? We've set up a continuous integration server to build and run cpp11-migrate on two projects so far and have plans for at least three more. For each project, the goal is to build the transformed code and run that project's test suite to ensure semantics haven't changed.</div><div style=margin-top:1em;text-indent:0;width:20em><div style="border-right:1px solid grey;display:inline-block;padding-right:.5em;vertical-align:top"><b>Implemented:</b><br><ol><li><a href=http://www.llvm.org/ target=_blank>LLVM 3.1</a></li><li><a href=http://www.itk.org/ target=_blank>ITK 4.3.1</a></li></ol></div><div style=display:inline-block;padding-left:.5em;vertical-align:top><b>Planned:</b><br><ol><li><a href=http://lldb.llvm.org/ target=_blank>LLDB</a></li><li><a href=http://opencv.org/ target=_blank>OpenCV</a></li><li><a href=http://pocoproject.org/ target=_blank>Poco</a></li></ol></div></div>Running the migrator on real code has been enormously helpful for finding bugs. Real code from varying projects often reveals code expressions not accounted for in the development and unit testing of the transforms. Every time a bug found from transforming these projects gets fixed, new test cases are added to the regression test suite and the migrator becomes more robust.<br><h2>Future Work</h2><div>Fixing bugs found by migrating real code is of high priority right now since we want a good user experience for as many people as we can as soon as possible. Adding more transforms is another priority and those transforms with the most interest from the community will come first. Currently at the top of the list are:</div><div><ol><li>Use the standard library instead of TR1</li><li>Replace use of the deprecated <span style="font-family:Courier New,Courier,monospace">auto_ptr</span> class.</li></ol>In addition to fixing bugs and adding transforms, there are also more general&nbsp;improvements to consider. One such improvement we're making progress on is to remove the restriction that only source files are transformed and not any of the headers they include. The restriction has been in place until now because the migrator needs to know which headers are safe to transform. System headers and third-party library headers clearly shouldn't be touched.</div><h2>Get Involved!</h2><div>If you want to get involved, the first thing you can do is try out cpp11-migrate on your code. Bugs can be logged with <a href=http://llvm.org/bugs/ target=_blank>LLVM's bug tracker</a>&nbsp;under the product <span style="font-family:Courier New,Courier,monospace">clang-tools-extra</span>. Send an email to the <a href=http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev target=_blank>Clang Developer's Mailing List</a> if you need help or would like to get more involved. We look forward to hearing from you!<br><br></div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2013/04/static-analysis-tools-using-clang-in.html><i class="fa fa-chevron-circle-left"></i> Static analysis tools: using Clang in CppDepend</a></li><li><a href=https://blog.llvm.org/2013/04/euro-llvm-2013-in-paris.html>Euro LLVM 2013 in Paris <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>