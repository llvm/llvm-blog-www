<!doctype html><html lang=en><head><title>Testing libc++ with -fsanitize=undefined - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Marshall Clow"><meta property="og:url" content="https://blog.llvm.org/2013/04/testing-libc-with-fsanitizeundefined.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Testing libc++ with -fsanitize=undefined"><meta property="og:description" content='[This article is re-posted in a slightly expanded form from Marshall&#39;s blog]
After my last article, Testing libc++ with Address Sanitizer, I thought "what other tests can I run?"
Address Sanitizer (ASan) is not the only "'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-04-01T10:12:00+00:00"><meta property="article:modified_time" content="2013-04-01T10:12:00+00:00"><meta property="article:tag" content="Sanitizer"><meta property="article:tag" content="C++"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing libc++ with -fsanitize=undefined"><meta name=twitter:description content='[This article is re-posted in a slightly expanded form from Marshall&#39;s blog]
After my last article, Testing libc++ with Address Sanitizer, I thought "what other tests can I run?"
Address Sanitizer (ASan) is not the only "'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Testing libc++ with -fsanitize=undefined</h1><aside><ul><li>By Marshall Clow</li><li><time class=post-date datetime=2013-04-01T10:12:00Z>Apr 1, 2013</time></li><li><em><a href=https://blog.llvm.org/tags/sanitizer>#sanitizer</a>
,
<a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>8 minute read</li></ul></aside><i style="background-color:#f5f5f5;font-family:trebuchet ms,verdana,sans-serif;font-size:13px;line-height:22px;text-indent:10px">[This article is re-posted in a slightly expanded form&nbsp;<a href=http://cplusplusmusings.wordpress.com/2013/03/26/testing-libc-with-fsanitizeundefined/ style=border-bottom-color:red;border-bottom-style:dashed;border-bottom-width:1px;color:purple;text-decoration:none>from Marshall's blog</a>]</i><br><br>After my last article, <a href=http://cplusplusmusings.wordpress.com/2013/03/20/testing-libc-with-address-sanitizer/>Testing libc++ with Address Sanitizer</a>, I thought "what other tests can I run?"<br><br>Address Sanitizer (ASan) is not the only "sanitizer" that clang offers. There are "Thread Sanitizer" (TSan), "Undefined Behavior Sanitizer" (UBSan), and others. There's an integer overflow sanitizer which is called IOC coming in the 3.3 release of clang. The documentation for UBSan can be found <a href=http://clang.llvm.org/docs/UsersManual.html>on the LLVM site</a>.<br><br>I have been looking at the results of running the libc++ test suite with UBSan enabled. Even if you're not interested in libc++ specifically, this post can be a useful introduction to useful Clang bug detectors, and shows several classes of problems they can find.<br><h3><a name=more></a></h3><h3>The mechanics</h3>Like ASan, UBSan is a compiler pass and a custom runtime library. You enable this by passing <code>-fsanitize=undefined</code> to the compiler and linker. I ran the libc++ test suite like this:<br><pre><code><br></code></pre><pre><code>cd $LLVM/libcxx/test<br>CC=/path/to/tot/clang OPTIONS="--std=c++11 -stdlib=libc++ -fsanitize=undefined" ./testit<br></code></pre><br>Unfortunately, this failed; working with unreleased compilers and libraries, I needed updated versions of both libc++.dylib and libc++abi.dylib. So I built those from sources, and then used <code>DYLD_LIBRARY_PATH</code> to make sure that the test program used the libraries that I'd just built. (I didn't want to replace the ones in /usr/lib, because lots of things in the system depend on them)<br><pre><code><br></code></pre><pre><code>cd $LLVM/libcxx/test<br>DYLD_LIBRARY_PATH=$LLVM/libcxx/lib:$LLVM/libcxxabi/lib CC=/path/to/tot/clang OPTIONS="-std=c++11 -stdlib=libc++ -fsanitize=undefined -L $LLVM/libcxxabi/lib -lc++abi" ./testit<br></code></pre><br>where, as before "/path/to/tot/clang" is the clang that I just built from source, and $LLVM is where I've checked out the various parts of LLVM from Subversion.<br><h3>The results</h3>And the tests were off and running. In the last article, I noted that these tests take about 30 minutes to run on my MacBook Pro. The ASan tests took about 90 minutes. I was pleasantly surprised when the UBSan tests finished in about 42 minutes, or about 40% slower than the baseline tests. There were 12 tests (out of more than 4800) that failed under normal circumstances. Using UBSan, 49 tests failed, and there were about 48,463 different runtime errors reported by UBSan.<br><h4>The failing tests</h4>Of the 37 tests that failed under UBSan, 34 of them were aborted because of <code>uncaught exception of type XXXX</code>, where XXX was from the standard library (<code>std::out_of_range</code>, for example). This is caused by a mismatch between libc++ and libc++abi, specifically by the fact that both my custom-built libc++ and my custom-built libc++abi contained typeinfo records for some of the standard exception classes. Getting this right and getting all the bits of the test infrastructure to use the right libraries turned into a big mess very quickly, and I still don't have a good solution here.<br><br>However, I was able to convince myself that these failures were not the result of a bug in either libc++, the test suite or UBSan.<br><br>The other three failures were in the <code>std::thread</code> test suite. When I investigated, it turned out that there was a race condition in some of the thread tests. <em>A race condition? In threading code? Inconceivable!</em><br><br>Apparently the runtime environment under UBSan was different enough to trigger the (latent) race condition in these three tests. Looking at the test suite, I found the same race condition in 10 other tests as well. I committed revision 178029 to fix this in all 13 tests.<br><h4>The error messages</h4>48K errors! I can't look at 48K error messages; so I decided to bin them.<br><br>There were 37,675 messages of the form: <code>0x000106ae3fff: runtime error: value inf is outside the range of representable values of type 'xxxx'&nbsp;</code>where "xxxx" could be "double" or "float" (this also included "-inf" as well)<br><br>and 10,693 messages of the form: <code>0x000101a8f244: runtime error: value nan is outside the range of representable values of type 'xxxx';</code>&nbsp;where "xxxx" could be "double" or "float".<br><br>There were 52 messages of the form: &nbsp;<code>what.pass.cpp:24:9: runtime error: member call on address 0x7fff5e8f48d0 which does not point to an object of type 'std::logic_error'.</code><br><br>There were 29 messages like this: &nbsp;<code>eval.pass.cpp:180:14: runtime error: division by zero</code><br><br>There were 6 messages like this: <code>/Sources/LLVM/libcxx/include/memory:3163:25 runtime error: load of misaligned address 0x7fff569a85c6 for type 'const unsigned long', which requires 8 byte alignment</code><br><br>There were 5 messages like this: <code>0x0001037a329e: runtime error: load of value 4294967294, which is not a valid value for type 'std::regex_constants::match_flag_type'</code><br><br>There were 2 messages like this: <code>/Sources/LLVM/libcxx/include/locale:3361:48: runtime error: index 40 out of bounds for type 'char_type [10]'</code><br><br>&nbsp;There was one message like this: <code>runtime error: load of value 64, which is not a valid value for type 'bool'</code><br><br>The first thing that I noticed is that sometimes UBSan will give you file and line number, and otherwise just a hex address. The file and line number is incredibly useful for tracking stuff down.<br><h4>The Analysis</h4>Working from the bottom up:<br><br>The <code>load of value 64, which is not a valid value for type 'bool'</code> message came out of one of the atomics tests, where it is trying to clear and set an atomic flag that has been default constructed. I don't know what the correct behavior is here; I'm still looking at this one.<br><br>The <code>index 40 out of bounds for type 'char_type [10]'</code> errors came from the money formatting tests in libc++, and were failing only on "wide string" versions of the tests; i.e, with two (or four) byte characters. The offending line turned out to be:<br><pre><code>*__nc = __src[find(__atoms, __atoms+sizeof(__atoms), *__w) - __atoms];</code></pre>and the problem was that sizeof(__atoms) was assumed to be the same as the number of entries in that array. Perfectly fine for character arrays, not so fine for wide character arrays. Fixed in revision 177694.<br><br>The <code>load of value 4294967294, which is not a valid value for type 'std::regex_constants::match_flag_type'</code> errors turned out to be simple to fix as well, once we decided what the right fix was.<br><br>This turned out to be complicated, because it involved a close reading of the standards document. The problem was that <code>match_flag_type</code> was an enum, emulating a bitmask. The type also had an <code>operator ~()</code>, which flipped all the bits in the type. But since the type was implemented as an enum, it had an underlying integer type that it was represented as, and the <code>operator ~</code> just flipped all the bits. This led to values that UBSan didn't like. A large discussion followed, with sentiments like "does it matter" and "can any code actually tell", and so on. Eventually, I just changed the <code>operator ~</code> to only flip the bits that are valid in the enumeration. Fixed in revision 177693.<br><br>The <code>load of misaligned address 0x7fff569a85c6 for type 'const unsigned long', which requires 8 byte alignment</code> were in the hashing code for strings. They are a performance optimization, and I haven't tried to touch them. Whatever changes are made here will have to be done very carefully, since this will affect the performance of all the associative containers.<br><br>The "division by zero" messages were in three different tests. There were 3 of them in the numeric limits tests, and they were there on purpose. There were 2 of them in the complex number tests, and they were also on purpose. The other 24 of them were in the random number test suite, where the tests were generating a bunch of random numbers (using various distributions) and checking to see that the mean, variance, standard deviation, skew, etc, were all what the programmer expected. The problem is in the last measurement: skew. It is some calculated value divided by the variance. If the variance is zero, then the skew should be infinity. Many of the tests in the random number suite are testing "edge cases" of the random number generators, and some of these edge cases will produce a sequence where all the numbers are the same (and thus, the variance == 0). We solved this by commenting out the calculation of the skew for these degenerate cases, and leaving a comment in the test source file. Howard fixed this in revision 177826.<br><br>The <code>runtime error: member call on address 0x7fff5e8f48d0 which does not point to an object of type 'std::logic_error'</code> messages, as it turned out, were due to a bug in UBSan.<br><br>I'm just getting started on the <code>inf</code>/<code>-inf</code>/<code>nan</code> messages (about 48K of those). Most of these come from the complex number regression tests. Since this is a test suite for a library that implements a bunch of numeric routines, a lot of the tests actually do generate and use nan/inf, so I expect that many of these will be "false positives". Richard Smith has pointed out:<br><br><blockquote>The C++ standard’s treatment of Inf and NaN values is highly underspecified, so for the most part it’s not clear what has defined behavior and what does not.&nbsp;</blockquote><blockquote>Anyway… I’m updating UBSan to suppress the diagnostics for conversions of ‘Inf’ and ‘NaN’ between floating-point types, and will probably split out a separate flag for finite overflow in conversions to floating-point types, so that users can turn it off as needed. I think that’s the right compromise for the time being.</blockquote><h4>Conclusions</h4>This exercise, while not completed, has already turned up a set of bugs in the libc++ test suite, as well as a bug in libc++ and some undefined behavior in libc++. There's more to look at here, but I think this was a good exercise. There's kind of a mismatch of expectations here, especially in the complex and numeric test suites, because UBSan is looking for nan/inf/-inf and the libc++ test code is deliberately generating them.<br><br>Thanks to Howard Hinnant for his patience and explanations about the C++ standard and libc++ and the libc++ test suite, and to Richard Smith for his help with UBSan and interpreting the C++ standard.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2013/03/testing-libc-with-address-sanitizer.html><i class="fa fa-chevron-circle-left"></i> Testing libc++ with Address Sanitizer</a></li><li><a href=https://blog.llvm.org/2013/04/llvm-debianubuntu-nightly-packages.html>LLVM Debian/Ubuntu nightly packages <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>