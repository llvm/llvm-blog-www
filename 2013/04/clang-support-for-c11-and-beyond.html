<!doctype html><html lang=en><head><title>Clang support for C++11 and beyond - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Richard Smith"><meta property="og:url" content="https://blog.llvm.org/2013/04/clang-support-for-c11-and-beyond.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Clang support for C++11 and beyond"><meta property="og:description" content='As of r179861, Clang implements the entirety of the C++11 language standard. The following features have been implemented since the release of Clang 3.2, along with our plans for "'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-04-21T07:04:00+00:00"><meta property="article:modified_time" content="2013-04-21T07:04:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="New-in-Llvm-3.3"><meta property="article:tag" content="Clang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Clang support for C++11 and beyond"><meta name=twitter:description content='As of r179861, Clang implements the entirety of the C++11 language standard. The following features have been implemented since the release of Clang 3.2, along with our plans for "'><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Clang support for C++11 and beyond</h1><aside><ul><li><time class=post-date datetime=2013-04-21T07:04:00Z>Apr 21, 2013</time></li><li><em><a href=https://blog.llvm.org/tags/c++>#C++</a>
,
<a href=https://blog.llvm.org/tags/new-in-llvm-3.3>#new-in-llvm-3.3</a>
,
<a href=https://blog.llvm.org/tags/clang>#Clang</a></em></li><li>4 minute read</li></ul></aside>As of <a href="http://llvm.org/viewvc/llvm-project?view=revision&amp;revision=179861">r179861</a>, Clang implements the <b>entirety</b> of the C++11 language standard. The following features have been implemented since the release of Clang 3.2, along with our plans for "C++1y".<br><br><a name=more></a><br><h3>Support for <tt>[[attributes]]</tt></h3>C++11's <tt>[[attribute]]</tt> syntax is now fully supported, including support for the standard <tt>[[noreturn]]</tt> and <tt>[[carries_dependency]]</tt> attributes (although <tt>[[carries_dependency]]</tt> does not provide improved code generation). This allows non-returning functions to be written with a standard syntax:<br><br><pre>[[noreturn]] void foo() {<br>  while (true) do_something();<br>}<br></pre><pre></pre><br>Just like <tt>__attribute__((noreturn))</tt>, Clang will warn you if you use this attribute on a function which can return, and will optimize callers on the assumption that the function does not return. Unlike <tt>__attribute__((noreturn))</tt>, <tt>[[noreturn]]</tt> is never part of a function's type.<br><br>As with g++'s implementation, <tt>__attribute__((foo))</tt> attributes which are supported by g++ can be written as <tt>[[gnu::foo]]</tt>. Clang-specific <tt>__attribute__((...))</tt>s are not available through this syntax (patches to add <tt>[[clang::...]]</tt> attribute names are welcome).<br><br>Clang also now provides complete support for C++11's almost-attribute <tt>alignas(...)</tt>.<br><h3>Inheriting constructors</h3>Clang now supports C++11's inheriting constructor syntax, which provides a simple mechanism to re-export all the constructors from a base class, other than default constructors, or constructors which would be copy or move constructors for either the base or derived class. Example:<br><br><pre>struct Base {<br>  Base(); // default constructor, not inherited<br>  Base(int, char);<br>  template&lt;typename T&gt; Base(T &amp;x);<br>};<br>struct Derived : Base {<br>  using Base::Base;<br>};<br>Derived f(1, 'x');<br>Derived d("foo"); // ok, calls inheriting constructor template<br></pre><h3><tt>thread_local</tt> variables</h3>Clang now supports C++11's <tt>thread_local</tt> keyword, including dynamic initialization and destruction of thread-local objects. Dynamic destruction requires a C++ runtime library which provides <tt>__cxa_thread_atexit</tt>, which is currently only provided by the g++4.8 C++ runtime library.<br><h2>C++1y</h2>With C++11 out of the door, what's next? The C++ standardization committee voted yesterday to create the first Committee Draft for C++1y (which will very likely be C++14). Since this is only the first draft, there will probably be many minor changes before C++1y is done, but the rough feature set is unlikely to change much. This new language standard includes:<br><ul><li>Generalized lambdas, allowing a templated call operator and arbitrary captures:<br><br><pre>auto apply = [v(21)] (auto &amp;&amp;fn) { fn(v); };<br>apply([] (int &amp;n) { n += 21; });<br>apply([] (int n) { std::cout &lt;&lt; n; });<br><br></pre></li><li>Return type deduction for (non-lambda) functions:<br><br><pre>auto fn(int n) { return something(n); }<br><br></pre></li><li>A more powerful <tt>constexpr</tt> feature, allowing variable mutation and loops:<br><br><pre></pre><pre>constexpr auto len(const char *str) {<br>  int k = 0;<br>  while (*str++) ++k;<br>  return k;<br>}<br>static_assert(len("foo") == 3, "hooray");<br></pre></li></ul>The improved <tt>constexpr</tt> feature comes with a backwards-compatibility cost, however. In order to support variable mutation for user-defined types, those types need to have <tt>constexpr</tt> member functions which are not <tt>const</tt>, so the C++11 rule which made <tt>constexpr</tt> member functions implicitly <tt>const</tt> has been removed. This means that you will need to make the <tt>const</tt> explicit if you were previously relying on this shorthand. Rewrite:<br><br><pre></pre><pre>struct S {<br>  int n;<br>  constexpr int get() { return n; }<br>};<br></pre><br>... as ...<br><pre></pre><pre>struct S {<br>  int n;<br>  constexpr int get() const { return n; }<br>};<br></pre><br>... and your code will work in both C++11 and C++14. Clang already has a warning for code which is relying on the implicit <tt>const</tt> rule, and will fix it for you if you run <tt>clang -fixit</tt>. Other compilers supporting C++11 <tt>constexpr</tt>&nbsp;are expected to start providing similar warnings soon.<br><br>Several of the new features were prototyped in Clang prior to standardization, and we expect implementations of those to land in Clang SVN over the coming weeks. See the <a href=http://clang.llvm.org/cxx_status.html>Clang C++ status page</a> for the latest details on C++1y features and Clang's support for them. The implemented features can be enabled with the <tt>-std=c++1y</tt> command-line flag.<br><br>If you find bugs in the C++11 support, please report them on <a href=http://llvm.org/bugs>our bug tracker</a>. If you want to get involved fixing bugs or working on C++1y support, <a href=http://clang.llvm.org/get_involved.html>our website</a> has details of how you can help.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2013/04/euro-llvm-2013-in-paris.html><i class="fa fa-chevron-circle-left"></i> Euro LLVM 2013 in Paris</a></li><li><a href=https://blog.llvm.org/2013/05/eurollvm-2013-paris-france.html>EuroLLVM 2013, Paris, France <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>