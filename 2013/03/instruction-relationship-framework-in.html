<!doctype html><html lang=en><head><title>Instruction Relationship Framework in LLVM - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Jyotsna Verma"><meta property="og:url" content="https://blog.llvm.org/2013/03/instruction-relationship-framework-in.html"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="Instruction Relationship Framework in LLVM"><meta property="og:description" content="The article provides an overview of the new Relationship framework of TableGen. This TableGen feature is used to describe user defined relationships between instructions. It was added to LLVM in October 2012."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-03-20T13:42:00+00:00"><meta property="article:modified_time" content="2013-03-20T13:42:00+00:00"><meta property="article:tag" content="Codegen"><meta property="article:tag" content="MC"><meta name=twitter:card content="summary"><meta name=twitter:title content="Instruction Relationship Framework in LLVM"><meta name=twitter:description content="The article provides an overview of the new Relationship framework of TableGen. This TableGen feature is used to describe user defined relationships between instructions. It was added to LLVM in October 2012."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Instruction Relationship Framework in LLVM</h1><aside><ul><li>By Jyotsna Verma</li><li><time class=post-date datetime=2013-03-20T13:42:00Z>Mar 20, 2013</time></li><li><em><a href=https://blog.llvm.org/tags/codegen>#codegen</a>
,
<a href=https://blog.llvm.org/tags/mc>#MC</a></em></li><li>9 minute read</li></ul></aside>The article provides an overview of the new Relationship framework of TableGen. This TableGen feature is used to describe user defined relationships between instructions. It was added to LLVM in October 2012. <a name=more></a><h3 id=Motivation>Motivation:</h3>The motivation for this feature stemmed from the Hexagon backend. Much like other processors, Hexagon provides multiple variations for many instructions. It is a common requirement in machine instruction passes to switch between various formats of the same instruction. For example, consider an <tt>Add</tt> instruction with predicated true (<tt>Add_pt</tt>) and predicated false (<tt>Add_pf</tt>) forms. Let's assume that a non-predicated <tt>Add</tt> instruction is selected during target lowering. However, during if-conversion, the optimization pass might decide to change the non-predicated <tt>Add</tt> into the predicated true <tt>Add_pt</tt> form. These transformations require a framework to relate non-predicated forms to the respective predicated forms. In the absence of such a framework, this transformation is typically achieved using large switch cases. There are many deficiencies in using a switch case based approach. The manual implementation of switch case clauses requires a very high maintenance cost. It also results in lost optimization opportunities due to incomplete implementation of switch cases. The lack of a relationship model resulted in around 15% of Hexagon backend code dedicated to switch cases with several of those functions growing to over thousands of lines of code.<br><br>This problem inspired us to explore some alternatives. We started to look for a framework that was easy to maintain, flexible, scalable, and less error prone. After some initial discussions and brainstorming in the Hexagon group, we decided to modify TableGen to express instruction relations. The initial design was submitted to the LLVM-dev mailing list for review. Jakob Stoklund gave valuable suggestions and helped with the design of the relationship framework. The idea was to add a query language that can be used to define different kind of relationships between instructions. TableGen was extended to parse relationship models. It uses the information to construct tables which are queried to determine new opcodes corresponding to a relationship. The Hexagon backend relies heavily on the relationship framework and it has significantly improved the code quality of our target.<br><br>Before getting into the implementation details, let's consider an API that takes an instruction opcode as input and returns its predicated true/false form. We'll first look at the switch-case based solution and then compare it with the relationship based implementation.<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>short getPredicatedTrue(short opcode) {<br>switch (opcode) {<br>default:<br>  return -1;<br>case Hexagon::Add:<br>  return Hexagon::Add_pt;<br>case Hexagon::Sub:<br>  return Hexagon::Sub_pt;<br>case Hexagon::And:<br>  return Hexagon::And_pt;<br>case Hexagon::Or:<br>  return Hexagon::Or_pt;<br>case ... :<br>  return ...<br>}<br><br>short getPredicatedFalse(short opcode) {<br>switch (opcode) {<br>default:<br>  return -1;<br>case Hexagon::Add:<br>  return Hexagon::Add_pf;<br>case Hexagon::Sub:<br>  return Hexagon::Sub_pf;<br>case Hexagon::And:<br>  return Hexagon::And_pf;<br>case Hexagon::Or:<br>  return Hexagon::Or_pf;<br>case ... :<br>  return ...<br>}<br><br>short getPredicatedOpcode(short opcode, bool predSense) {<br>return predSense ? getPredicatedTrue(opcode)<br>                 : getPredicatedFlase(opcode);<br>}<br><br></pre></div>The switch-case based approach becomes quite unwieldy because of the large number of cases. Also, it requires continuous maintenance as new instructions are added. The problem becomes more demanding when an instruction has multiple relations since each of these APIs must be updated.<br><br>The relationship framework offers a very systematic solution to this problem. It requires instructions to model their attributes and categorize their groups. For instance, a field called 'PredSense' can be used to record whether an instruction is predicated or not and its sense of predication. Each instruction in the group has to be unique such that no two instructions can share all the same attributes. There must be at least one field with different value. The instruction groups are modeled by assigning a common base name to all the instructions in the group. One of the biggest advantages of this approach is that, by modeling these attributes and groups once, we can define multiple relationships with very little effort.<br><br>With the relationship framework, the <tt>getPredicatedOpcode</tt> API can be implemented as below:<br><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>short getPredicatedOpcode(short opcode, bool predSense) {<br>return predSense ? getPredicated(opcode, PredSenseTrue)<br>                 : getPredicated(opcode, PredSenseFalse);<br>}<br><br></pre></div>Here, <tt>getPredicated()</tt> function is automatically generated by the relationship framework. It performs a query into the corresponding relationship table, also generated by the framework, and returns the matching predicated opcode if found.<br><h3 id=architecture>Architecture:</h3>The entire framework is driven by a class called <tt>InstrMapping</tt>. The TableGen back-end has been extended to include a new parser for the relationship models implemented using <tt>InstrMapping</tt> class. Any relationship model must derive from this class and assign all the class members to the appropriate values. This is how the class looks like:<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>class InstrMapping {<br>  // Used to reduce search space only to the instructions using this relation model<br>  string FilterClass;<br><br>  // List of fields/attributes that should be same for all the instructions in<br>  // a row of the relation table. Think of this as a set of properties shared<br>  // by all the instructions related by this relationship.<br>  list<string> RowFields = [];<br>  // List of fields/attributes that are same for all the instructions<br>  // in a column of the relation table.<br>  list<string> ColFields = [];<br><br>  // Values for the fields/attributes listed in 'ColFields' corresponding to<br>  // the key instruction. This is the instruction that will be transformed<br>  // using this relation model.<br>  list<string> KeyCol = [];<br><br>  // List of values for the fields/attributes listed in 'ColFields', one for<br>  // each column in the relation table. These are the instructions a key<br>  // instruction will be transformed into.<br>  list<list string> &gt; ValueCols = [];<br>}<br><br></list></string></string></string></pre></div>Now, let's revisit the <tt>getPredicated</tt> API. As mentioned earlier, this function can be auto-generated by the relationship framework. It requires us to define a relationship model that can relate non-predicated instructions with their predicated forms:<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>def getPredicated : InstrMapping {<br>  // Choose a FilterClass that is used as a base class for all the instructions modeling<br>  // this relationship. This is done to reduce the search space only to these set of instructions.<br>  let FilterClass = "PredRel";<br><br>  // Instructions with same values for all the fields in RowFields form a row in the resulting<br>  // relation table.<br>  // For example, if we want to relate 'Add' (non-predicated) with 'Add_pt'<br>  // (predicated true) and 'Add_pf' (predicated false), then all 3<br>  // instructions need to have a common base name, i.e., same value for BaseOpcode here. It can be <br>  // any unique value (Ex: XYZ) and should not be shared with any other instruction not related to 'Add'.<br>  let RowFields = ["BaseOpcode"];<br><br>  // List of attributes that can be used to define key and column instructions for a relation.<br>  // Here, key instruction is passed as an argument to the function used for querying relation tables.<br>  // Column instructions are the instructions they (key) can transform into.<br>  //<br>  // Here, we choose 'PredSense' as ColFields since this is the unique attribute of the key<br>  // (non-predicated) and column (true/false) instructions involved in this relationship model.<br>  let ColFields = ["PredSense"];<br><br>  // The key column contains non-predicated instructions.<br>  let KeyCol = ["none"];<br><br>  // Two value columns - first column contains instructions with PredSense=true while the second<br>  // column has instructions with PredSense=false.<br>  let ValueCols = [["true"], ["false"]];<br>}<br><br></pre></div>This relationship model is processed and the information is used to construct a table along with the API to query. All this is emitted in the <tt>XXXInstrInfo.inc</tt> file. However, with the changes made so far, we may end up with an empty relation table since we haven't defined <tt>PredSense</tt> and <tt>BaseOpcode</tt> for any of the instructions yet.<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>multiclass ALU32_Pred<string bit mnemonic prednot> {<br>  let <span style=color:#4169e1;font-weight:700>PredSense = !if(PredNot, "false", "true")</span>, isPredicated = 1 in<br>  def NAME : ALU32_rr&lt;(outs IntRegs:$dst),<br>            (ins PredRegs:$src1, IntRegs:$src2, IntRegs: $src3),<br>            !if(PredNot, "if (!$src1)", "if ($src1)")#<br>            " $dst = "#mnemonic#"($src2, $src3)",<br>            []&gt;;<br>}<br><br>multiclass ALU32_base<string baseop mnemonic opnode sdnode string> {<br>  let <span style=color:#4169e1;font-weight:700>BaseOpcode = BaseOp</span> in {<br>    let isPredicable = 1 in<br>    def NAME : ALU32_rr&lt;(outs IntRegs:$dst),<br>            (ins IntRegs:$src1, IntRegs:$src2),<br>            "$dst = "#mnemonic#"($src1, $src2)",<br>            [(set (i32 IntRegs:$dst), (OpNode (i32 IntRegs:$src1),<br>                                              (i32 IntRegs:$src2)))]&gt;;<br><br>      defm pt : ALU32_Pred<mnemonic 0>; // Predicate true<br>      defm pf : ALU32_Pred<mnemonic 1>; // Predicate false<br>  }<br>}<br><br>let isCommutable = 1 in {<br>  defm Add : ALU32_base&lt;"add", "ADD", add&gt;, <span style=color:#4169e1;font-weight:700>PredRel</span>;<br>  defm And : ALU32_base&lt;"and", "AND", and&gt;, <span style=color:#4169e1;font-weight:700>PredRel</span>;<br>  defm Xor: ALU32_base&lt;"xor", "XOR", xor&gt;, <span style=color:#4169e1;font-weight:700>PredRel</span>;<br>  defm Or  : ALU32_base&lt;"or", "OR", or&gt;, <span style=color:#4169e1;font-weight:700>PredRel</span>;<br>}<br>defm Sub : ALU32_base&lt;"sub", "SUB", sub&gt;, <span style=color:#4169e1;font-weight:700>PredRel</span>;<br><br></mnemonic></mnemonic></string></string></pre></div>Fields highlighted in blue are solely for the purpose of Relationship framework. Here, <tt>PredRel</tt> is a filter class used to extract instructions that may be related using <tt>getPredicated</tt> relationship model. All the instructions using this model are expected to derive from <tt>PreRel</tt> class. <tt>BaseOpcode</tt> is used to group related instructions together. In the above example, all the variants of <tt>Add</tt> instruction, <tt>Add, Add_pt, Add_pf</tt> will have their BaseOpcode set to <tt>ADD</tt>. Similarly, <tt>BaseOpcode</tt> for all the variants for <tt>Sub</tt> is set to <tt>SUB</tt>. It can be any string unique across all groups. <tt>PredSense</tt> is used to identify instructions within each group.<br><br>With the help of this extra information, TableGen is able to construct the following API. It offers the same functionality as switch-case based approach and significantly reduces the maintenance overhead:<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>int getPredicated(uint16_t Opcode, enum PredSense inPredSense) {<br>static const uint16_t getPredicatedTable[][3] = {<br>  { Hexagon::Add, Hexagon::Add_pt, Hexagon::Add_pf },<br>  { Hexagon::And, Hexagon::And_pt, Hexagon::And_pf },<br>  { Hexagon::Or, Hexagon::Or_pt, Hexagon::Or_pf },<br>  { Hexagon::Sub, Hexagon::Sub_pt, Hexagon::Sub_pf },<br>  { Hexagon::Xor, Hexagon::Xor_pt, Hexagon::Xor_pf },<br>}; // End of getPredicatedTable<br><br>  unsigned mid;<br>  unsigned start = 0;<br>  unsigned end = 5;<br>  while (start &lt; end) {<br>    mid = start + (end - start)/2;<br>    if (Opcode == getPredicatedTable[mid][0]) {<br>      break;<br>    }<br>    if (Opcode &lt; getPredicatedTable[mid][0])<br>      end = mid;<br>    else<br>      start = mid + 1;<br>  }<br>  if (start == end)<br>    return -1; // Instruction doesn't exist in this table.<br><br>  if (inPredSense == PredSense_true)<br>    return getPredOpcodeTable[mid][1];<br>  if (inPredSense == PredSense_false)<br>    return getPredicatedTable[mid][2];<br>  return -1;<br>}<br><br></pre></div>Once instructions have been defined to appropriately model their properties, defining new instruction mappings become extremely easy. Now, say we want to have an API that allows us to transform a <tt>predicate-true</tt> instruction into its <tt>predicate-false</tt> form. This can be done by defining a new relationship model. For this model, we don't have to modify any of the instruction definitions as they already have all the necessary information present.<br \><div class=highlight style=background:#fff><pre style=line-height:150%><br><br>//===------------------------------------------------------------------===//<br>// Generate mapping table to relate predicate-true instructions with their<br>// predicate-false forms<br>//<br>def getFalsePredOpcode : InstrMapping {<br>  let FilterClass = "PredRel";<br>  let RowFields = ["BaseOpcode"];<br>  let ColFields = ["PredSense"];<br>  let KeyCol = ["true"];<br>  let ValueCols = [["false"]];<br>}<br><br></pre></div><h3 id=conclusion>Conclusion:</h3>I hope this article succeeds in providing some useful information about the framework. The Hexagon backend makes extensive use of this feature and can be used as a reference for getting started on relationship framework.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/2012/12/new-loop-vectorizer.html><i class="fa fa-chevron-circle-left"></i> New Loop Vectorizer</a></li><li><a href=https://blog.llvm.org/2013/03/testing-libc-with-address-sanitizer.html>Testing libc++ with Address Sanitizer <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>