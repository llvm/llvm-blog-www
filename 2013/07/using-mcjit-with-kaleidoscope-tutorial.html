<!doctype html><html lang=en>
<head>
<title>Using MCJIT with the Kaleidoscope Tutorial - The LLVM Project Blog</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="LLVM Project News and Details from the Trenches">
<meta name=author content="Andy Kaylor"><meta property="og:title" content="Using MCJIT with the Kaleidoscope Tutorial">
<meta property="og:description" content="You may have noticed that there are two different JIT execution engines in the LLVM project.&nbsp; The older implementation (llvm::JIT) is a sort of ad hoc implementation that brings together various pieces of the LLVM code generation and adds its own glue to get dynamically generated code into memory one function at a time.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.llvm.org/2013/07/using-mcjit-with-kaleidoscope-tutorial.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2013-07-22T11:49:00+00:00">
<meta property="article:modified_time" content="2013-07-22T11:49:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Using MCJIT with the Kaleidoscope Tutorial">
<meta name=twitter:description content="You may have noticed that there are two different JIT execution engines in the LLVM project.&nbsp; The older implementation (llvm::JIT) is a sort of ad hoc implementation that brings together various pieces of the LLVM code generation and adds its own glue to get dynamically generated code into memory one function at a time.">
<meta name=generator content="Hugo 0.89.4">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://blog.llvm.org/>The LLVM Project Blog</a>
</h1>
<ul id=social-media>
<li>
<a href=https://www.facebook.com/llvmorg title=Facebook>
<i class="fab fa-facebook fa-lg"></i>
</a>
</li>
<li>
<a href=https://github.com/llvm title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/llvmorg title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://www.youtube.com/c/LLVMPROJ title=Youtube>
<i class="fab fa-youtube fa-lg"></i>
</a>
</li>
</ul>
<p><em>LLVM Project News and Details from the Trenches</em></p>
</header>
<nav>
<ul>
<li>
<a href=https://blog.llvm.org/about>
<i class="fa-li fa fa-lg"></i><span>About</span>
</a>
</li>
<li>
<a href=https://blog.llvm.org/posts>
<i class="fa-li fa fa-lg"></i><span>Posts</span>
</a>
</li>
<li>
<a href=https://blog.llvm.org/tags>
<i class="fa-li fa fa-lg"></i><span>Tags</span>
</a>
</li>
<li>
<a href=https://llvm.org/>
<i class="fa-li fa fa-lg"></i><span>llvm.org</span>
</a>
</li>
</ul>
</nav>
<main>
<article>
<h1>Using MCJIT with the Kaleidoscope Tutorial</h1>
<aside>
<ul>
<li>By Andy Kaylor</li>
<li>
<time class=post-date datetime=2013-07-22T11:49:00Z>Jul 22, 2013</time>
</li>
<li>
<em>
<a href=https://blog.llvm.org/tags/mc>#MC</a>
,
<a href=https://blog.llvm.org/tags/jit>#jit</a>
</em>
</li>
<li>15 minute read</li>
</ul>
</aside>
<div class=MsoNormal>You may have noticed that there are two different JIT execution engines in the LLVM project.&nbsp; The older implementation (llvm::JIT) is a sort of ad hoc implementation that brings together various pieces of the LLVM code generation and adds its own glue to get dynamically generated code into memory one function at a time.&nbsp; The newer implementation (llvm::MCJIT) is heavily based on the core MC library and emits complete object files into memory then prepares them for execution.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>MCJIT has several advantages, including broader platform support and better tool integration.&nbsp; However, because it is designed to compile entire modules into object images the MCJIT engine doesn’t directly support some key features of the older JIT implementation, such as lazy compilation.&nbsp; By lazy compilation, I mean deferring compilation of individual functions until just before the function is going to be executed.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>At this point you may find yourself saying, “Wait a minute?&nbsp; Are you saying MC<b><i>JIT</i></b>doesn’t do ‘just-in-time’ compilation?!?”&nbsp; Well…sort of.&nbsp; It’s more of a dynamic code emitter than a true just-in-time compiler.&nbsp; That said we’d like it to become a long term replacement for the old JIT so that we can reap the benefits of ongoing development in core MC code generation.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>So the question becomes, can we make MCJIT do what the older JIT engine does?&nbsp; The current answer is, “I hope so.”&nbsp; As a means of exploring this question, I decided to try to convert the Kaleidoscope tutorial to use MCJIT.<o:p></o:p></div><div class=MsoNormal><br><a name=more></a><br></div><div class=MsoNormal>The Kaleidoscope tutorial demonstrates a simple interactive interpreter (“toy”) designed to teach developers how to implement a simple programming language using LLVM.&nbsp; Kaleidoscope is presented as a procedural language that supports floating point variables, function calls and a few basic operators.&nbsp; The tutorial uses the JIT execution engine to produce executable code from user input.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Since MCJIT was conceived as a drop in replacement for the older JIT engine, putting it into the Kaleidoscope tutorial should be easy, right?&nbsp; Eh….keep reading and you can judge for yourself.&nbsp; Along the way, you’ll see firsthand some of the key differences between these two engines.<o:p></o:p></div><h3>First Steps</h3><h1><o:p></o:p></h1><div class=MsoNormal>I’ll be starting where the Kaleidoscope tutorial ends.&nbsp; If you want to follow along, you can grab the final Kaleidoscope source code from the LLVM source tree at<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">&lt;llvm_root>/examples/Kaleidoscope/Chapter7/toy.cpp</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>There’s a Makefile there too, but it is intended to build the program in place as part of a complete LLVM build, so we’ll be using a command line approach.&nbsp; For now, you can just type the build command in the Kaleidoscope tutorial:</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">clang++ -g toy.cpp `llvm-config --cppflags --ldflags --libs core jit native` -O3 –o toy</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>If you have the right tools in your path, that should build the tutorial for you.</div><div class=MsoNormal><o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>The first change we’ll need to make is to create an MCJIT execution engine instead of a JIT execution engine.&nbsp; This is pretty simple.&nbsp; The ExecutionEngine gets created in the main() function in toy.cpp using an EngineBuilder object with a call that looks like this:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">TheExecutionEngine = EngineBuilder(TheModule).setErrorStr(&ErrStr).create();</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>EngineBuilder creates a JIT engine by default, but you can request an MCJIT engine instead by calling the setUseMCJIT() function, as such:</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace;font-size:x-small">TheExecutionEngine = EngineBuilder(TheModule).setErrorStr(&ErrStr)</span><span style="font-family:Courier New,Courier,monospace;font-size:x-small">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setUseMCJIT(true)</span><span style="font-family:Courier New,Courier,monospace;font-size:x-small">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .create();</span></blockquote><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>You’ll also need to include ‘MCJIT.h’ to get the MCJIT static constructor linked in properly (you can replace ‘JIT.h’) and add two new lines of component initialization at the top of main().</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">IntializeNativeTargetAsmPrinter();</span><span style="font-family:Courier New,Courier,monospace">InitializeNatureTargetAsmParser();</span></blockquote><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>Another feature of MCJIT that I should mention at this point is that it is designed to allow generated code to be remapped for execution in external processes or even on remote systems.&nbsp; As such, it requires that we call ExecutionEngine::finalizeObject() to let it know we’re ready for the generated object to be put in its executable state.&nbsp; We can do that just before calling getPointerToFunction() in HandleTopLevelExpression:</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">TheExecutionEngine->finalizeObject();</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>Now build with the command above, substituting ‘mcjit’ for ‘jit’ in the library list.</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">clang++ -g toy.cpp `llvm-config --cppflags --ldflags --libs core mcjit native` -O3 –o toy</span></blockquote><div class=Code><o:p></o:p></div><h3>Handling Function Names</h3><h1><o:p></o:p></h1><div class=MsoNormal>At this point, you’re up and running with MCJIT.&nbsp; Unfortunately, nothing will work because the interpreter uses unnamed functions to evaluate immediate expressions and MCJIT doesn’t like that.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>For the purposes of this experiment, I’m going to work around that with a quick and dirty hack that generates a simple unique name for such anonymous functions, and while I’m at it I’ll make sure any function names would be legal in C, because that we need that to handle the way our interpreter names operators.&nbsp; My hack looks like this:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">//===----------------------------------------------------------------------===//<br>// Quick and dirty hack<br>//===----------------------------------------------------------------------===//<br><o:p>&nbsp;</o:p>// FIXME: Obviously we can do better than this<br>std::string GenerateUniqueName(const char *root)<br>{<br>&nbsp; static int i = 0;<br>&nbsp; char s[16];<br>&nbsp; sprintf(s, "%s%d", root, i++);<br>&nbsp; std::string S = s;<br>&nbsp; return S;<br>}<br><o:p>&nbsp;</o:p>std::string MakeLegalFunctionName(std::string Name)<br>{<br>&nbsp; std::string NewName;<br>&nbsp; if (!Name.length())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GenerateUniqueName("anon_func_");<br><o:p>&nbsp;</o:p>&nbsp; // Start with what we have<br>&nbsp; NewName = Name;<br><o:p>&nbsp;</o:p>&nbsp; // Look for a numberic first character<br>&nbsp; if (NewName.find_first_of("0123456789") == 0) {<br>&nbsp;&nbsp;&nbsp; NewName.insert(0, 1, 'n');<br>&nbsp; }<br><o:p>&nbsp;</o:p>&nbsp; // Replace illegal characters with their ASCII equivalent<br>&nbsp; std::string legal_elements = "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";<br>&nbsp; size_t pos;<br>&nbsp; while ((pos = NewName.find_first_not_of(legal_elements)) != std::string::npos) {<br>&nbsp;&nbsp;&nbsp; char old_c = NewName.at(pos);<br>&nbsp;&nbsp;&nbsp; char new_str[16];<br>&nbsp;&nbsp;&nbsp; sprintf(new_str, "%d", (int)old_c);<br>&nbsp;&nbsp;&nbsp; NewName = NewName.replace(pos, 1, new_str);<br>&nbsp; }<br><o:p>&nbsp;</o:p>&nbsp; return NewName;<br>}</span></blockquote><div class=CodeCxSpFirst><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>We need to use this in three places.&nbsp; First, in PrototypeAST::Codegen() just before the call to Function::Create()<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">std::string FnName = MakeLegalFunctionName(Name);</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>Also replace subsequent references to ‘Name’ with ‘FnName’ in this function.&nbsp; Changing the ‘Name’ member of the PrototypeAST object would have other unintended consequences, so here we’re just changing the name by which LLVM will know the function.&nbsp; To that end, we also need to update calls to getFunction in UnaryExprAST::Codegen() and BinaryExprAST::Codegen().&nbsp;</div><div class=MsoNormal><o:p></o:p></div><div class=MsoNormal><br></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">Function *F = TheModule->getFunction(MakeLegalFunctionName(std::string("unary")+Opcode));</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>and</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">Function *F = TheModule->getFunction(MakeLegalFunctionName(std::string("binary")+Opcode));</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>A new member variable wouldn’t be a bad idea, but we won’t have to think about this again, so for now let’s just leave it simple.</div><div class=MsoNormal><o:p></o:p></div><h3>Adding Multiple Module Support</h3><h2><o:p></o:p></h2><div class=MsoNormal>Now let’s compile again using the command line above and give this a try.<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">ready> def add(x y) x+y;</span><span style="font-family:Courier New,Courier,monospace">[output omitted]</span><span style="font-family:Courier New,Courier,monospace">ready> add(1, 2);</span><span style="font-family:Courier New,Courier,monospace">ready> Evaluated to 3.000000</span><span style="font-family:Courier New,Courier,monospace">Hurray! It’s working!&nbsp; Let’s keep playing with it.</span><span style="font-family:Courier New,Courier,monospace">ready> add(3, 4);</span><span style="font-family:Courier New,Courier,monospace">ready> Segmentation fault (core dumped)</span></blockquote><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>Oops!&nbsp; What happened?&nbsp; Well, here’s the thing.&nbsp; Our ‘toy’ program creates a single module, uses that to create an execution engine, then keeps adding all the functions it creates to that same module.&nbsp; This works with JIT, which is just generating code for one function at a time.&nbsp; MCJIT, on the other hand, compiles the entire module and expects it to stay compiled.&nbsp; When you add something to it and call finalizeObject() again it will skip the compilation phase (because it thinks the module has already been compiled) and attempt to re-apply relocations.&nbsp; Since the MCJIT memory manager marked the code sections for this object as R-X in the previous call to finalizeObject, the attempt to re-write the relocation crashes.&nbsp; MCJIT should obviously handle this case more gracefully, but the relevant point here is that MCJIT won’t let you continue to modify a module after it’s been compiled.</div><div class=MsoNormal><o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>We’ll need to modify our program to spin off a new module and execution engine every time it compiles a previous module, but as it turns out that’s not as painful to implement as it might sound.&nbsp; Our ‘toy’ program uses three global variables (TheModule, TheFPM and TheExecutionEngine) to handle all the functionality we’re interested in.&nbsp; We’ll create a helper class to replace those three objects and coordinate their behavior.<o:p></o:p></div><div class=MsoNormal>The class will look like this:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">//===----------------------------------------------------------------------===//<br>// MCJIT helper class<br>//===----------------------------------------------------------------------===//<br><o:p>&nbsp;</o:p>class MCJITHelper<br>{<br>public:<br>&nbsp; MCJITHelper(LLVMContext& C) : Context(C), OpenModule(NULL) {}<br>&nbsp; ~MCJITHelper();<br><o:p>&nbsp;</o:p>&nbsp; Function *getFunction(const std::string FnName);<br>&nbsp; Module *getModuleForNewFunction();<br>&nbsp; void *getPointerToFunction(Function* F);<br>&nbsp; void dump();<br><o:p>&nbsp;</o:p>private:<br>&nbsp; typedef std::vector&lt;Module*> ModuleVector;<br>&nbsp; typedef std::vector&lt;ExecutionEngine*> EngineVector;<br><o:p>&nbsp;</o:p>&nbsp; LLVMContext&nbsp; &amp;Context;<br>&nbsp; Module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *OpenModule;<br>&nbsp; ModuleVector&nbsp; Modules;<br>&nbsp; EngineVector&nbsp; Engines;<br>};<br><o:p>&nbsp;</o:p>MCJITHelper::~MCJITHelper()<br>{<br>&nbsp; if (OpenModule)<br>&nbsp;&nbsp;&nbsp; delete OpenModule;<br>&nbsp; EngineVector::iterator begin = Engines.begin();<br>&nbsp; EngineVector::iterator end = Engines.end();<br>&nbsp; EngineVector::iterator it;<br>&nbsp; for (it = begin; it != end; ++it)<br>&nbsp;&nbsp;&nbsp; delete *it;<br>}<br><o:p>&nbsp;</o:p>Function *MCJITHelper::getFunction(const std::string FnName) {<br>&nbsp; ModuleVector::iterator begin = Modules.begin();<br>&nbsp; ModuleVector::iterator end = Modules.end();<br>&nbsp; ModuleVector::iterator it;<br>&nbsp; for (it = begin; it != end; ++it) {<br>&nbsp;&nbsp;&nbsp; Function *F = (*it)->getFunction(FnName);<br>&nbsp;&nbsp;&nbsp; if (F) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*it == OpenModule)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return F;<br><o:p>&nbsp;</o:p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(OpenModule != NULL);<br><o:p>&nbsp;</o:p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This function is in a module that has already been JITed.<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// We need to generate a new prototype for external linkage.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Look for a prototype in the current module.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function *PF = OpenModule->getFunction(FnName);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PF && !PF->empty()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorF("redefinition of function across modules");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><o:p>&nbsp;</o:p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If we don't have a prototype yet, create one.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!PF)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PF = Function::Create(F->getFunctionType(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function::ExternalLinkage,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FnName,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenModule);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PF;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; return NULL;<br>}<br><o:p>&nbsp;</o:p>Module *MCJITHelper::getModuleForNewFunction() {<br>&nbsp; // If we have a Module that hasn't been JITed, use that.<br>&nbsp; if (OpenModule)<br>&nbsp;&nbsp;&nbsp; return OpenModule;<br><o:p>&nbsp;</o:p>&nbsp; // Otherwise create a new Module.<br>&nbsp; std::string ModName = GenerateUniqueName("mcjit_module_");<br>&nbsp; Module *M = new Module(ModName, Context);<br>&nbsp; Modules.push_back(M);<br>&nbsp; OpenModule = M;<br>&nbsp; return M;<br>}<br><o:p>&nbsp;</o:p>void *MCJITHelper::getPointerToFunction(Function* F) {<br>&nbsp; // See if an existing instance of MCJIT has this function.<br>&nbsp; EngineVector::iterator begin = Engines.begin();<br>&nbsp; EngineVector::iterator end = Engines.end();<br>&nbsp; EngineVector::iterator it;<br>&nbsp; for (it = begin; it != end; ++it) {<br>&nbsp;&nbsp;&nbsp; void *P = (*it)->getPointerToFunction(F);<br>&nbsp;&nbsp;&nbsp; if (P)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return P;<br>&nbsp; }<br><o:p>&nbsp;</o:p>&nbsp; // If we didn't find the function, see if we can generate it.<br>&nbsp; if (OpenModule) {<br>&nbsp;&nbsp;&nbsp; std::string ErrStr;<br>&nbsp;&nbsp;&nbsp; ExecutionEngine *NewEngine = EngineBuilder(OpenModule)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.setErrorStr(&ErrStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setUseMCJIT(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .create();<br>&nbsp;&nbsp;&nbsp; if (!NewEngine) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Could not create ExecutionEngine: %s\n", ErrStr.c_str());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; OpenModule = NULL;<br>&nbsp;&nbsp;&nbsp; Engines.push_back(NewEngine);<br>&nbsp;&nbsp;&nbsp; NewEngine->finalizeObject();<br>&nbsp;&nbsp;&nbsp; return NewEngine->getPointerToFunction(F);<br>&nbsp; }<br>&nbsp; return NULL;<br>}<br><o:p>&nbsp;</o:p>void MCJITHelper::dump()<br>{<br>&nbsp; ModuleVector::iterator begin = Modules.begin();<br>&nbsp; ModuleVector::iterator end = Modules.end();<br>&nbsp; ModuleVector::iterator it;<br>&nbsp; for (it = begin; it != end; ++it)<br>&nbsp;&nbsp;&nbsp; (*it)->dump();<br>}</span></blockquote><div class=CodeCxSpFirst><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpLast>The one thing here that might require explanation is the implementation of getFunction.&nbsp; This is used when the interpreter wants to call an existing function.&nbsp; Since we’re dealing with multiple modules now, we need to look for this function in all of the modules our helper class is handling.&nbsp; If we find it in the module we’re currently working with, we can just use it, but if we find it in another module we need to create a prototype in the current module.&nbsp; The function declaration we found in the other module will provide the function type.</div><div class=MsoNormal><o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>We’ll create a new global variable (TheHelper) and get rid of the three previously mentioned.&nbsp; In main() we’ll replace the code that creates and initializes those three objects with a single line of code:<o:p></o:p></div><div class=Code>TheHelper = new MCJITHelper(Context);<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Now we just need to go through the code and replace uses of those three global objects with calls to our helper.&nbsp; There aren’t as many as you might expect.&nbsp; You can find references to TheModule in UnaryExprAST::Codegen(), BinaryExprAST::Codegen(), CallExprAST::Codegen(), and PrototypeAST::Codegen().&nbsp; All of these except the last are just drop-in replacements.&nbsp; In PrototypeAST::Codegen() we need to add a call to TheHelper->getModuleForNewFunction() to get the last argument to Function::Create().<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">Module* M = TheHelper->getModuleForNewFunction();</span><span style="font-family:Courier New,Courier,monospace">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, M);</span></blockquote><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>TheExecutionEngine is used only in HandleTopLevelExpression() and a direct replacement is suitable there, plus we can eliminate the call to finalizeObject since that will happen inside MCJITHelper::getPointerToFunction.</div><div class=MsoNormal><o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>TheFPM is used in FunctionAST::Codegen() but that’s not where we’ll want it for MCJIT purposes.&nbsp; Since we aren’t creating an ExecutionEngine until we need to compile a Module, I’m also going to put the FunctionPassManager creation there and optimize all the functions in a Module just before code generation.&nbsp; This isn’t strictly necessary, but it makes the code generation phase go a bit faster.&nbsp; We can put the following in MCJITHelper::getPointerToFunction() just after the execution engine is created:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">// Create a function pass manager for this engine<br>FunctionPassManager *FPM = new FunctionPassManager(OpenModule);<br><o:p>&nbsp;</o:p>// Set up the optimizer pipeline.&nbsp; Start with registering info about how the<br>// target lays out data structures.<br>FPM->add(new DataLayout(*NewEngine->getDataLayout()));<br>// Provide basic AliasAnalysis support for GVN.<br>FPM->add(createBasicAliasAnalysisPass());<br>// Promote allocas to registers.<br>FPM->add(createPromoteMemoryToRegisterPass());<br>// Do simple "peephole" optimizations and bit-twiddling optzns.<br>FPM->add(createInstructionCombiningPass());<br>// Reassociate expressions.<br>FPM->add(createReassociatePass());<br>// Eliminate Common SubExpressions.<br>FPM->add(createGVNPass());<br>// Simplify the control flow graph (deleting unreachable blocks, etc).<br>FPM->add(createCFGSimplificationPass());<br>FPM->doInitialization();<br><o:p>&nbsp;</o:p>// For each function in the module<br>Module::iterator it;<br>Module::iterator end = OpenModule->end();<br>for (it = OpenModule->begin(); it != end; ++it) {<br>&nbsp; // Run the FPM on this function<br>&nbsp; FPM->run(*it);<br>}<br><o:p>&nbsp;</o:p>// We don't need this anymore<br>delete FPM;</span></blockquote><div class=CodeCxSpFirst><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpLast><o:p></o:p></div><h3>Cross Module Linking</h3><h1><o:p></o:p></h1><div class=MsoNormal>Let’s try what we have now.&nbsp; Recompile using the command line above and start the program:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">ready> def add(x y) x+y;<br>[output omitted]<br>ready> add(1, 2);<br>ready> Evaluated to 3.000000<br>ready> add(3, 4);<br>ready> LLVM ERROR: Program used external function ‘add’ which could not be resolved!</span></blockquote><div class=CodeCxSpFirst><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>Do you see what happened there?&nbsp; Our program created a module, added the function ‘add’ to it and then added a call to that function.&nbsp; At this point, the MCJITHelper compiled that module and started a new module.&nbsp; When we tried to call ‘add’ a second time, the generated call went into the new module, which doesn’t have a definition for ‘add’ – only a prototype.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>To make this work we’re going to need some way to link our dynamic code against previously generated modules.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Here’s how linking works in MCJIT.&nbsp; When code is generated from a Module, a complete object file image is generated into memory.&nbsp; As MCJIT’s runtime loader is preparing this object for execution, it will create a list of external symbols that need to be resolved.&nbsp; It will then call the MCJIT memory manager’s getPointerToNamedFunction method in an attempt to resolve these external symbols.&nbsp; (Why the memory manager? Because that’s the component that knows which address space the JITed code will be running in.)&nbsp; The default memory manager (SectionMemoryManager) uses sys::DynamicLibrary::SearchForAddressOfSymbol() to try to link this symbol against the current process.&nbsp; If it can’t find the symbol, the symbol gets reported as unresolved.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>We could solve the problem of linking dynamically generated objects by iterating through all the symbols in an object as it is loaded and calling sys::DynamicLibrary::AddSymbol() for each one.&nbsp; In some circumstances that might be a good solution (as long as you aren’t worried about name conflicts).&nbsp; However, I’d like to demonstrate an alternative solution which can be adapted to more general purposes.&nbsp; I’m going to create a custom memory manager for linking purposes.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>My new memory manager will inherit from SectionMemoryManager and use the base implementation for the actual memory management.&nbsp; It will also attempt to reuse the base symbol resolution, but if a symbol is not found, it will delegate symbol resolution to our MCJITHelper class, which can search other loaded objects.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Here’s the code for the new memory manager:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">class HelpingMemoryManager : public SectionMemoryManager</span><br><span style="font-family:Courier New,Courier,monospace">{</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; HelpingMemoryManager(const HelpingMemoryManager&) LLVM_DELETED_FUNCTION;</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; void operator=(const HelpingMemoryManager&) LLVM_DELETED_FUNCTION;</span><br><span style="font-family:Courier New,Courier,monospace"><br></span><span style="font-family:Courier New,Courier,monospace">public:</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; HelpingMemoryManager(MCJITHelper *Helper) : MasterHelper(Helper) {}</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; virtual ~HelpingMemoryManager() {}</span><br><span style="font-family:Courier New,Courier,monospace"><br></span><span style="font-family:Courier New,Courier,monospace">&nbsp; /// This method returns the address of the specified function.&nbsp;</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// Our implementation will attempt to find functions in other</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// modules associated with the MCJITHelper to cross link functions</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// from one generated module to another.</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; ///</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// If \p AbortOnFailure is false and no function with the given name is</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// found, this function returns a null pointer. Otherwise, it prints a</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; /// message to stderr and aborts.</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; virtual void *getPointerToNamedFunction(const std::string &Name,</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool AbortOnFailure = true);</span><br><span style="font-family:Courier New,Courier,monospace">private:</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; MCJITHelper *MasterHelper;</span><br><span style="font-family:Courier New,Courier,monospace">};</span><br><span style="font-family:Courier New,Courier,monospace"><br></span><span style="font-family:Courier New,Courier,monospace">void *HelpingMemoryManager::getPointerToNamedFunction(const std::string &Name,</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool AbortOnFailure)</span><br><span style="font-family:Courier New,Courier,monospace">{</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; // Try the standard symbol resolution first, but ask it not to abort.</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; void *pfn = SectionMemoryManager::getPointerToNamedFunction(Name, false);</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; if (pfn)</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; &nbsp; return pfn;</span><br><span style="font-family:Courier New,Courier,monospace"><br></span><span style="font-family:Courier New,Courier,monospace">&nbsp; pfn = MasterHelper->getPointerToNamedFunction(Name);</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; if (!pfn && AbortOnFailure)</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; &nbsp; report_fatal_error("Program used external function '" + Name +</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "' which could not be resolved!");</span><br><span style="font-family:Courier New,Courier,monospace">&nbsp; return pfn;</span><br><span style="font-family:Courier New,Courier,monospace">}</span><br><div><br></div></blockquote><div class=CodeCxSpFirst><span style="font-family:Courier New,Courier,monospace;font-size:x-small"><o:p></o:p></span></div><div class=MsoNormal>(Don’t forget to add this to the class definition if you’re coding along.)<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Finally, we need to set the memory manager in MCJITHelper::getPointerToFunction where we use EngineBuilder to create a new execution engine.<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">ExecutionEngine *NewEngine = EngineBuilder(OpenModule)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setErrorStr(&ErrStr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setUseMCJIT(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setMCJITMemoryManager(new HelpingMemoryManager(this))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .create();</span></blockquote><div class=CodeCxSpFirst><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpMiddle><o:p></o:p></div><div class=CodeCxSpLast><o:p></o:p></div><div class=MsoNormal>If you’re building against the LLVM 3.3 release, you need to use setJITMemoryManager instead of the more recently added setMCJITMemoryManager call.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Finally, chances are you’ve built LLVM with the default settings, which means you built it without runtime type information (RTTI).&nbsp; If that is the case, you’ll also need to start building the sample program without RTTI to get the inheritance from SectionMemoryManager to link properly. If you do that, there’s a place in BinaryExprAST::Codegen where you’ll need to change a ‘dynamic_cast’ to a ‘reinterpret_cast’ to keep things working.&nbsp; You lose a little automatic error checking that way, but since this is just a demo program I think we can live with that.&nbsp; Alternatively, you could rebuild LLVM with RTTI enabled.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Here’s the new command line we’ll use for building our program:<o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">clang++ -g -fno-rtti toy.cpp `llvm-config --cppflags --ldflags --libs core mcjit native` -O3 –o toy</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal>Trying it out one more time:</div><div class=MsoNormal><o:p></o:p></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">ready> def add(x y) x+y;</span><br><span style="font-family:Courier New,Courier,monospace">[output omitted]</span><br><span style="font-family:Courier New,Courier,monospace">ready> add(1, 2);</span><br><span style="font-family:Courier New,Courier,monospace">ready> Evaluated to 3.000000</span><br><span style="font-family:Courier New,Courier,monospace">ready> add(3, 4);</span><br><span style="font-family:Courier New,Courier,monospace">ready> Evaluated to 7.000000</span><br><span style="font-family:Courier New,Courier,monospace">ready> def mul(x y) x*y;</span><br><span style="font-family:Courier New,Courier,monospace">[output omitted]</span><br><span style="font-family:Courier New,Courier,monospace">ready> mul(5, 6);</span><br><span style="font-family:Courier New,Courier,monospace">ready> Evaluated to 30.000000</span><br><span style="font-family:Courier New,Courier,monospace">ready> mul(7, add(8, 9));</span><br><span style="font-family:Courier New,Courier,monospace">ready> Evaluated to 119.000000</span><br><span style="font-family:Courier New,Courier,monospace">ready> extern exit();</span><br><span style="font-family:Courier New,Courier,monospace">[output omitted]</span><br><span style="font-family:Courier New,Courier,monospace">ready> exit();</span></blockquote><div class=MsoNormal>Woo hoo!&nbsp; It’s really working this time.<o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>BTW, you see how that call to exit() got linked against our app, right?&nbsp; The Kaleidoscope tutorial shows you something like that, but the tutorial is a bit out of date.&nbsp; You can link against symbols in shared libraries that our program uses this way, but to link against symbols defined in the main program module you’ll need to build with the ‘-rdynamic’ flag.<o:p></o:p></div><div class=Code><br></div><blockquote class=tr_bq><span style="font-family:Courier New,Courier,monospace">clang++ -g -fno-rtti -rdynamic toy.cpp `llvm-config --cppflags --ldflags --libs core mcjit native` -O3 –o toy</span></blockquote><div class=Code><o:p></o:p></div><div class=MsoNormal><br></div><div class=MsoNormal>Anyway, now we’ve got a functional Kaleidoscope interpreter built using MCJIT.&nbsp; In the next installment I’ll do some crude performance analysis and look at ways that we can make it a little better.<o:p></o:p></div><div class=MsoNormal><br></div>The full source code listing for this post is available in the trunk of the LLVM source tree at &lt;llvm_root>/examples/Kaleidoscope/MCJIT.
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://blog.llvm.org/2013/06/lldb-33-and-beyond.html><i class="fa fa-chevron-circle-left"></i> LLDB 3.3 and beyond</a>
</li>
<li>
<a href=https://blog.llvm.org/2013/07/kaleidoscope-performance-with-mcjit.html>Kaleidoscope Performance with MCJIT <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://blog.llvm.org/js/scripts.js></script>
</body>
</html>