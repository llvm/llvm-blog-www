<!doctype html><html lang=en><head><title>GSoC 2025 - Byte Type: Supporting Raw Data Copies in the LLVM IR - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Pedro Lobo"><meta property="og:url" content="https://blog.llvm.org/posts/2025-08-29-gsoc-byte-type/"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="GSoC 2025 - Byte Type: Supporting Raw Data Copies in the LLVM IR"><meta property="og:description" content="This summer I participated in GSoC under the LLVM Compiler Infrastructure. The goal of the project was to add a new byte type to the LLVM IR, capable of representing raw memory values."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-08T00:00:00+00:00"><meta property="article:tag" content="GSoC"><meta property="article:tag" content="Clang"><meta property="article:tag" content="Optimizations"><meta property="article:tag" content="IR"><meta name=twitter:card content="summary"><meta name=twitter:title content="GSoC 2025 - Byte Type: Supporting Raw Data Copies in the LLVM IR"><meta name=twitter:description content="This summer I participated in GSoC under the LLVM Compiler Infrastructure. The goal of the project was to add a new byte type to the LLVM IR, capable of representing raw memory values."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>GSoC 2025 - Byte Type: Supporting Raw Data Copies in the LLVM IR</h1><aside><ul><li>By Pedro Lobo</li><li><time class=post-date datetime=2025-09-08T00:00:00Z>Sep 8, 2025</time></li><li><em><a href=https://blog.llvm.org/tags/gsoc>#GSoC</a>
,
<a href=https://blog.llvm.org/tags/clang>#clang</a>
,
<a href=https://blog.llvm.org/tags/optimizations>#optimizations</a>
,
<a href=https://blog.llvm.org/tags/ir>#IR</a></em></li><li>22 minute read</li></ul></aside><p>This summer I participated in GSoC under the LLVM Compiler Infrastructure.
The goal of the project was to add a new byte type to the LLVM IR, capable of representing raw memory values.
This new addition enables the native implementation of memory-related intrinsics in the IR, including <code>memcpy</code>, <code>memmove</code> and <code>memcmp</code>, fixes existing unsound transformations and enables new optimizations, all with a minimal performance impact.</p><h1 id=background>Background</h1><p>One of LLVM&rsquo;s longstanding problems is the absence of a type capable of representing raw memory values.
Currently, memory loads of raw bytes are performed through an appropriately sized integer type.
However, integers are incapable of representing an arbitrary memory value.
Firstly, they do not retain pointer provenance information, rendering them unable to fully specify the value of a pointer.
Secondly, loading memory values containing <code>poison</code> bits through an integer type taints the loaded value, as integer values are either <code>poison</code> or have a fully-defined value, with no way to represent individual <code>poison</code> bits.</p><p>Source languages such as C<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and C++<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> provide proper types to inspect and manipulate raw memory.
These include <code>char</code>, <code>signed char</code> and <code>unsigned char</code>.
C++17 introduced the <code>std::byte</code> type, which offers similar raw memory access capabilities, but does not support arithmetic operations.
Currently, Clang lowers these types to the <code>i8</code> integer type, which does not accurately model their raw memory access semantics, motivating miscompilations such as the one reported in <a href="https://bugs.llvm.org/show_bug.cgi?id=37469">bug report 37469</a>.</p><p>The absence of a similar type in the LLVM IR hinders the implementation of memory-related intrinsics such as <code>memcpy</code>, <code>memmove</code> and <code>memcmp</code>, and introduces additional friction when loading and converting memory values to other types, leading to implicit conversions that are hard to identify and reason about.
The two core problems stemming from the absence of a proper type to access and manipulate raw memory, directly addressed by the byte type and explored throughout the remainder of this section, are summarized as follows:</p><ol><li>Integers do not track provenance, rendering them incapable of representing a pointer.</li><li>Loads through integer types spread <code>poison</code> values, which taints the load result if the loaded values contain at least one <code>poison</code> bit (as occurs with padded values).</li></ol><h2 id=pointer-provenance>Pointer Provenance</h2><p>According to the <a href=https://llvm.org/docs/LangRef.html>LLVM Language Reference</a>, pointers track provenance, which is <em>the ability to perform memory accesses through the pointer, in the sense of the pointer aliasing rules</em>.
The main goal of tracking pointer provenance is to simplify alias analysis, yielding more precise results, which enables high-level optimizations.</p><p>Integers, unlike pointers, do not capture provenance information, being solely characterized by their numerical value.
Therefore, loading a pointer through an integer type discards the pointer&rsquo;s provenance.
This is problematic as such loads can cause pointer escapes that go unnoticed by alias analysis.
Once alias analysis is compromised, simple optimizations that rely on the absence of aliasing become invalid, compromising the correctness of the whole compilation process.</p><p>Currently, Alive2 defines the result of loading a pointer value through an integer type as <code>poison</code>.
This implies that loads through integer types fail to accurately recreate the original memory value, hindering pointer copies via integer types.
In the following example, storing a pointer to memory and loading it through the <code>i64</code> type yields <code>poison</code>, invalidating the transformation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %ptr, <span style=color:#960050;background-color:#1e0010>ptr</span> %v) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr
</span></span><span style=display:flex><span>  %l = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %l
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %ptr, <span style=color:#960050;background-color:#1e0010>ptr</span> %v) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr
</span></span><span style=display:flex><span>  %l = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr      <span style=color:#75715e>; poison
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %c = <span style=color:#66d9ef>inttoptr</span> <span style=color:#66d9ef>i64</span> %l <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>  <span style=color:#75715e>; poison
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %c                   <span style=color:#75715e>; poison
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=undefined-behavior>Undefined Behavior</h2><p>LLVMâ€™s <code>poison</code> value is used to represent unspecified values, such as padding bits.
Loading such memory values through an integer type propagates <code>poison</code> values, as integer types are either <code>poison</code> or have a fully-defined value, not providing enough granularity to represent individual <code>poison</code> bits.
This hinders the copy of padded values.</p><p>Moreover, this lack of granularity can lead to subtle issues that are often overlooked.
The <a href=https://llvm.org/docs/LangRef.html#bitcast-to-instruction>LLVM Language Reference</a> defines the <code>bitcast</code> instruction as a <em>no-op cast because no bits change with this conversion</em>.
Nonetheless, while scalar types are either <code>poison</code> or have a fully-defined value, vector types in LLVM track <code>poison</code> values on a per-lane basis.
This introduces potential pitfalls when casting vector types to non-vector types, as the cast operation can inadvertently taint non-<code>poison</code> lanes.
In the following example, considering the first lane of <code>%v</code> to be <code>poison</code>, the result of casting the vector to an <code>i64</code> value is <code>poison</code>, regardless of the value of the second lane.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i64</span> @ub(<span style=color:#960050;background-color:#1e0010>ptr</span> %ptr) {
</span></span><span style=display:flex><span>  %v = <span style=color:#66d9ef>load</span> &lt;<span style=color:#ae81ff>2</span> <span style=color:#66d9ef>x</span> <span style=color:#66d9ef>i32</span>&gt;, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr       <span style=color:#75715e>; &lt;i32 poison, i32 42&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %c = <span style=color:#66d9ef>bitcast</span> &lt;<span style=color:#ae81ff>2</span> <span style=color:#66d9ef>x</span> <span style=color:#66d9ef>i32</span>&gt; %v <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i64</span>    <span style=color:#75715e>; i64 poison
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i64</span> %c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Although covered by the <a href=https://llvm.org/docs/LangRef.html#bitcast-to-instruction>Language Reference</a> ("<em>the [bitcast] conversion is done as if the value had been stored to memory and read back as [the destination type]</em>"), this duality in the value representation between vector and scalar types integer constitutes a corner case that is not widely contemplated and often unnecessarily introduces undefined behavior.</p><h1 id=implementing-the-byte-type>Implementing the Byte Type</h1><p>Back in 2021, a <a href=https://github.com/georgemitenkov/GSoC-2021>GSoC project with a similar goal</a>, produced a working prototype of the byte type.
This prototype introduced the byte type to the IR, lowered C and C++&rsquo;s raw memory access types to the byte type and implemented some optimizations over the new type.</p><p>The current project began by porting these patches to the latest version of LLVM, adapting the code to support the newly introduced opaque pointers.
As the work progressed and new challenges emerged, the original proposal was iteratively refined.
The implementation of the byte type in LLVM and Alive2 can be found <a href=https://github.com/pedroclobo/llvm-project/tree/byte-type>here</a> and <a href=https://github.com/pedroclobo/alive2/tree/byte-type>here</a>, respectively.</p><h2 id=byte-type>Byte Type</h2><p>The byte type is a first-class single-value type, with the same size and alignment as the equivalently sized integer type.
Memory loads through the byte type yield the value&rsquo;s raw representation, without introducing any implicit casts.
This allows the byte type to represent both pointer and non-pointer values.</p><p>Additionally, the byte type is equipped with the necessary granularity to represent <code>poison</code> values at the bit-level, such that loads of padded values through the byte type do not taint the loaded value.
As a consequence, a <code>bitcast</code> between vector and scalar byte types preserves the raw byte value.
In the following example, a <code>poison</code> lane does not taint the cast result, unlike with equivalently sized integer types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> @f(<span style=color:#960050;background-color:#1e0010>ptr</span> %ptr) {
</span></span><span style=display:flex><span>  %v = <span style=color:#66d9ef>load</span> &lt;<span style=color:#ae81ff>2</span> <span style=color:#66d9ef>x</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span>&gt;, <span style=color:#960050;background-color:#1e0010>ptr</span> %ptr
</span></span><span style=display:flex><span>  %c = <span style=color:#66d9ef>bitcast</span> &lt;<span style=color:#ae81ff>2</span> <span style=color:#66d9ef>x</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span>&gt; %v <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These two properties of the byte type directly addressed the aforementioned problems, enabling the implementation of a user-defined <code>memcpy</code> in the IR, as shown in the following example.
In a similar manner, a native implementation of <code>memmove</code> can be achieved.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @my_memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src, <span style=color:#66d9ef>i64</span> %n) {
</span></span><span style=display:flex><span>entry:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %for.cond
</span></span><span style=display:flex><span>for.cond:
</span></span><span style=display:flex><span>  %i = <span style=color:#66d9ef>phi</span> <span style=color:#66d9ef>i64</span> [ <span style=color:#ae81ff>0</span>, %entry ], [ %inc, %for.body ]
</span></span><span style=display:flex><span>  %cmp = <span style=color:#66d9ef>icmp</span> <span style=color:#66d9ef>ult</span> <span style=color:#66d9ef>i64</span> %i, %n
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %cmp, <span style=color:#66d9ef>label</span> %for.body, <span style=color:#66d9ef>label</span> %for.end
</span></span><span style=display:flex><span>for.body:
</span></span><span style=display:flex><span>  %arrayidx = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>inbounds</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %src, <span style=color:#66d9ef>i64</span> %i
</span></span><span style=display:flex><span>  %byte = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %arrayidx
</span></span><span style=display:flex><span>  %arrayidx1 = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>inbounds</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#66d9ef>i64</span> %i
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %byte, <span style=color:#960050;background-color:#1e0010>ptr</span> %arrayidx1
</span></span><span style=display:flex><span>  %inc = <span style=color:#66d9ef>add</span> <span style=color:#66d9ef>i64</span> %i, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %for.cond
</span></span><span style=display:flex><span>for.end:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %dst
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The newly implemented type also fixes existing optimizations.
Previously, InstCombine lowered small calls to <code>memcpy</code> and <code>memmove</code> into integer load/store pairs.
Due to the aforementioned reasons, this lowering is unsound.
By using byte load/store pairs instead, the transformation, as shown in the following example, is now valid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @my_memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @llvm.memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @my_memmove(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @llvm.memmove(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @my_memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %dst, <span style=color:#960050;background-color:#1e0010>ptr</span> %src) {
</span></span><span style=display:flex><span>  %l = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %src
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %l, <span style=color:#960050;background-color:#1e0010>ptr</span> %dst
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @my_memmove(<span style=color:#960050;background-color:#1e0010>ptr</span> %d, <span style=color:#960050;background-color:#1e0010>ptr</span> %s) {
</span></span><span style=display:flex><span>  %l = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %s
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %l, <span style=color:#960050;background-color:#1e0010>ptr</span> %d
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SROA performs a similar transformation, lowering <code>memcpy</code> calls to integer load/store pairs.
Similarly, this optimization pass was changed to use byte load/store pairs, as depicted in the following example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %a, <span style=color:#960050;background-color:#1e0010>ptr</span> %b) {
</span></span><span style=display:flex><span>  %mem = <span style=color:#66d9ef>alloca</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @llvm.memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %mem, <span style=color:#960050;background-color:#1e0010>ptr</span> %a, <span style=color:#66d9ef>i32</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @llvm.memcpy(<span style=color:#960050;background-color:#1e0010>ptr</span> %a, <span style=color:#960050;background-color:#1e0010>ptr</span> %mem, <span style=color:#66d9ef>i32</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>void</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %a, <span style=color:#960050;background-color:#1e0010>ptr</span> %b) {
</span></span><span style=display:flex><span>  %mem.copyload = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %mem.copyload, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=bytecast-instruction>Bytecast Instruction</h2><p>Byte values can be reinterpreted as values of other primitive types.
This is achieved through the <code>bytecast</code> instruction.
This cast instruction comes in two flavors, either allowing or disallowing type punning.
Considering that a byte might hold a pointer or a non-pointer value, the <code>bytecast</code> follows the following semantics:</p><ul><li><p>A vanilla <code>bytecast</code>, distinguished by the absence of the <code>exact</code> flag, is used to cast a byte to any other primitive type, allowing type punning. More precisely,</p><ul><li>If the type of the value held by the byte matches the destination type of the cast, it is a no-op.</li><li>Otherwise, the cast operand undergoes a conversion to the destination type, converting pointers to non-pointer values and vice-versa, respectively wrapping a <code>ptrtoint</code> or <code>inttoptr</code> cast.</li></ul></li><li><p>A <code>bytecast</code> with the <code>exact</code> flag succeeds if both the type of the value held by the byte and the destination type are either both pointer or non-pointer types. More specifically,</p><ul><li>If the type of the value held by the byte matches the destination type of the cast, it is a no-op.</li><li>Otherwise, the result is <code>poison</code>, preventing type punning between pointer and non-pointer values.</li></ul></li></ul><p>The <code>exact</code> version of the <code>bytecast</code> mimics the reinterpretation of a value, as if it had been stored in memory and loaded back through the cast destination type.
This is aligned with the semantics adopted by the <code>bitcast</code> instruction, which &ldquo;<em>is done as if the value had been stored to memory and read back as [the destination type]</em>&rdquo;", enabling store-to-load forwarding optimizations, such as the one depicted in the next example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @src(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %x) {
</span></span><span style=display:flex><span>  %a = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  %v = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %v
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @tgt(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %x) {
</span></span><span style=display:flex><span>  %cast = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %x <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %cast
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=memcmp-lowering>Memcmp Lowering</h2><p>The standard version of the <code>bytecast</code> enables the implementation of <code>memcmp</code> in the IR.
Currently, calls to <code>memcmp</code> of small sizes are lowered to integer loads, followed by a subtraction, comparing the two loaded values.
Due to the aforementioned problems, this lowering is unsound.
Loading the two memory values as bytes is insufficient as comparisons between bytes are undefined, as to avoid overloading the IR by supporting comparisons between pointers and provenance-unaware values.
To that end, the version of the <code>bytecast</code> which performs type punning is used, forcefully converting possible pointer values into their integer representation.
The two values, then converted to integers, can be compared as before.
The following example depicts the previous and new lowerings of a <code>memcmp</code> of 1 byte.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i32</span> @before(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#960050;background-color:#1e0010>ptr</span> %q) {
</span></span><span style=display:flex><span>  %lhsc = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  %lhsv = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i8</span> %lhsc <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %rhsc = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %q
</span></span><span style=display:flex><span>  %rhsv = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i8</span> %rhsc <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %chardiff = <span style=color:#66d9ef>sub</span> <span style=color:#66d9ef>i32</span> %lhsv, %rhsv
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i32</span> %chardiff
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i32</span> @after(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#960050;background-color:#1e0010>ptr</span> %q) {
</span></span><span style=display:flex><span>  %lhsb = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  %lhsc = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %lhsb <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %lhsv = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i8</span> %lhsc <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %rhsb = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %q
</span></span><span style=display:flex><span>  %rhsc = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %rhsb <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %rhsv = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i8</span> %rhsc <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %chardiff = <span style=color:#66d9ef>sub</span> <span style=color:#66d9ef>i32</span> %lhsv, %rhsv
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i32</span> %chardiff
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=load-widening>Load Widening</h2><p>A common optimization performed by LLVM is to widen memory loads when lowering calls to <code>memcmp</code>.
The previously proposed lowering falls short in the presence of such optimizations.
Whilst using a larger byte type to load the memory value preserves its raw value, the <code>bytecast</code> to an integer type yields <code>poison</code> if any of the loaded bits are <code>poison</code>.
This is problematic as the remaining bits added by the widened load could assume any value or even be uninitialized.
As such, when performing load widening, the following lowering, depicted in the next example, is performed.
The <code>!uninit_is_nondet</code>, proposed in <a href=https://discourse.llvm.org/t/rfc-load-instruction-uninitialized-memory-semantics/67481>the RFC proposing uninitialized memory loads to return <code>poison</code></a>, converts any <code>poison</code> bits to a non-deterministic value, preventing the <code>bytecast</code> to an integer type from yielding <code>poison</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i32</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %y) {
</span></span><span style=display:flex><span>  %call = <span style=color:#66d9ef>tail</span> <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>i32</span> @memcmp(
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>ptr</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %y, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i32</span> %call
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i32</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %y) {
</span></span><span style=display:flex><span>  %1 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>16</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %x, !uninit_is_nondet
</span></span><span style=display:flex><span>  %2 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>16</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %y, !uninit_is_nondet
</span></span><span style=display:flex><span>  %3 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>16</span> %1 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i16</span>
</span></span><span style=display:flex><span>  %4 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>16</span> %2 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i16</span>
</span></span><span style=display:flex><span>  %5 = <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>i16</span> @llvm.bswap.i16(<span style=color:#66d9ef>i16</span> %3)
</span></span><span style=display:flex><span>  %6 = <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>i16</span> @llvm.bswap.i16(<span style=color:#66d9ef>i16</span> %4)
</span></span><span style=display:flex><span>  %7 = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i16</span> %5 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %8 = <span style=color:#66d9ef>zext</span> <span style=color:#66d9ef>i16</span> %6 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %9 = <span style=color:#66d9ef>sub</span> <span style=color:#66d9ef>i32</span> %7, %8
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i32</span> %9
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=casts-bitwise-and-arithmetic-operations>Casts, Bitwise and Arithmetic Operations</h2><p>Values of other primitive types can be cast to the byte type using the <code>bitcast</code> instruction, as shown in the following example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span>%1 = <span style=color:#66d9ef>bitcast</span> <span style=color:#66d9ef>i8</span> %val <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>%2 = <span style=color:#66d9ef>bitcast</span> <span style=color:#66d9ef>i64</span> %val <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span>
</span></span><span style=display:flex><span>%3 = <span style=color:#66d9ef>bitcast</span> <span style=color:#960050;background-color:#1e0010>ptr</span> <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> <span style=color:#75715e>; assuming pointers to be 64 bits wide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>%4 = <span style=color:#66d9ef>bitcast</span> &lt;<span style=color:#ae81ff>8</span> <span style=color:#66d9ef>x</span> <span style=color:#66d9ef>i8</span>&gt; <span style=color:#66d9ef>to</span> &lt;<span style=color:#ae81ff>8</span> <span style=color:#66d9ef>x</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>&gt;
</span></span></code></pre></div><p>Furthermore, bytes can also be truncated, enabling store-to-load forwarding optimizations, such as the one presented in the next example.
Performing an exact <code>bytecast</code> to <code>i32</code>, followed by a <code>trunc</code> to <code>i8</code> and a <code>bitcast</code> to <code>b8</code> would be unsound, as if any of the unobserved bits of the byte value were <code>poison</code>, the <code>bytecast</code> would yield <code>poison</code>, invalidating the transformation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> @src(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x) {
</span></span><span style=display:flex><span>  %a = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  %v = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %v
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> @tgt(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x) {
</span></span><span style=display:flex><span>  %trunc = <span style=color:#66d9ef>trunc</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %trunc
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Due to the cumbersome semantics of performing arithmetic on provenance-aware values, arithmetic operations on the byte type are disallowed.
Bitwise binary operations are also disallowed, with the exception of logical shift right.
This instruction enables store-to-load forwarding optimization with offsets, such as the one performed in the following example.
To rule out sub-byte accesses, its use is restricted to shift amounts that are multiples of 8.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @src(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x) {
</span></span><span style=display:flex><span>  %a = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>  %gep = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %a, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x, <span style=color:#960050;background-color:#1e0010>ptr</span> %a
</span></span><span style=display:flex><span>  %v = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %gep
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %v
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @tgt(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x) {
</span></span><span style=display:flex><span>  %shift = <span style=color:#66d9ef>lshr</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %x, <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>  %trunc = <span style=color:#66d9ef>trunc</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %shift <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %cast = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %cast
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=value-coercion-optimizations>Value Coercion Optimizations</h2><p>Some optimization passes perform transformations that are unsound under the premise that type punning is disallowed.
Such an optimization pass is GVN, which performs value coercion in order to eliminate redundant loads.
Currently, a class of optimization where a pointer load is coerced to a non-pointer value or a non-pointer load is coerced to a pointer value <a href=https://github.com/llvm/llvm-project/issues/124461>is reported as unsound by Alive2</a>.</p><p>The following example illustrates one such optimization, in which GVN replaces the pointer load at <code>%v3</code> by a phi node, merging the pointer load at <code>%v2</code> with the coerced value at <code>%1</code>, resulting from an <code>inttoptr</code> cast.
If the value stored in memory is a pointer, the source function returns the pointer value, while, in the target function, the load at <code>%v1</code> returns <code>poison</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>void</span> @use(...) <span style=color:#66d9ef>readonly</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#66d9ef>i1</span> %cond) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %cond, <span style=color:#66d9ef>label</span> %bb1, <span style=color:#66d9ef>label</span> %bb2
</span></span><span style=display:flex><span>bb1:
</span></span><span style=display:flex><span>  %v1 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#66d9ef>i64</span> %v1)
</span></span><span style=display:flex><span>  %1 = <span style=color:#66d9ef>inttoptr</span> <span style=color:#66d9ef>i64</span> %v1 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>bb2:
</span></span><span style=display:flex><span>  %v2 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#960050;background-color:#1e0010>ptr</span> %v2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>merge:
</span></span><span style=display:flex><span>  %v3 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v3
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#66d9ef>i1</span> %cond) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %cond, <span style=color:#66d9ef>label</span> %bb1, <span style=color:#66d9ef>label</span> %bb2
</span></span><span style=display:flex><span>bb1:
</span></span><span style=display:flex><span>  %v1 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#66d9ef>i64</span> %v1)
</span></span><span style=display:flex><span>  %1 = <span style=color:#66d9ef>inttoptr</span> <span style=color:#66d9ef>i64</span> %v1 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>bb2:
</span></span><span style=display:flex><span>  %v2 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#960050;background-color:#1e0010>ptr</span> %v2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>merge:
</span></span><span style=display:flex><span>  %v3 = <span style=color:#66d9ef>phi</span> <span style=color:#960050;background-color:#1e0010>ptr</span> [ %v2, %bb2 ], [ %1, %bb1 ]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v3
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The byte type can be leveraged to avoid the implicit type punning that hinders this kind of optimizations, as depicted in the following example.
Since the byte type can represent both pointer and non-pointer values, the loads at <code>%v1</code> and <code>%v2</code> can instead be performed using the byte type.
The <code>bytecast</code> instruction is then used to convert the byte into the desired type.
As the load through the byte type accurately models the loaded value, avoiding implicit casts, the <code>bytecast</code>, yields the pointer stored in memory.
This value can then be used to replace the load at <code>%v3</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>void</span> @use(...) <span style=color:#66d9ef>readonly</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#66d9ef>i1</span> %cond) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %cond, <span style=color:#66d9ef>label</span> %bb1, <span style=color:#66d9ef>label</span> %bb2
</span></span><span style=display:flex><span>bb1:
</span></span><span style=display:flex><span>  %v1 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#66d9ef>i64</span> %v1)
</span></span><span style=display:flex><span>  %1 = <span style=color:#66d9ef>inttoptr</span> <span style=color:#66d9ef>i64</span> %v1 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>bb2:
</span></span><span style=display:flex><span>  %v2 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#960050;background-color:#1e0010>ptr</span> %v2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>merge:
</span></span><span style=display:flex><span>  %v3 = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v3
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %p, <span style=color:#66d9ef>i1</span> %cond) {
</span></span><span style=display:flex><span>  %load = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %cond, <span style=color:#66d9ef>label</span> %bb1, <span style=color:#66d9ef>label</span> %bb2
</span></span><span style=display:flex><span>bb1:
</span></span><span style=display:flex><span>  %v1 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %load <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#66d9ef>i64</span> %v1)
</span></span><span style=display:flex><span>  %1 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %load <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>bb2:
</span></span><span style=display:flex><span>  %v2 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>64</span> %load <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @use(<span style=color:#960050;background-color:#1e0010>ptr</span> %v2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %merge
</span></span><span style=display:flex><span>merge:
</span></span><span style=display:flex><span>  %v3 = <span style=color:#66d9ef>phi</span> <span style=color:#960050;background-color:#1e0010>ptr</span> [ %v2, %bb2 ], [ %1, %bb1 ]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %v3
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=other-optimizations>Other Optimizations</h2><p>Additional optimizations were also implemented.
While these do not affect program correctness, they do contribute to performance improvements.
Some of them include cast pair eliminations and combining of load and <code>bytecast</code> pairs with a single use, depicted in the following examples.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> @src_float(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %b) {
</span></span><span style=display:flex><span>  %1 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %b <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>float</span>
</span></span><span style=display:flex><span>  %2 = <span style=color:#66d9ef>bitcast</span> <span style=color:#66d9ef>float</span> %1 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %2
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @src_int(<span style=color:#66d9ef>i8</span> %i) {
</span></span><span style=display:flex><span>  %b = <span style=color:#66d9ef>bitcast</span> <span style=color:#66d9ef>i8</span> %i <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %c = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %1 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %c
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> @tgt_float(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %b) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>32</span> %b
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @tgt_int(<span style=color:#66d9ef>i8</span> %i) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %i
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @src(<span style=color:#960050;background-color:#1e0010>ptr</span> %p) {
</span></span><span style=display:flex><span>  %b = <span style=color:#66d9ef>load</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  %c = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %b <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %c
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#66d9ef>i8</span> @tgt(<span style=color:#960050;background-color:#1e0010>ptr</span> %p) {
</span></span><span style=display:flex><span>  %i = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#66d9ef>i8</span> %i
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=clang>Clang</h2><p>Given the raw memory access capabilities of the byte type, Clang was altered to lower C and C++&rsquo;s raw memory access types were lowered to the byte type.
These include <code>char</code>, <code>signed char</code>, <code>unsigned char</code> and <code>std::byte</code>.
The new lowerings are depicted in the next example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> arg1,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> arg2,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>char</span> arg3,
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>byte arg4
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>void</span> @foo(
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>zeroext</span> %arg1,
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>signext</span> %arg2,
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>signext</span> %arg3,
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>zeroext</span> %arg4
</span></span><span style=display:flex><span>)<span style=color:#75715e>;
</span></span></span></code></pre></div><p>Additionally, code generation was updated to insert missing <code>bytecast</code> instructions where integer values were previously expected, such as in arithmetic and comparison operations involving character types.
The next example depicts an example function in C, adding two <code>char</code> values, and the corresponding lowering to LLVM IR as performed by Clang.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>char</span> a, <span style=color:#66d9ef>char</span> b) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#66d9ef>define</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> @sum(<span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %a, <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %b) {
</span></span><span style=display:flex><span>  %conv = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %a <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %conv1 = <span style=color:#66d9ef>sext</span> <span style=color:#66d9ef>i8</span> %conv <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %conv2 = <span style=color:#960050;background-color:#1e0010>bytecast</span> <span style=color:#66d9ef>exact</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %b <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %conv3 = <span style=color:#66d9ef>sext</span> <span style=color:#66d9ef>i8</span> %conv2 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>  %add = <span style=color:#66d9ef>add</span> <span style=color:#66d9ef>nsw</span> <span style=color:#66d9ef>i32</span> %conv1, %conv3
</span></span><span style=display:flex><span>  %conv4 = <span style=color:#66d9ef>trunc</span> <span style=color:#66d9ef>i32</span> %add <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %res = <span style=color:#66d9ef>bitcast</span> <span style=color:#66d9ef>i8</span> %conv4 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ret</span> <span style=color:#960050;background-color:#1e0010>b</span><span style=color:#ae81ff>8</span> %res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=summary>Summary</h2><p>In summary, the byte type contributes with the following changes/additions to the IR:</p><ul><li><p><strong>Raw memory representation:</strong> Optimization passes can use the byte type to represent raw memory values, avoiding the introduction of implicit casts and treating both pointer and non-pointer values uniformly.</p></li><li><p><strong>Bit-level <code>poison</code> representation:</strong> The byte type provides the necessary granularity to represent individual <code>poison</code> bits, providing greater flexibility than integer types, which either have a fully-defined value or are tainted by <code>poison</code> bits.</p></li><li><p><strong><code>bitcast</code> instruction:</strong> This instruction allows conversions from other primitive types to equivalently-sized byte types. Casts between vector and scalar byte types do not taint the cast result in the presence of <code>poison</code> lanes, as occurs with integer types.</p></li><li><p><strong><code>bytecast</code> instruction:</strong> This instruction enables the conversion of byte values to other primitive types. The standard version of the cast performs type punning, reinterpreting pointers as integers and vice-versa. The <code>exact</code> flag disallows type punning by returning <code>poison</code> if the type of the value held by the byte does not match the cast destination type.</p></li><li><p><strong><code>trunc</code> and <code>lshr</code> instructions:</strong> The <code>trunc</code> and <code>lshr</code> instructions accept byte operands, behaving similarly to their integer counterparts. The latter only accepts shift amounts that are multiples of 8, ruling out sub-byte accesses.</p></li></ul><h1 id=results>Results</h1><h2 id=benchmarks>Benchmarks</h2><p>The implementation was evaluated using the Phoronix Test Suite automated benchmarking tool, from which a set of 20 C/C++ applications, listed below, were selected.</p><table><thead><tr><th><strong>Benchmark</strong></th><th><strong>Version</strong></th><th><strong>LoC</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>aircrack-ng</td><td>1.7</td><td>66,988</td><td>Tool suite to test WiFi/WLAN network security</td></tr><tr><td>botan</td><td>2.17.3</td><td>147,832</td><td>C++ library for cryptographic operations</td></tr><tr><td>compress-7zip</td><td>24.05</td><td>247,211</td><td>File archiving tool based on the 7-Zip format</td></tr><tr><td>compress-pbzip2</td><td>1.1.13</td><td>10,187</td><td>Parallel implementation of bzip2</td></tr><tr><td>compress-zstd</td><td>1.5.4</td><td>90,489</td><td>Lossless compression tool using Zstandard</td></tr><tr><td>draco</td><td>1.5.6</td><td>50,007</td><td>3D mesh and point cloud compressing library</td></tr><tr><td>espeak</td><td>1.51</td><td>45,192</td><td>Compact open-source speech synthesizer</td></tr><tr><td>ffmpeg</td><td>7.0</td><td>1,291,957</td><td>Audio and video processing framework</td></tr><tr><td>fftw</td><td>3.3.10</td><td>264,128</td><td>Library for computing FFTs</td></tr><tr><td>graphics-magick</td><td>1.3.43</td><td>267,450</td><td>Toolkit for image editing and conversion</td></tr><tr><td>luajit</td><td>2.1-git</td><td>68,833</td><td>JIT-compiler of the Lua programming language</td></tr><tr><td>ngspice</td><td>34</td><td>527,637</td><td>Open-source circuit simulator</td></tr><tr><td>openssl</td><td>3.3</td><td>597,713</td><td>Implementation of SSL/TLS</td></tr><tr><td>redis</td><td>7.0.4</td><td>178,014</td><td>In-memory data store</td></tr><tr><td>rnnoise</td><td>0.2</td><td>146,693</td><td>Neural network for audio noise reduction</td></tr><tr><td>scimark2</td><td>2.0</td><td>800</td><td>Scientific computing suite written in ANSI C</td></tr><tr><td>sqlite-speedtest</td><td>3.30</td><td>250,607</td><td>Program for executing SQLite database tests</td></tr><tr><td>stockfish</td><td>17</td><td>11,054</td><td>Advanced open-source chess engine</td></tr><tr><td>tjbench</td><td>2.1.0</td><td>57,438</td><td>JPEG encoding and decoding tool</td></tr><tr><td>z3</td><td>4.14.1</td><td>512,002</td><td>SMT solver and theorem prover</td></tr></tbody></table><p>All programs were compiled with the <code>-O3</code> pipeline on an AMD EPYC 9554P 64-Core CPU.
In order to minimize result variance, turbo boost, hyperthreading, and ASLR were disabled, the performance governor was used, and core pinning was applied.
The plots, depicted below, display the compile time, object size, peak memory usage (maximum redisent set size) and run-time performance differences between the implementation and upstream LLVM.
The results reveal that the addition of the byte type had a minimal impact on all of the addressed performance metrics.
Each result is averaged over three runs. The run-time results represent the average regression percentage across all tests of each benchmark.</p><div style="margin:0 auto"><img src=https://blog.llvm.org/img/byte-type-plots.svg><br></div><p>The following plots show per-function assembly size distributions and differences, indicating that the addition of the <code>byte</code> type results in minor changes to the generated code, with the largest observed shift being approximately 5%.
Each subplot includes the net byte size change and the percentage of functions with differing assembly, disregarding non-semantic differences such as varying jump and call target addresses.</p><div style="margin:0 auto"><img src=https://blog.llvm.org/img/byte-type-asm-size.svg><br><img src=https://blog.llvm.org/img/byte-type-asm-diff.svg><br></div><h2 id=alive2>Alive2</h2><h3 id=llvm-test-suite>LLVM Test Suite</h3><p>The byte type was implemented in Alive2, enabling the verification of both the reworked and newly added optimizations.
Accessing both the correctness of the implementation and the broader impact of introducing the byte type into the IR, Alive2 was run over the LLVM test suite.
Several previously unsound optimizations, which were addressed by the byte type, were identified in the tests listed below.</p><table><thead><tr><th><strong>Test</strong></th><th><strong>Reason</strong></th></tr></thead><tbody><tr><td>ExpandMemCmp/AArch64/memcmp.ll</td><td><code>memcmp</code> to integer load/store pairs</td></tr><tr><td>ExpandMemCmp/X86/bcmp.ll</td><td><code>bcmp</code> to integer load/store pairs</td></tr><tr><td>ExpandMemCmp/X86/memcmp-x32.ll</td><td><code>memcmp</code> to integer load/store pairs</td></tr><tr><td>ExpandMemCmp/X86/memcmp.ll</td><td><code>memcmp</code> to integer load/store pairs</td></tr><tr><td>GVN/metadata.ll</td><td>Unsound pointer coercions</td></tr><tr><td>GVN/pr24397.ll</td><td>Unsound pointer coercions</td></tr><tr><td>InstCombine/bcmp-1.ll</td><td><code>bcmp</code> to integer load/store pairs</td></tr><tr><td>InstCombine/memcmp-1.ll</td><td><code>memcmp</code> to integer load/store pairs</td></tr><tr><td>InstCombine/memcpy-to-load.ll</td><td><code>memcpy</code> to integer load/store pairs</td></tr><tr><td>PhaseOrdering/swap-promotion.ll</td><td><code>memcpy</code> to integer load/store pairs</td></tr><tr><td>SROA/alignment.ll</td><td><code>memcpy</code> to integer load/store pairs</td></tr></tbody></table><p>It is worth noting that some additional tests containing unsound optimizations were addressed.
However, Alive2 did not report them as unsound, due to the presence of unsupported features, such as multiple address spaces.
Moreover, the <code>ExpandMemCmp</code> tests continue to be flagged as unsound by Alive2.
This is because the required <code>!uninit_is_nondet</code> metadata has not yet been upstreamed and therefore remains absent in <code>memcmp</code> load widenings optimizations.</p><h3 id=single-file-programs>Single File Programs</h3><p>The <code>alivecc</code> tool was used to verify the compilation of two single-file C programs, both compiled with the <code>-O2</code> optimization level.
The results are presented below.</p><ul><li><a href=https://people.csail.mit.edu/smcc/projects/single-file-programs/bzip2.c><code>bzip2</code></a>: No differences were detected during verification.</li><li><a href=https://raw.githubusercontent.com/azadkuh/sqlite-amalgamation/refs/heads/master/sqlite3.c><code>sqlite3</code></a>: Two optimizations previously flagged as unsound by Alive2 were fixed. These occurred in the <code>sqlite3WhereOkOnePass</code> and <code>dup8bytes</code> functions. The reduced IR reveals that these were caused by lowerings of <code>memcpy</code> to integer load/store pairs.</li></ul><h1 id=future-work>Future Work</h1><p>After modifying Clang to lower the <code>char</code>, <code>unsigned char</code> and <code>signed char</code> types to the byte type, approximately 1800 Clang regression tests began failing.
Over the course of the project, the number of failing tests was gradually reduced and, currently, around 100 regression tests are still failing.
LLVM is a fast-moving codebase, and due to the sheer number of Clang tests affected by the introduction of the byte type, maintaining a clean test suite constitutes a continuous effort.</p><p>The benchmarks were run on an x86-64 system.
However, LLVM also supports other popular architectures such as AArch64 and RISC-V, which may require additional performance evaluation.</p><p>Furthermore, the patches do not include any additions to the Language Reference.</p><h1 id=conclusion>Conclusion</h1><p>The addition of the byte type to the IR solves one of the long lasting problems in LLVM, with a minimal performance impact.
Optimization passes can now safely represent and manipulate raw memory values, fixing existing optimizations, and setting up a solid foundation for new, previously inexpressible optimizations.</p><p>Participating in GSoC was both a great honor and a tremendous learning opportunity.
Over the course of this project, I&rsquo;ve learned a lot about compilers, optimizations and LLVM.
It was also a valuable opportunity to get in touch with the LLVM community and contribute through the following pull requests:</p><ul><li><a href=https://github.com/llvm/llvm-project/pull/153842>[InstCombine] Fold <code>(x == A) || (x & -Pow2) == A + 1</code> into range check</a></li><li><a href=https://github.com/llvm/llvm-project/pull/153399>[ADT] Add signed and unsigned mulExtended to APInt</a></li><li><a href=https://github.com/llvm/llvm-project/pull/153293>[Headers][X86] Allow pmuludq/pmuldq to be used in constexpr</a></li><li><a href=https://github.com/llvm/llvm-project/pull/152927>[LangRef] Fix <code>ptrtoaddr</code> code block</a></li><li><a href=https://github.com/llvm/llvm-project/pull/152478>[clang][x86] Add C/C++ and 32/64-bit test coverage to constexpr tests</a></li><li><a href=https://github.com/llvm/llvm-project/pull/152363>[Headers][X86] Allow AVX512 reduction intrinsics to be used in constexpr</a></li><li><a href=https://github.com/llvm/llvm-project/pull/151924>[InstCombine] Support offsets in <code>memset</code> to load forwarding</a></li><li><a href=https://github.com/llvm/llvm-project/pull/150546>[ConstantFolding] Merge constant gep <code>inrange</code> attributes</a></li><li><a href=https://github.com/llvm/llvm-project/pull/150460>[InstCombine] Propagate neg <code>nsw</code> when folding <code>abs(-x)</code> to <code>abs(x)</code></a></li><li><a href=https://github.com/llvm/llvm-project/pull/146856>[LV] Peek through bitcasts when performing CSE</a></li></ul><p>I would like to thank my mentor, Nuno Lopes, for his guidance and support.
Not only did his experience and expertise help me get through some of the most challenging parts of the project, but his presence also made the whole process genuinely enjoyable.
I also believe few people in the world could guide me so well through the Alive2 codebase!</p><p>I would also like to thank George Mitenkov, who laid the groundwork by developing the <a href=https://github.com/georgemitenkov/llvm-project/commits/gsoc2021-dev>original prototype introducing the byte type</a>.
Not only did he accomplish quite a lot in a single summer, but he also wrote a <a href=https://gist.github.com/georgemitenkov/3def898b8845c2cc161bd216cbbdb81f>phenomenal write-up</a>, which greatly contributed to my understanding of the problem.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><em>Values stored in non-bit-field objects of any other object type consist of n x <code>CHAR_BIT</code> bits, where <code>n</code> is the size of an object of that type, in bytes. The value may be copied into an object of type <code>unsigned char [n]</code> (e.g., by <code>memcpy</code>); the resulting set of bytes is called the object representation of the value.</em> (C99 ISO Standard, 6.2.6.1.4)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><em>The underlying bytes making up the object can be copied into an array of <code>char</code>, <code>unsigned char</code>, or <code>std::byte</code>. If the content of that array is copied back into the object, the object shall subsequently hold its original value.</em> (C++20 ISO Standard, 6.9.2)&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/posts/2025-08-29-gsoc-profiling-and-testing-math-functions-on-gpus/><i class="fa fa-chevron-circle-left"></i> GSoC 2025: Profiling and Testing Math Functions on GPUs</a></li><li><a href=https://blog.llvm.org/posts/2025-gsoc-clang-doc/>GSoC 2025: Improving Core Clang-Doc Functionality <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>