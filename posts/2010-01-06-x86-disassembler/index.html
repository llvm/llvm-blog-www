<!doctype html><html lang=en><head><title>The LLVM Project Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Spyffe"><meta property="og:title" content="The x86 Disassembler"><meta property="og:description" content="Disassemblers make binary analysis work. With a reliable disassembler, you can solve high-level problems like tracing back through a program's call stack or analyzing sample-based profiles to low-level problems like figuring out how your compiler unrolled a tight floating-point loop or what advantages declaring a variable const actually had at the other end of the optimization chain."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.llvm.org/posts/2010-01-06-x86-disassembler/"><meta property="article:published_time" content="2010-01-06T13:34:00+00:00"><meta property="article:modified_time" content="2010-01-06T13:34:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The x86 Disassembler"><meta name=twitter:description content="Disassemblers make binary analysis work. With a reliable disassembler, you can solve high-level problems like tracing back through a program's call stack or analyzing sample-based profiles to low-level problems like figuring out how your compiler unrolled a tight floating-point loop or what advantages declaring a variable const actually had at the other end of the optimization chain."><meta name=generator content="Hugo 0.68.3"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>The x86 Disassembler</h1><aside><ul><li><time class=post-date datetime=2010-01-06T13:34:00Z>Jan 6, 2010</time></li><li>Spyffe</li><li><em><a href=https://blog.llvm.org/tags/mc>#MC</a>
,
<a href=https://blog.llvm.org/tags/new-in-llvm-2.7>#new-in-llvm-2.7</a></em></li><li>6 minutes read</li></ul></aside>Disassemblers make binary analysis work. With a reliable disassembler, you can solve high-level problems like tracing back through a program's call stack or analyzing sample-based profiles to low-level problems like figuring out how your compiler unrolled a tight floating-point loop or what advantages declaring a variable const actually had at the other end of the optimization chain. A reliable disassembler, which takes sequences of bytes and prints human-readable instruction mnemonics, is a crucial part of any development platform. You're about to go on a whirlwind tour of the LLVM disassembler: why one should exist, what's great about this one, and how you can use it.<br><br><a name=more></a><br><h3>The case for an LLVM-based disassembler</h3>Disassemblers are all over the place. A disassembler you may well be familiar with is the disassembler from GNU gdb (<a href=http://opensource.apple.com/source/gdb/gdb-1346/src/include/dis-asm.h>source</a>). In fact, any debugger needs one: Sun mdb has a disassembler too (<a href=http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/mdb/common/mdb/mdb_disasm.h>source</a>). Some specialized applications like Dtrace need disassemblers as well (<a href=http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/intel/dtrace/fasttrap_isa.c>source</a>). So because this is well-traveled ground, there are several common properties you should expect from a disassembler:<br><br><ul><li>A large library can contain hundreds of thousands of instructions, so disassembly must be <em>fast</em>.<br></li><li>A disassembler with a large memory footprint can steal memory and cache from analysis algorithms that need them more, so its code and data should be <em>compact</em>.<br></li><li>Because disassemblers are used in a variety of applications, they should provide information about instructions in a <em>generic</em>, preferably even architecture-independent form.<br></li><li>For the benefit of future code maintainers, disassemblers should be as <em>table-driven</em> as possible.</li></ul>Enter the LLVM MC architecture. In MC, instructions are represented using the architecture-independent <code>MCInst</code> class (<code>include/llvm/MC/MCInst.h</code>). The translation between MC instructions and machine code is specified by pre-existing <a href=http://llvm.org/docs/TableGenFundamentals.html>TableGen</a> tables (<code>lib/Target/X86/X86.td</code> for x86 platforms). Writing a disassembler inside the MC framework makes sense because it solves the generality and table-driven problems naturally, but we still need to solve two problems: speed and compactness.<br><h3><span class=Apple-style-span style=font-size:medium;font-weight:400><h3>Quick Testdrive of the Disassembler</h3></span></h3><br>The llvm-mc tool provides a simple command line wrapper around the disassembler that we primarily use for testing (e.g. <span style="font-family:courier new,Courier,monospace">test/MC/Disassembler/simple-tests.txt</span>). &nbsp;It reads a text file containing input bytes and prints out the instructions that correspond to those bytes. &nbsp;For example, here's a simple transcript of using it:<br><br><pre>$ echo '1 2' | llvm-mc -disassemble -triple=x86_64-apple-darwin9<br>addl %eax, (%rdx)<br>$ echo '0x0f 0x1 0x9' | llvm-mc -disassemble -triple=x86_64-apple-darwin9<br>sidt (%rcx)<br>$ echo '0x0f 0xa2' | llvm-mc -disassemble -triple=x86_64-apple-darwin9<br>cpuid<br>$ echo '0xd9 0xff' | llvm-mc -disassemble -triple=i386-apple-darwin9<br>fcos<br></pre><br><div><span class=Apple-style-span style=font-size:19px;font-weight:700>Design of the decode process</span></div>Fast disassemblers can be classified into two categories, depending on the instruction format. On platforms with fixed-length instructions, it is possible to pull out all bits of the instruction at once and filter based on arbitrary ranges of those bits. In contrast, platforms with variable-length instructions require that the instruction be parsed byte by byte. In this article, I will discuss the variable-length case, and in particular the case of x86, which includes the <code>i386</code> and <code>x86_64</code> targets.<br>The structure of an x86 instruction is determined by several important factors, each of which is of vital importance when decoding:<br><ul><li>The <em>context</em> of the instruction determines the meaning of the instruction and the size of its operands. The context includes the address and operand sizes of the instruction, as well as the presence (and position!) of prefixes such as the <code>REX.w</code> prefix on <code>x86_64</code> targets and the <code>f3</code> prefix on architectures with SSE.<br></li><li>The <em>opcode</em> of the instruction is of varying size, and determines what operands are required. Opcodes come in four different types: one-byte opcodes of the form <code>xx</code>, two-byte opcodes of the form <code>0f</code> <code>xx</code>, three-byte opcodes of the form <code>0f</code> <code>38</code> <code>xx</code>, and three-byte opcodes of the form <code>0f</code><code>3a</code> <code>xx</code>.<br></li><li>The <em>addressing bytes</em> of the instruction determine the addressing mode of the instruction's memory operand (there is only one memory operand possible with a selectable mode). The addressing bytes include the ModR/M (Modifier - Register/Memory) byte and the SIB (Scale - Index - Base) byte.</li></ul><table border=1><tbody><tr><td><b class=phase2><span style=color:#399>Other prefixes?</span></b><br></td><td><b class=phase2><span style=color:#399>Mandatory prefix?</span></b><br></td><td><b class=phase2><span style=color:#399>REX prefix?</span></b><br></td><td><b class=phase1><code><span style=color:#939>0f</span></code><span style=color:#939> [</span><code><span style=color:#939>38</span></code><span style=color:#939>/</span><code><span style=color:#939>3a</span></code><span style=color:#939>]?</span></b><br></td><td><b class=phase3><span style=color:#090>Opcode</span></b><br></td><td><b class=phase4><span style=color:#33f>ModR/M byte?</span></b><br></td><td><b class=phase5><span style=color:#c93>SIB byte?</span></b><br></td></tr></tbody></table><div class=caption><em>Table 1:</em> Portions of an instruction relevant to decode<br></div>You can read more about the meaning of all of these bytes in Chapter 2 of the Intel instruction manual, volume 2A (<a href=http://www.intel.com/Assets/PDF/manual/253666.pdf>large PDF</a>). The x86 disassembler is structured around hierarchical tables that assume a 5-phase decode process. You can follow along with this discussion by looking at <code>lib/Target/X86/Disassembler/X86DisassemblerDecoderCommon.h</code>, and the steps below are colored consistently with the data they access in Table 1.<br><dl><dt><b class=phase1><span style=color:#939>Phase 1</span></b></dt><dd>Record all prefixes but do not use them. Determine the type of the opcode, and obtain a <code>ContextDecision</code> on that basis: <code><span style=color:#c93><b>ONEBYTE_SYM</b></span></code>, <code><span style=color:#c93><b>TWOBYTE_SYM</b></span></code>, <code><b><span style=color:#c93>THREEBYTE38_SYM</span></b></code>, and <code><b><span style=color:#c93>THREEBYTE3A_SYM</span></b></code>.</dd><dt><b class=phase2><span style=color:#399>Phase 2</span></b></dt><dd>Develop a context mask based on the prefixes that are present and the machine architecture being decoded for. Look up this mask in a lookup table (<code><b><span style=color:#c93>CONTEXTS_SYM</span></b></code>) to get a context ID. Consult the <code><span style=color:#399><b>ContextDecision</b></span></code> to find the <code><span style=color:#399><b>OpcodeDecision</b></span></code> that corresponds to the context. As the comments in the header point out, the many possible contexts are boiled down to <code><span style=color:#399><b>IC_max</b></span></code> distinct context IDs that actually matter when decoding. This saves a lot of space.</dd><dt><b class=phase3><span style=color:#090>Phase 3</span></b></dt><dd>Read the opcode and use it to consult the <code><span style=color:#399><b>OpcodeDecision</b></span></code> to find the right <code><span style=color:#399><b>ModRMDecision</b></span></code>.</dd><dt><b class=phase4><span style=color:#33f>Phase 4</span></b></dt><dd>The ModR/M byte not only specifies the addressing mode, but also sometimes serves to identify the specific instruction intended. For example, extended opcodes and escape opcodes (often seen in SSE) use the Reg/Opcode field in the ModR/M byte as part of the opcode. You can see these oddities in Chapters A.4 and A.5 of the Intel instruction manual, volume 2B (<a href=http://www.intel.com/Assets/PDF/manual/253666.pdf>large PDF</a>). Given the value of the ModR/M byte, look up the LLVM opcode for the decoded instruction in the <code><span style=color:#399><b>ModRMDecision</b></span></code>.</dd><dt><b class=phase5><span style=color:#c93>Phase 5</span></b></dt><dd>If the ModR/M byte indicates that an SIB byte is needed, read the SIB byte. This phase occurs as operands are read.</dd></dl>Once these five steps have been performed, the disassembler consumes the operands, whose forms are now completely specified.<br><h3>Using the disassemblers in real code</h3>If you want to use a disassembler in your own code, then <code>tools/llvm-mc/Disassembler.cpp</code> is a good example of how to use one. You can instantiate a disassembler given a Target using the following code:<br><pre><b class=namespace><span style=color:#60c>llvm</span></b>::<b class=identifier><span style=color:#399>OwningPtr</span></b>&lt;<b class=keyword><span style=color:#939>const</span></b> <b class=namespace><span style=color:#60c>llvm</span></b>::<b class=identifier><span style=color:#399>MCDisassembler</span><span style=font-weight:400>&gt;</span></b><br><b class=identifier><span style=color:#399>  disassembler</span></b>(<b class=identifier><span style=color:#399>target</span></b>.<b class=function><span style=color:#366>createMCDisassembler</span></b>());<br></pre>This disassembler works with <code><b><span style=color:#399>MemoryObject</span></b></code>s (<code>include/llvm/Support/MemoryObject.h</code>), and you will need to subclass <code><span style=color:#399><b>MemoryObject</b></span></code> to perform the proper reading functions. A very <span style=color:#303>simple </span><code><span style=color:#399><b>MemoryObject</b></span></code> subclass might look like this:<br><pre><b class=keyword><span style=color:#939>class</span></b> <b class=identifier><span style=color:#399>BufferMemoryObject</span></b> : <span style=color:#939><b>public</b></span> <b class=namespace><span style=color:#60c>llvm</span></b>::<b class=identifier><span style=color:#399>MemoryObject</span></b> {<br><b class=keyword><span style=color:#939>private</span></b>:<br><b class=keyword><span style=color:#939>  const</span></b> <b class=identifier><span style=color:#399>uint8_t</span></b> *<b class=identifier><span style=color:#399>Bytes</span></b>;<br><b class=identifier><span style=color:#399>  uint64_t</span></b> <b class=identifier><span style=color:#399>Length</span></b>;<br><b class=keyword><span style=color:#939>public</span></b>:<br><b class=function><span style=color:#399>  BufferMemoryObject</span></b>(<b class=keyword><span style=color:#939>const</span></b> <b class=identifier><span style=color:#399>uint8_t</span></b> *<b class=identifier><span style=color:#399>bytes</span></b>, <b class=identifier><span style=color:#399>uint64_t</span></b> <b class=identifier><span style=color:#399>length</span></b>) :<br><b class=identifier><span style=color:#399>Bytes</span></b>(<b class=identifier><span style=color:#399>bytes</span></b>), <b class=identifier><span style=color:#399>Length</span></b>(<b class=identifier><span style=color:#399>length</span></b>) {<br>}<br><br><b class=identifier><span style=color:#399>  uint64_t</span></b> <b class=function><span style=color:#366>getBase</span></b>() <b class=keyword><span style=color:#939>const</span></b> { <b class=keyword><span style=color:#939>return</span></b> <b class=literal><span style=color:#33f>0</span></b>; }<br><b class=identifier><span style=color:#399>  uint64_t</span></b> <b class=function><span style=color:#366>getExtent</span></b>() <b class=keyword><span style=color:#939>const</span></b> { <b class=keyword><span style=color:#939>return</span></b> <b class=identifier><span style=color:#399>Length</span></b>; }<br><br><b class=keyword><span style=color:#939>  int</span></b> <b class=function><span style=color:#366>readByte</span></b>(<b class=identifier><span style=color:#399>uint64_t</span></b> <b class=identifier><span style=color:#399>addr</span></b>, <b class=identifier><span style=color:#399>uint8_t</span></b> *<b class=identifier><span style=color:#399>byte</span></b>) <b class=keyword><span style=color:#939>const</span></b> {<br><b class=keyword><span style=color:#939>if</span></b> (<b class=identifier><span style=color:#399>addr</span></b> &gt; <b class=function><span style=color:#366>getExtent</span></b>())<br><b class=keyword><span style=color:#939>return</span></b> <b class=literal><span style=color:#33f>-1</span></b>;<br>*<b class=identifier><span style=color:#399>byte</span></b> = <b class=identifier><span style=color:#399>Bytes</span></b>[<b class=identifier><span style=color:#399>addr</span></b>];<br><b class=keyword><span style=color:#939>return</span></b> <b class=literal><span style=color:#33f>0</span></b>;<br>}<br>};<br></pre>Given a <code><span style=color:#399><b>BufferMemoryObject</b></span></code>, all you have to do to extract <code><span style=color:#399><b>MCInst</b></span></code> objects is to call the <code>getInstruction</code> method of the disassembler you got earlier:<br><pre><b class=namespace><span style=color:#60c>llvm</span></b>::<b class=identifier><span style=color:#399>MCInst</span></b> <b class=identifier><span style=color:#399>Inst</span></b>;<br><b class=identifier><span style=color:#399>uint64_t</span></b> <b class=identifier><span style=color:#399>Size</span></b>;<br><b class=identifier><span style=color:#399>disassembler</span></b>-&gt;<b class=function><span style=color:#366>getInstruction</span></b>(<b class=identifier><span style=color:#399>Inst</span></b>, <b class=identifier><span style=color:#399>Size</span></b>, <b class=identifier><span style=color:#399>BufferMObj</span></b>, <b class=literal><span style=color:#33f>0</span></b>, <b class=function><b class=namespace><span style=color:#60c>llvm</span></b>::<span style=color:#366>nulls</span></b>()));<br></pre>The last argument is an optional diagnostic stream, and the <code>0</code> indicates that the disassembler should start from address 0 in the buffer.<br><h2>Where to look for more documentation</h2>For general information on how the disassembler's decode tables are generated from <code>lib/Target/X86/X86.td</code>, visit <code>utils/TableGen/DisassemblerEmitter.cpp</code>, which provides an overview of the TableGen side of the code. If you're interested in the gory, bit-for-bit details of how the disassembler dissects the various instruction bytes, you can go straight to <code>lib/Target/X86/Disassembler/X86Disassembler.h</code>, which describes the decode process in more detail and gives a guide to the implementation files.</article><section class=post-nav><ul><li><a href=https://blog.llvm.org/posts/2010-01-03-address-of-label-and-indirect-branches/><i class="fa fa-chevron-circle-left"></i>Address of Label and Indirect Branches in LLVM IR</a></li><li><a href=https://blog.llvm.org/posts/2010-02-04-clang-successfully-self-hosts/>Clang Successfully Self-Hosts! <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>