<!doctype html><html lang=en><head><title>GSoC 2025: Introducing an ABI Lowering Library - The LLVM Project Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Narayan Sreekumar (vortex73)"><meta property="og:url" content="https://blog.llvm.org/posts/2025-08-25-abi-library/"><meta property="og:site_name" content="The LLVM Project Blog"><meta property="og:title" content="GSoC 2025: Introducing an ABI Lowering Library"><meta property="og:description" content="Introduction In this post I’m going to outline details about a new ABI lowering library I’ve been developing for LLVM as part of GSoC 2025! The aim was to extract the ABI logic from Clang and create a reusable library that any LLVM frontend can use for correct C interoperability."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-03T00:00:00+00:00"><meta property="article:tag" content="GSoC"><meta property="article:tag" content="Abi"><meta property="article:tag" content="CodeGen"><meta property="article:tag" content="Sysv"><meta name=twitter:card content="summary"><meta name=twitter:title content="GSoC 2025: Introducing an ABI Lowering Library"><meta name=twitter:description content="Introduction In this post I’m going to outline details about a new ABI lowering library I’ve been developing for LLVM as part of GSoC 2025! The aim was to extract the ABI logic from Clang and create a reusable library that any LLVM frontend can use for correct C interoperability."><meta name=generator content="Hugo 0.128.0"><link rel=stylesheet href=https://blog.llvm.org/css/normalize.min.css><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>GSoC 2025: Introducing an ABI Lowering Library</h1><aside><ul><li>By Narayan Sreekumar (vortex73)</li><li><time class=post-date datetime=2025-11-03T00:00:00Z>Nov 3, 2025</time></li><li><em><a href=https://blog.llvm.org/tags/gsoc>#GSoC</a>
,
<a href=https://blog.llvm.org/tags/abi>#abi</a>
,
<a href=https://blog.llvm.org/tags/codegen>#codegen</a>
,
<a href=https://blog.llvm.org/tags/sysv>#sysv</a></em></li><li>7 minute read</li></ul></aside><h1 id=introduction>Introduction</h1><p>In this post I&rsquo;m going to outline details about a new ABI lowering library I&rsquo;ve been developing for LLVM as part of GSoC 2025! The aim was to extract the ABI logic from Clang and create a reusable library that any LLVM frontend can use for correct C interoperability.</p><h1 id=the-problem-were-solving>The Problem We&rsquo;re Solving</h1><p>At the start of the program, I wrote about the <a href=https://vortex73.github.io/rendered/GSOC_BLOG1.html>fundamental gap in LLVM&rsquo;s target abstraction</a>. The promise is simple: frontends emit LLVM IR, and LLVM handles everything else. But this promise completely breaks down when it comes to Application Binary Interface (ABI) lowering. Every LLVM frontend that wants C interoperability has to reimplement thousands of lines of target-specific ABI logic.</p><p>Here&rsquo;s what that looks like in practice:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> { <span style=color:#66d9ef>float</span> x, y; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> <span style=color:#a6e22e>add_points</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> a, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> b);
</span></span></code></pre></div><p>Seems innocent enough, right? But generating correct LLVM IR for this requires knowing:</p><ul><li>Are the struct arguments passed in registers or memory?</li><li>If in registers, what register class is used?</li><li>Are multiple values packed into a single register?</li><li>Is the struct returned in registers or using a hidden return parameter?</li></ul><p>The answer depends on subtle ABI rules that are target-specific, constantly evolving, and absolutely critical to get right. Miss one detail and you get silent memory corruption.</p><p><a href=https://clang.godbolt.org/z/P4fMj7hjY>This godbolt link</a> shows the same simple struct using six different calling conventions across six different targets. And crucially: a frontend generating IR needs to know ALL of this before it can emit the right function signature.</p><p>As I outlined in my earlier blog post, LLVM&rsquo;s type system simply can&rsquo;t express all the information needed for correct ABI decisions. Two otherwise identical structs with different explicit alignment attributes have different ABIs. <code>__int128</code> and <code>_BitInt(128)</code> look similar but follow completely different rules.</p><h1 id=the-design>The Design</h1><div style="margin:0 auto"><img src=https://blog.llvm.org/img/abi_flow.png><br></div><h2 id=independent-abi-type-system>Independent ABI Type System</h2><p>At the heart of the library is <code>llvm::abi::Type</code>, a type system designed specifically for ABI decisions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Type</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  TypeKind Kind;
</span></span><span style=display:flex><span>  TypeSize SizeInBits;
</span></span><span style=display:flex><span>  Align ABIAlignment;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  TypeKind getKind() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> Kind; }
</span></span><span style=display:flex><span>  TypeSize <span style=color:#a6e22e>getSizeInBits</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> SizeInBits; }
</span></span><span style=display:flex><span>  Align <span style=color:#a6e22e>getAlignment</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> ABIAlignment; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isInteger</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> Kind <span style=color:#f92672>==</span> TypeKind<span style=color:#f92672>::</span>Integer; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isStruct</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> Kind <span style=color:#f92672>==</span> TypeKind<span style=color:#f92672>::</span>Struct; }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... other predicates that matter for ABI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>It contains <strong>more information than LLVM IR types</strong> (which for instance doesn&rsquo;t distinguish between <code>__int128</code> and <code>_BitInt(128)</code>, both just <code>i128</code>), but <strong>less information than frontend types</strong> like Clang&rsquo;s QualType (which carry parsing context, sugar, and other frontend-specific concerns that don&rsquo;t matter for calling conventions).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IntegerType</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Type {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> IsSigned;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> IsBitInt;        <span style=color:#75715e>// Crucially different from __int128!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  IntegerType(<span style=color:#66d9ef>uint64_t</span> BitWidth, Align Align, <span style=color:#66d9ef>bool</span> Signed,
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>bool</span> BitInt <span style=color:#f92672>=</span> false);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=frontend-to-abi-mapping>Frontend-to-ABI Mapping</h2><p>The <code>QualTypeMapper</code> class handles the job of converting Clang frontend types to ABI types.</p><p><strong>The ABI library is primarily intended to handle the C ABI.</strong> The C type system is relatively simple, and as such the type mapping from frontend types to ABI types is straightforward : integers map to <code>IntegerType</code>, pointers map to <code>PointerType</code>, and structs map to <code>StructType</code> with their fields and offsets preserved.</p><p>However, Clang also needs support for the C++ ABI, and the type mapping for this case is significantly more complicated. C++ object layout involves vtables, base class subobjects, virtual inheritance, and all sorts of edge cases that need to be preserved for correct ABI decisions. Here&rsquo;s an excerpt showing how <code>QualTypeMapper</code> tackles C++ inheritance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>StructType <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>QualTypeMapper<span style=color:#f92672>::</span>convertCXXRecordType(<span style=color:#66d9ef>const</span> CXXRecordDecl <span style=color:#f92672>*</span>RD,
</span></span><span style=display:flex><span>                                     <span style=color:#66d9ef>bool</span> canPassInRegs) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ASTRecordLayout <span style=color:#f92672>&amp;</span>Layout <span style=color:#f92672>=</span> ASTCtx.getASTRecordLayout(RD);
</span></span><span style=display:flex><span>  SmallVector<span style=color:#f92672>&lt;</span>llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>FieldInfo, <span style=color:#ae81ff>16</span><span style=color:#f92672>&gt;</span> Fields;
</span></span><span style=display:flex><span>  SmallVector<span style=color:#f92672>&lt;</span>llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>FieldInfo, <span style=color:#ae81ff>8</span><span style=color:#f92672>&gt;</span> BaseClasses;
</span></span><span style=display:flex><span>  SmallVector<span style=color:#f92672>&lt;</span>llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>FieldInfo, <span style=color:#ae81ff>8</span><span style=color:#f92672>&gt;</span> VirtualBaseClasses;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Handle vtable pointer for polymorphic classes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (RD<span style=color:#f92672>-&gt;</span>isPolymorphic()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>Type <span style=color:#f92672>*</span>VtablePointer <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        createPointerTypeForPointee(ASTCtx.VoidPtrTy);
</span></span><span style=display:flex><span>    Fields.emplace_back(VtablePointer, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Process base classes with proper offset calculation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>Base : RD<span style=color:#f92672>-&gt;</span>bases()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>Type <span style=color:#f92672>*</span>BaseType <span style=color:#f92672>=</span> convertType(Base.getType());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> BaseOffset <span style=color:#f92672>=</span> Layout.getBaseClassOffset(
</span></span><span style=display:flex><span>        Base.getType()<span style=color:#f92672>-&gt;</span>castAs<span style=color:#f92672>&lt;</span>RecordType<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>-&gt;</span>getAsCXXRecordDecl()
</span></span><span style=display:flex><span>    ).getQuantity() <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Base.isVirtual())
</span></span><span style=display:flex><span>      VirtualBaseClasses.emplace_back(BaseType, BaseOffset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      BaseClasses.emplace_back(BaseType, BaseOffset);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... field processing and final struct creation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Other frontends that only need C interoperability will have a much simpler mapping task.</p><h2 id=target-specific-classification>Target-Specific Classification</h2><p>Each target implements the ABIInfo interface. I&rsquo;ll show the BPF implementation here since it&rsquo;s one of the simplest ABIs in LLVM, the classification logic fits in about 50 lines of code with straightforward rules: small aggregates go in registers, larger ones are passed indirectly.</p><p>Its worth noting that most real-world ABIs are not <em>this</em> simple - for instance targets like X86-64 are significantly more complex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BPFABIInfo</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ABIInfo {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  TypeBuilder <span style=color:#f92672>&amp;</span>TB;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  BPFABIInfo(TypeBuilder <span style=color:#f92672>&amp;</span>TypeBuilder) <span style=color:#f92672>:</span> TB(TypeBuilder) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ABIArgInfo <span style=color:#a6e22e>classifyArgumentType</span>(<span style=color:#66d9ef>const</span> Type <span style=color:#f92672>*</span>ArgTy) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isAggregateTypeForABI(ArgTy)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>auto</span> SizeInBits <span style=color:#f92672>=</span> ArgTy<span style=color:#f92672>-&gt;</span>getSizeInBits().getFixedValue();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (SizeInBits <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getIgnore();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (SizeInBits <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>128</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> Type <span style=color:#f92672>*</span>CoerceTy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (SizeInBits <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>64</span>) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>auto</span> AlignedBits <span style=color:#f92672>=</span> alignTo(SizeInBits, <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>          CoerceTy <span style=color:#f92672>=</span> TB.getIntegerType(AlignedBits, Align(<span style=color:#ae81ff>8</span>), false);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>const</span> Type <span style=color:#f92672>*</span>RegTy <span style=color:#f92672>=</span> TB.getIntegerType(<span style=color:#ae81ff>64</span>, Align(<span style=color:#ae81ff>8</span>), false);
</span></span><span style=display:flex><span>          CoerceTy <span style=color:#f92672>=</span> TB.getArrayType(RegTy, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getDirect(CoerceTy);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getIndirect(ArgTy<span style=color:#f92672>-&gt;</span>getAlignment().value());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>*</span>IntTy <span style=color:#f92672>=</span> dyn_cast<span style=color:#f92672>&lt;</span>IntegerType<span style=color:#f92672>&gt;</span>(ArgTy)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>auto</span> BitWidth <span style=color:#f92672>=</span> IntTy<span style=color:#f92672>-&gt;</span>getSizeInBits().getFixedValue();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (IntTy<span style=color:#f92672>-&gt;</span>isBitInt() <span style=color:#f92672>&amp;&amp;</span> BitWidth <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>128</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getIndirect(ArgTy<span style=color:#f92672>-&gt;</span>getAlignment().value());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (isPromotableInteger(IntTy))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getExtend(ArgTy);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ABIArgInfo<span style=color:#f92672>::</span>getDirect();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The key difference is that the ABI classification logic itself is <strong>completely independent of Clang</strong>. Any LLVM frontend can use it by implementing a mapper from their types to <code>llvm::abi::Type</code>. The library then performs ABI classification and outputs <code>llvm::abi::ABIFunctionInfo</code> with all the lowering decisions.</p><p>For Clang specifically, the <code>ABITypeMapper</code> converts those <code>llvm::abi::Type</code> results back into <code>llvm::Type</code> and populates <code>clang::CGFunctionInfo</code>, which then continues through the normal IR generation pipeline.</p><h1 id=results>Results</h1><p>The library and the new type system are implemented and working in the <a href=https://github.com/llvm/llvm-project/pull/140112>PR #140112</a>, currently enabled for BPF and X86-64 Linux targets. You can find the implementation under <code>llvm/lib/ABI/</code> with Clang integration in <code>clang/lib/CodeGen/CGCall.cpp</code>. Here&rsquo;s what we&rsquo;ve achieved so far:</p><h2 id=clean-architecture>Clean Architecture</h2><p>The three-layer separation is working beautifully. Frontend concerns, ABI classification, and IR generation are now properly separated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Integration point in Clang
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (CGM.shouldUseLLVMABI()) {
</span></span><span style=display:flex><span>  SmallVector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>Type <span style=color:#f92672>*</span>, <span style=color:#ae81ff>8</span><span style=color:#f92672>&gt;</span> MappedArgTypes;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (CanQualType ArgType : argTypes)
</span></span><span style=display:flex><span>    MappedArgTypes.push_back(getMapper().convertType(ArgType));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  tempFI.reset(llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>ABIFunctionInfo<span style=color:#f92672>::</span>create(
</span></span><span style=display:flex><span>      CC, getMapper().convertType(resultType), MappedArgTypes));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  CGM.fetchABIInfo(getTypeBuilder()).computeInfo(<span style=color:#f92672>*</span>tempFI);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  CGM.getABIInfo().computeInfo(<span style=color:#f92672>*</span>FI);  <span style=color:#75715e>// Legacy path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=performance-considerations-addressed>Performance Considerations Addressed</h2><p>My earlier blog post worried about the overhead of &ldquo;an additional type system.&rdquo; The caching strategy handles this elegantly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>Type <span style=color:#f92672>*</span>QualTypeMapper<span style=color:#f92672>::</span>convertType(QualType QT) {
</span></span><span style=display:flex><span>  QT <span style=color:#f92672>=</span> QT.getCanonicalType().getUnqualifiedType();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> It <span style=color:#f92672>=</span> TypeCache.find(QT);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (It <span style=color:#f92672>!=</span> TypeCache.end())
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> It<span style=color:#f92672>-&gt;</span>second;  <span style=color:#75715e>// Cache hit - no recomputation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> llvm<span style=color:#f92672>::</span>abi<span style=color:#f92672>::</span>Type <span style=color:#f92672>*</span>Result <span style=color:#f92672>=</span> <span style=color:#75715e>/* conversion logic */</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Result)
</span></span><span style=display:flex><span>    TypeCache[QT] <span style=color:#f92672>=</span> Result;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Combined with <code>BumpPtrAllocator</code> for type storage, the performance impact is minimal in practice.</p><div style="margin:0 auto"><img src=https://blog.llvm.org/img/abi_library_benchmarks.png><br></div><p>The results are encouraging. Most compilation stages show essentially no performance difference (well within measurement noise). The 0.20% regression in the final Clang build times is expected - we&rsquo;ve added new code to the codebase. But the actual compilation performance impact is negligible.</p><h1 id=future-work>Future Work</h1><p>There&rsquo;s still plenty to explore:</p><h2 id=upstreaming-the-progress-so-far>Upstreaming the progress so far&mldr;</h2><p>The work is being upstreamed to LLVM in stages, starting with <a href=https://github.com/llvm/llvm-project/pull/158329>PR #158329</a>. This involves addressing reviewer feedback, ensuring compatibility with existing code, and validating that the new system produces identical results to the current implementation for all supported targets.</p><h2 id=extended-target-support>Extended Target Support</h2><p>Currently the ABI library supports the BPF and X86-64 SysV ABIs, but the architecture makes adding ARM, Windows calling conventions, and other targets straightforward.</p><h2 id=cross-frontend-compatibility>Cross-Frontend Compatibility</h2><p>The real test will be when other frontends start using the library. We need to ensure that all frontends generate identical calling conventions for the same C function signature.</p><h2 id=better-integration>Better Integration</h2><p>There are still some rough edges in the Clang integration that could be smoothed out. And other LLVM projects could benefit from adopting the library.</p><h1 id=acknowledgements>Acknowledgements</h1><p>This work wouldn&rsquo;t have been possible without my amazing mentors, Nikita Popov and Maksim Levental, who provided invaluable guidance throughout the project. The LLVM community&rsquo;s feedback on the <a href=https://discourse.llvm.org/t/rfc-an-abi-lowering-library-for-llvm/84495>original RFC</a> was instrumental in shaping the design.</p><p>Special thanks to everyone who reviewed the code, provided feedback, and helped navigate all the ABI corner cases. The architecture only works because it&rsquo;s built on decades of accumulated ABI knowledge that was already present in LLVM and Clang.</p><p>Looking back at my precursor blog post from earlier this year, I&rsquo;m amazed at how much the design evolved during implementation. What started as a relatively straightforward &ldquo;extract Clang&rsquo;s ABI code&rdquo; became a much more ambitious architectural rework. But the result is something that&rsquo;s genuinely useful for the entire LLVM ecosystem.</p></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/posts/2025-09-01-gsoc-ubsan-trap-messages/><i class="fa fa-chevron-circle-left"></i> GSoC 2025: Usability Improvements for the Undefined Behavior Sanitizer</a></li><li></li></ul></section></main><footer><ul><li><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>