<!doctype html><html lang=en><head><title>The LLVM Project Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Unknown"><meta property="og:title" content="Improving Link Time on Windows with clang-cl and lld"><meta property="og:description" content="One of our goals in bringing clang and lld to Windows has always been to improve developer experience, and what is it that developers want the most?&nbsp; Faster build times!"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.llvm.org/posts/2018-01-08-improving-link-time-on-windows-with/"><meta property="article:published_time" content="2018-01-08T10:06:00+00:00"><meta property="article:modified_time" content="2018-01-08T10:06:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Improving Link Time on Windows with clang-cl and lld"><meta name=twitter:description content="One of our goals in bringing clang and lld to Windows has always been to improve developer experience, and what is it that developers want the most?&nbsp; Faster build times!"><meta name=generator content="Hugo 0.68.3"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>Improving Link Time on Windows with clang-cl and lld</h1><aside><ul><li><time class=post-date datetime=2018-01-08T10:06:00Z>Jan 8, 2018</time></li><li>Unknown</li><li><em><a href=https://blog.llvm.org/tags/clang-cl>#clang-cl</a>
,
<a href=https://blog.llvm.org/tags/lld>#lld</a>
,
<a href=https://blog.llvm.org/tags/windows>#Windows</a></em></li><li>18 minutes read</li></ul></aside>One of our goals in bringing clang and lld to Windows has always been to improve developer experience, and what is it that developers want the most?&nbsp; Faster build times!&nbsp; Recently, our focus has been on improving link time because it's the step that's the hardest to parallelize so we can't fall back on the time honored tradition of throwing more cores at it.<br><br>Of the various steps involved in linking, generating the debug info (which, on Windows, is a PDB file) is by far the slowest since it involves merging O(# of linker inputs) sequences of type records, most of which are duplicate anyway.&nbsp; For example, if two cpp files both include <span style="font-family:courier new,courier,monospace">&lt;string></span><span style=font-family:inherit>, then both of those object files will have hundreds of duplicate type records that need to be de-duplicated during the link step.&nbsp; This means you have to compute O(M x N) hash values, even though only a small fraction of those ultimately contribute to the final PDB.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>Several strategies have been invented to deal with this over the years and try to make linking faster.&nbsp; Many years ago, Microsoft introduced the notion of a <i>Type Server</i>&nbsp;(enabled via&nbsp;<b>/Zi</b>&nbsp;compiler option in MSVC), which moves some of the work into the compiler (to take advantage of parallelism).&nbsp; More recently we have been given the <b>/DEBUG:FASTLINK</b>&nbsp;linker option which attempts to solve the problem by not merging types at all in the linker.&nbsp; However, each of these strategies has its own set of disadvantages, and neither can be considered perfect for all use cases.</span><br><span style=font-family:inherit><br></span><span style=font-family:inherit>In this blog post, we'll first go over some technical background about CodeView so that we can understand the problem, followed by a summary of existing attempts to speed up type merging.&nbsp; Then, we'll describe a novel extension to the PE/COFF file format which speeds up linking by offloading part of the work required to de-duplicate types to the compiler and using a new algorithm which uniquely identifies type records even across input files, and discuss the various tradeoffs of each approach.&nbsp; Finally, we'll present some benchmarks and discuss how you can try this out in clang-cl and lld today.</span><br><span style=font-family:inherit><br></span><br><h2><span style=font-family:inherit>Background</span></h2><div><span style=font-family:inherit>Consider a simple structure in C++, defined like this a header file:</span></div><div><span style=font-family:inherit><br></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp;<span style=color:blue>struct</span> <span style=color:#999>Node</span> {</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp;<span style=color:#999>Node</span> *Next = <span style=color:blue>nullptr</span>;</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp;<span style=color:#999>Node</span> *Prev = <span style=color:blue>nullptr</span>;</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp;<span style=color:blue>int</span> Value = 0;</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp;};</span></div><div><span style=font-family:inherit><br></span></div><div><span style=font-family:inherit>Since each compilation happens independently of every other compilation, the compiler cannot assume any other translation unit will ever emit the records necessary to describe this type.&nbsp; As a result, to guarantee that the type makes it into the final PDB, <i>every</i>&nbsp;compiler instance that encounters this definition must emit type information for this type.&nbsp; So the record will be serialized by the compiler into a series of records that looks roughly like this:</span></div><div><span style=font-family:inherit><br></span></div><div><span style="font-family:courier new,courier,monospace">0x1004 | LF_STRUCTURE [size = 40] `Node`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unique name: `.?AUNode@@`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vtable: &lt;none></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base list: &lt;none></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;field list: &lt;none></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;options: forward ref | has unique name</span></div><div><span style="font-family:courier new,courier,monospace">0x1005 | LF_POINTER [size = 12]</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;referent = 0x1004</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mode = pointer</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;opts = None</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kind = ptr32</span></div><div><span style="font-family:courier new,courier,monospace">0x1006 | LF_FIELDLIST [size = 52]</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- LF_MEMBER</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name = `Next`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type = 0x1005</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Offset = 0</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attrs = public</span></div><div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- LF_MEMBER</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name = `Prev`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type = 0x1005</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Offset = 4</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attrs = public</span></div></div><div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- LF_MEMBER</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name = `Value`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type = 0x0074 (int)</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Offset = 8</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attrs = public</span></div></div><div><span style="font-family:courier new,courier,monospace">0x1007 | LF_STRUCTURE [size = 40] `Node`</span></div><div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unique name: `.?AUNode@@`</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vtable: &lt;none></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base list: &lt;none></span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;field list: 0x1006</span></div><div><span style="font-family:courier new,courier,monospace">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;options: has unique name</span></div></div><div><span style=font-family:inherit>The values on the left correspond to the types <i>index</i>&nbsp;in the type sequence and depend on what types have already been encountered, while other types can the refer to them (for example,&nbsp;</span><span style="font-family:courier new,courier,monospace">referent = 0x1004</span><span style=font-family:inherit>) means that this record is a pointer to whatever the type at index 0x1004 was.</span></div><div><span style=font-family:inherit><br></span></div><div>As a result of this design, another compilation unit which includes the same header file will need to emit this exact same type, with the only difference being the indices (since the other compilation may encounter other types before this one, causing the ordering to be different).</div><div><br></div><div><div class=MsoNormal>In short, type indices only make sense within the context of a single type sequence (i.e. compiland), but since the linker needs to see across <i>all</i> object files, it has to have some way of identifying whether a type from object file A is isomorphic to a different type from object file B, even if its type indices might be different numerically from any previously seen type.&nbsp;</div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>This algorithm, henceforth referred to as <i>type merging</i>, is the primary consumer of CPU cycles during linking (measured in LLD, and estimated in MSVC linker by comparing /DEBUG:FULL vs /DEBUG:FASTLINK times), and as such it is the portion of the linking process which this blog post presents a new solution to.<o:p></o:p></span></div><div class=MsoNormal><br></div><h2>Existing Solutions</h2></div><div><div class=MsoNormal><span lang=en>It’s worthwhile to discuss some of the existing attempts to reduce the cost associated with type merging so that we can compare and contrast their various pros and cons.<o:p></o:p></span></div><div class=MsoNormal><span lang=en><br></span></div><h3><span lang=en>Type Servers (/Zi)</span></h3></div><div><span lang=en></span><br><div class=MsoNormal><span lang=en><span lang=en>The /Zi compiler option was one of the first attempts to address type merging speed, and it dates back many years.&nbsp; The idea behind type servers is to offload the work of de-duplication from the linking phase to the compilation phase.&nbsp; Most build systems already support parallel compilation, and even if they don’t </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>cl.exe</span><span lang=en> supports it natively via the /MP compiler switch, so there is no roadblock to anyone taking advantage of parallel compilation.&nbsp; <o:p></o:p></span></span></div><span lang=en></span><br><div class=MsoNormal><span lang=en><br></span></div><span lang=en></span><br><div class=MsoNormal><span lang=en><span lang=en>To implement type servers, each compilation process communicates via IPC with a single process (<span style="font-family:courier new,courier,monospace">mspdbsrv.exe</span>) whose job is to de-duplicate type records on the fly, and when a record is isomorphic to an existing record, the type server communicates back the previously saved index, and when it is new it sends back a new index.&nbsp; This allows type deduplication to happen <i>mostly</i>in parallel, but adding some overhead to each compilation (since there is contention over a global lock) in return for significantly reduced link times, since types will already have been merged.<o:p></o:p></span></span></div><span lang=en></span><br><div class=MsoNormal><span lang=en><br></span></div><span lang=en></span><div class=MsoNormal><span lang=en><span lang=en>Type servers bring with them some disadvantages though, so we enumerate them here:<o:p></o:p></span></span></div><span lang=en><ol start=1 style=margin-top:0 type=1><li class=MsoNormalCxSpMiddle><span lang=en>Type servers add significant context switching and global lock contention to the compilation phase, reducing parallelism and degrading overall system performance while a build is in process.&nbsp; While some performance is reclaimed from the linker, some is sacrificed due to the use of a global system lock.&nbsp; It’s still a net win, but as it is not free, it leaves open the possibility that we may be able to achieve better parallelism using a different approach.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>The type server process itself (</span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>mspdbsrv.exe</span><span lang=en>) introduces a single point of failure.&nbsp; When it crashes (we see C1033 several times per day on Chrome, for example, which seems to indicate an mspdbsrv.exe crash) it could trigger a full rebuild if the type server PDB file is left in a corrupt state.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>mspdbsrv</span><span lang=en> is incompatible with distributed builds, which is a show-stopper for large applications that can take several hours to build on normal workstations.&nbsp; Type servers operate only via local IPC.&nbsp; While multi-processing works well for small applications, many large products have build farms that distribute compilations among tens or hundreds of physical machines.&nbsp; Type servers are incompatible with this scenario</span><span lang=en>.<o:p></o:p></span></li></ol><div><h2><span lang=en>Fastlink PDBs<o:p></o:p></span></h2><div class=MsoNormal><span lang=en>Fastlink PDBs are a relatively recent introduction, and the approach used by this solution is to <i>eliminate type merging entirely.</i>&nbsp; To support this, special metadata is set in the PDB file to indicate to the tool that this is a fastlink PDB, and when the tool (e.g. debugger) encounters this metadata, it will fetch all type information from the original object file, rather than from the PDB.&nbsp; As before, there are several disadvantages to this approach, enumerated here:<o:p></o:p></span></div><ol start=1 style=margin-top:0 type=1><li class=MsoNormalCxSpMiddle><span lang=en>The </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>pdbcopy</span><span lang=en> utility is almost unusable with fastlink PDBs for performance reasons.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Since type merging doesn’t happen, indexing of type information also doesn’t happen (since the expensive part of building an index -- the hashing -- comes for free when you were hashing the record anyway).&nbsp; This leads to degradation in the debugger user experience, since waits which previously happened only at build time now happen at debug-time.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Fastlink PDBs are not portable.&nbsp; The PDB references the object files by path, so if you copy the PDB and object files to a different machine (or even different path on the same machine) for archival purposes, they can no longer be debugged.&nbsp; This is a deal-breaker for using it on production builds<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Symbols can’t be enumerated in a Fastlink PDB.&nbsp; This is most obvious if you attempt to use DIA SDK on a Fastlink PDB, where it will simply refuse to do anything at all.&nbsp; This means that the only externally supported way of querying debug info for users is impossible against a Fastlink PDB.&nbsp; Beyond that, however, it also means that even Microsoft’s own tools which need to enumerate symbols cannot use any standard API for doing so.&nbsp; For example, WinDbg doesn’t fully support Fastlink PDBs, and many workflows are broken by the use of them, even using supported Microsoft tools.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>It has several serious stability issues which make it unusable on large projects&nbsp; [<a href=https://developercommunity.visualstudio.com/content/problem/158451/chrome-with-1550-preview-50-and-fastlink-crashes-d.html><span style=color:#15c>ref</span></a>].&nbsp; This is probably related to point 4 above, namely the fact that every tool that wants to be able to work with a Fastlink PDB needs to use different code than the SDK that has been tested and battle-hardened through years of development.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>When compiling with clang-cl and linking with /debug:fastlink the compiler has to be instructed to <a href="https://cs.chromium.org/chromium/src/build/config/compiler/BUILD.gn?type=cs&q=build/config/compiler/BUILD.gn&sq=package:chromium&l=1886"><span style=color:#15c>emit additional debug information</span></a>, making .obj files about 29% larger.<o:p></o:p></span></li></ol><div><h2><span style=font-family:inherit><span lang=en>Clang's Solution - The COFF </span><span lang=en>.debug$H</span></span><span lang=en><span style=font-family:inherit> section</span><o:p></o:p></span></h2><div class=MsoNormal><span lang=en>This new approach tries to combine the ideas behind type servers and fastlink PDBs.&nbsp; Like type servers, it attempts to offload the work of de-duplication to the compilation phase so that it can be done in parallel.&nbsp; However, it does so using an algorithm with the property that the resulting hash can be used to identify a type record even across type streams.&nbsp; Specifically, <b>if two records have the same hash, they are the same record even if they are from different object files.</b>&nbsp; If you can take it on faith that such an algorithm exists (which will be henceforth referred to as a <i>global hash</i>), then the amount of work that the linker needs to perform is greatly reduced.&nbsp; And the work that it does still have to do can be done much quicker.&nbsp; Perhaps most importantly, <i>it produces a byte-for-byte identical PDB to when the option is not used</i>, meaning all of the issues surrounding Fastlink PDBs and compatibility are gone.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>Previously, the linker would do something that looks roughly like this:<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; HashTable&lt;Type> HashedTypes;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; vector&lt;Type> MergedTypes;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; for (ObjectFile &Obj : Objects) {<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; for (Type &T : Obj.types()) {<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; remapAllTypeIndices(MergedTypes, T);<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!HashedTypes.try_insert(T))<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MergedTypes.push_back(T);<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; }<o:p></o:p></span></div><div class=MsoNormal><span lang=en>The important observations here are:<o:p></o:p></span></div><ol start=1 style=margin-top:0 type=1><li class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>remapAllTypeIndices </span><span lang=en>is called unconditionally for every type in every object file.<o:p></o:p></span></li><li class=MsoNormal><span lang=en>A hash of the type is computed unconditionally for every type<o:p></o:p></span></li><li class=MsoNormal><i>At least one</i><span lang=en> full record comparison is done for every type.&nbsp; In practice it turns out to be much more, because hash buckets are computed modulo table size, so there will actually be 1 full record comparison for every probe.<o:p></o:p></span></li></ol><div class=MsoNormal><span lang=en>Given a global hash function as described above, the algorithm can be re-written like this:</span><span lang=en style=font-size:8pt;line-height:115%><o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap&lt;SHA1, int> HashToIndex;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vector&lt;Type> OrderedTypes;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (ObjectFile &Obj : Objects) {<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto Hashes = Obj.DebugHSectionHashes;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; for (int I=0; I &lt; Obj.NumTypes; ++I) {<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int NextIndex = OrderedTypes.size();<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!HashToIndex.try_emplace(Hashes[I], NextIndex))<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; remapAllTypeIndices(T);<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OrderedTypes.push_back(T);<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }<o:p></o:p></span></div><div class=MsoNormal><span lang=en style="font-family:courier new;line-height:115%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<span style=font-size:10pt><o:p></o:p></span></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>While this appears very similar, its performance characteristics are quite different.<o:p></o:p></span></div><ol start=1 style=margin-top:0 type=1><li class=MsoNormalCxSpMiddle><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>remapAllTypeIndices </span><span lang=en>is only called when the record is actually new.&nbsp; Which, as we discussed earlier, is a small fraction of the time over many linker inputs.</span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'><o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>A hash of the type is <b>never</b> computed by the linker.<b>&nbsp; </b>It is simply there in the object file (the exception to this is mixed linker inputs, discussed earlier, but those are a small fraction of input files).<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Full record comparisons <b>never</b> happen<i>.</i>&nbsp; Since we are using a strong hash function with negligible chance of false collisions, and since the hash of a record provides equality semantics across streams, the hash is as good as the record itself.<i><o:p></o:p></i></span></li></ol><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>Combining all of these points, we get an algorithm that is extremely cache friendly.&nbsp; Amortized over all input files, most records during type merging are cache hits (i.e. duplicate records).&nbsp; With this algorithm when we get a cache hit, the only two data structures that are accessed are:<o:p></o:p></span></div><ol start=1 style=margin-top:0 type=1><li class=MsoNormalCxSpMiddle><span lang=en>An array of contiguous hash values.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>An array of contiguous hash buckets.<o:p></o:p></span></li></ol><div class=MsoNormal><span lang=en>Since we never do full equality comparison (which would blow out the L1 and sometimes even L2 cache due to the average size of a type record being larger than a cache line) the algorithm here is very fast.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>We’ve deferred discussion of how to create such a hash up until now, but it is actually fairly straightforward.&nbsp; We use what is known as a “tree hash” or “Merkle tree”.&nbsp; The idea is to pass bytes from a type record directly to the hash function up until the point we get to a type index.&nbsp; Then, instead of passing the numeric value of the type index to the hash function, we pass the previously computed hash of the record that is being referenced.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>Such a hash is very fast to compute in the compiler because <i>the compiler must already hash types anyway</i>, so the incremental cost to emit this to the .debug$H section is negligible.&nbsp; For example, when a type is encountered in a translation unit, before you can add that type to the object file’s </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$T</span><span lang=en> section, it must first be verified that the type has not already been added.&nbsp; And since this is happening naturally in the order in which types are encountered, all that has to be done is to save these hash values in an array indexed by type index, and subsequent hash operations will have O(1) access to all of the information needed to compute this merkle hash.<o:p></o:p></span></div><div class=MsoSubtitle><a href=https://www.blogger.com/null name=_ma3qfmnbo3o6></a><span lang=en>&nbsp;</span>&nbsp;</div><h3><span lang=en>Mixed Input Files and Compiler/Linker Compatibility</span></h3><div class=MsoSubtitle><a href=https://www.blogger.com/null name=_rmj5k0mxyuuq></a></div><div class=MsoNormal><span lang=en>A linker must be prepared to deal with a mixed set of input files.&nbsp; For example, while a particular compiler may choose to always emit </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> sections, a linker must be prepared to link objects that for whatever reason do not have this section.&nbsp; To handle this, the linker can examine all inputs up front and manually compute hashes for inputs with missing </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en>sections.&nbsp; In practice this proves to be a small fraction and the penalty for doing this serially is negligible, although it should be noted that in theory this can also be done as a parallel pre-processing step if some use cases show that this has non-negligible cost.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>Similarly, the emission of this section in an object file has no impact on linkers which have not been taught to use it.&nbsp; Since it is a purely additive (and optional) inclusion into the object file, any linker which does not understand it will continue to work exactly as it does today.<o:p></o:p></span></div><div class=MsoNormal><span lang=en><br></span></div><h2><span lang=en>The On-Disk Format</span></h2><div class=MsoNormal><span lang=en>Clang uses the following on-disk format for the </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>0x0&nbsp;&nbsp;&nbsp;&nbsp; : &lt;Section Magic>&nbsp; (4 bytes)<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; 0x4&nbsp;&nbsp;&nbsp;&nbsp; : &lt;Version>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2 bytes)<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; 0x6&nbsp;&nbsp;&nbsp;&nbsp; : &lt;Hash Algorithm> (2 bytes)<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; 0x8&nbsp;&nbsp;&nbsp;&nbsp; : &lt;Hash Value>&nbsp;&nbsp;&nbsp;&nbsp; (N bytes)<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; 0x8 + N : &lt;Hash Value>&nbsp;&nbsp;&nbsp;&nbsp; (N bytes)<o:p></o:p></span></div><div class=MsoNormal><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … <o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>Here, “Section Magic” is an arbitrarily chosen 4-byte number whose purpose is to provide some level of certainty that what we’re seeing is a real </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section, and not some section that someone created that accidentally happened<span style=font-family:inherit> to be called that.&nbsp;&nbsp; Our current implementation uses the value 0x133C9C5, which represents the date of the initial prototype implementation.&nbsp; But this can be any reasonable value here, as long as it never changes.<o:p></o:p></span></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en><span style=font-family:inherit>“Version” is reserved for future use, so that the format of the section can theoretically change. <o:p></o:p></span></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en><span style=font-family:inherit><span lang=en style=line-height:115%>“Hash Algorithm” is a value that indicates what algorithm was used to generate the hashes that follow.&nbsp; As such, the value of N above is also a function of what hash algorithm is used.&nbsp; Currently, the only proposed value for Hash Algorithm is SHA1 = 0, which would imply N = 20 when Hash Algorithm = 0.&nbsp; Should it prove useful to have truncated 8-byte SHA1 hashes, we could define SHA1_8 = 1, for example.</span></span></span></div><div class=MsoNormal><span lang=en><span style=font-family:inherit><span lang=en style=font-size:11pt;line-height:115%><br></span></span></span></div><h2><span lang=en>Limitations and Pitfalls</span></h2><div class=MsoNormal><span lang=en>The biggest limitation of this format is that it increases object file size.&nbsp; Experiments locally on fairly large projects show an average aggregate object file size increase of ~15% compared to /DEBUG:FULL (which, for clang-cl, actually makes .debug$H object files <i>smaller</i>than those needed to support /DEBUG:FASTLINK).<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>There is another, less obvious potential pitfall as well.&nbsp; The worst case scenario is when no input files have a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section present, but this limitation is the same in principle even if only a subset of files have a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section.&nbsp; Since the linker must agree on a single hash function for all object files, there is the question of what to do when not all object files agree on hash function, or when not all object files contain a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H </span><span lang=en>section.&nbsp; If the code is not written carefully, you could get into a situation where, for example, no input files contain a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section so the linker decides to synthesize one on the fly for every input file.&nbsp; Since SHA1 (for example) is quite slow, this could cause a huge performance penalty.<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en>This limitation can be coded around with some care, however.&nbsp; For example, tree hashes can be computed up-front in parallel as a pre-processing step.&nbsp; Alternatively, a hash function could be chosen based on some heuristic estimate of what would likely lead to the fastest link (based on the percentage of inputs that had a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section, for example).&nbsp; There are other possibilities as well.&nbsp; The important thing is to just be aware of this potential pitfall, and if your links become very slow, you'll know that the first thing you should check is "do all my object files have .debug$H sections?"<o:p></o:p></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en></span></div><div class=MsoNormal><span lang=en>Finally, since a hash is considered to be identical to the original record, we must consider the possibility of collisions.&nbsp; That said, this does not appear to be a serious concern in practice.&nbsp; A single PDB can have a theoretical maximum of 2<sup>32</sup> type records anyway (due to a type index being 4 bytes).&nbsp; The following table shows the expected number of type records needed for a collision to exist as a function of hash size.<o:p></o:p></span></div><div class=MsoNormal><span lang=en></span></div><table border=1 cellpadding=0 cellspacing=0 class=MsoNormalTable style="border-collapse:collapse;border:none;margin-left:5pt;mso-border-alt:solid #000 1pt;mso-border-insideh:1pt solid #000;mso-border-insidev:1pt solid #000;mso-padding-alt:0 5.4pt 0 5.4pt;mso-table-layout-alt:fixed;mso-yfti-tbllook:1536;width:449px"><tbody><tr><td style="background:#6d9eeb;border:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div class=MsoNormal style=line-height:normal;mso-pagination:none><span lang=en>Hash Size (Bytes)<o:p></o:p></span></div></td><td style="background:#e69138;border-left:none;border:solid #000 1pt;mso-border-left-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>Average # of records needed for a collision<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>4<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>82,137<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>6<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>21,027,121<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>8<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>5,382,943,231<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>12<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>3.53 x 10<sup>14<o:p></o:p></sup></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>16<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>2.31 x 10<sup>19</sup><o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>20<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:226.5pt" valign=top width=302><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>1.52 x 10<sup>24</sup><o:p></o:p></span></div></td></tr></tbody></table></div></div><div><span lang=en style=line-height:115%><span style=font-family:inherit>Given that this is strictly for debug information and not generated code, it’s worth thinking about the <i>severity</i> of a collision.&nbsp; We feel that an 8-byte hash is probably acceptable for real world use.</span></span></div><div><span lang=en style=font-family:arial,sans-serif;line-height:115%><br></span></div><h2><span lang=en style=font-family:arial,sans-serif;line-height:115%>Benchmarks</span></h2><div><span style=font-family:inherit>Here we will give some benchmarks on large real world applications (specifically, Chrome and clang).&nbsp; The times presented are <b>only</b> for the linker.&nbsp; gn args for each build of chromium are specified at the end..</span></div><div><span style=font-family:arial,sans-serif><br></span></div><div><table border=1 cellpadding=0 cellspacing=0 class=MsoNormalTable style="border-collapse:collapse;border:none;margin-left:5pt;mso-border-alt:solid #000 1pt;mso-border-insideh:1pt solid #000;mso-border-insidev:1pt solid #000;mso-padding-alt:0 5.4pt 0 5.4pt;mso-table-layout-alt:fixed;mso-yfti-tbllook:1536;width:623px"><tbody><tr style=height:21pt;mso-yfti-firstrow:yes;mso-yfti-irow:0><td rowspan=2 style="background:#6d9eeb;border:solid #000 1pt;height:21pt;padding:5pt;width:82.5pt" valign=top width=110><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><br></div><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><a href=https://www.blogger.com/null></a><a href=https://www.blogger.com/null></a><a href=https://www.blogger.com/null></a><a href=https://www.blogger.com/null></a><a href=https://www.blogger.com/null></a>Toolchain<span lang=en>&nbsp;<o:p></o:p></span></div></td><td rowspan=2 style="background:#6d9eeb;border-left:none;border:solid #000 1pt;height:21pt;mso-border-left-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><br></div><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>Mode<o:p></o:p></span></div></td><td colspan=4 style="background:#f90;border-left:none;border:solid #000 1pt;height:21pt;mso-border-left-alt:solid #000 1pt;padding:5pt;width:274.5pt" valign=top width=366><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>Target<o:p></o:p></span></div></td></tr><tr style=height:21pt;mso-yfti-irow:1><td style="background:#f9cb9c;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;height:21pt;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:75.75pt" valign=top width=101><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>blink_core.dll<o:p></o:p></span></div></td><td style="background:#f9cb9c;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;height:21pt;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:69pt" valign=top width=92><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>content.dll<o:p></o:p></span></div></td><td style="background:#f9cb9c;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;height:21pt;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:66pt" valign=top width=88><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>chrome.dll<o:p></o:p></span></div></td><td style="background:#f9cb9c;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;height:21pt;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:63.75pt" valign=top width=85><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>clang.exe<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:82.5pt" valign=top width=110><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>MSVC<o:p></o:p></span></div></td><td style="background:#a4c2f4;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>/DEBUG:FULL<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:75.75pt" valign=top width=101><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>553.11s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:69pt" valign=top width=92><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>205.45s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:66pt" valign=top width=88><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>507.17s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:63.75pt" valign=top width=85><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>62.45s<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:82.5pt" valign=top width=110><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>MSVC<o:p></o:p></span></div></td><td style="background:#a4c2f4;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>/DEBUG:FASTLINK<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:75.75pt" valign=top width=101><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>116.77s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:69pt" valign=top width=92><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>56.05s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:66pt" valign=top width=88><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>67.80s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:63.75pt" valign=top width=85><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>29.37s<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:82.5pt" valign=top width=110><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>lld-link<o:p></o:p></span></div></td><td style="background:#a4c2f4;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>/DEBUG:FULL<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:75.75pt" valign=top width=101><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>121.17s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:69pt" valign=top width=92><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>42.10s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:66pt" valign=top width=88><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>42.31s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:63.75pt" valign=top width=85><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>24.14s<o:p></o:p></span></div></td></tr><tr><td style="background:#a4c2f4;border-top:none;border:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:82.5pt" valign=top width=110><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>lld-link<o:p></o:p></span></div></td><td style="background:#a4c2f4;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:110.25pt" valign=top width=147><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>/DEBUG:GHASH<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:75.75pt" valign=top width=101><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>88.71s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:69pt" valign=top width=92><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>33.30s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:66pt" valign=top width=88><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>34.76s<o:p></o:p></span></div></td><td style="background:#fce5cd;border-bottom:solid #000 1pt;border-left:none;border-right:solid #000 1pt;border-top:none;mso-border-left-alt:solid #000 1pt;mso-border-top-alt:solid #000 1pt;padding:5pt;width:63.75pt" valign=top width=85><div align=center class=MsoNormal style=line-height:normal;mso-pagination:none;text-align:center><span lang=en>17.99s<o:p></o:p></span></div></td></tr></tbody></table><br><div><!--[if !supportAnnotations]--><br><div><div class=msocomtxt id=_com_6 language=javascript><!--[if !supportAnnotations]--></div><!--[endif]--></div></div></div><div><div class=MsoNormal><span lang=en><span style=font-family:inherit>The numbers here indicate a reduction in link time of up to 30% by enabling /DEBUG:GHASH in lld.<o:p></o:p></span></span></div><div class=MsoNormal><span lang=en><span style=font-family:inherit><br></span></span></div><div class=MsoNormal><span lang=en><span style=font-family:inherit>It's worth mentioning that lld does not yet have support for incremental linking so we could not compare the cost of an incremental link with /DEBUG:GHASH versus MSVC.&nbsp; We still expect incremental linking using MSVC under optimal conditions (e.g. change whitespace in a header file) to produce much faster links than lld is currently able to do.</span></span></div><div class=MsoNormal><br></div><div class=MsoNormal><span lang=en><span style=font-family:inherit>There are several possible avenues for further optimization though, so we will finish up by discussing them.</span><o:p></o:p></span></div><div class=MsoNormal><span lang=en><span style=font-family:inherit><br></span></span></div><h2><span lang=en>Further Improvements</span></h2><div class=MsoNormal><span lang=en>There are several ways to improve the times further, which have yet to be explored.</span></div><div class=MsoNormal><br></div><ol start=1 style=margin-top:0 type=1><li class=MsoNormalCxSpMiddle><span lang=en>Use a smaller or faster hash.&nbsp; We use a 20-byte SHA1 hash.&nbsp; This is not a multiple of cache line size, and in any case the probability of collision is astronomically small even in the largest PDBs, considering that the theoretical limit of a PDB is just under 2^32 possible unique types (due to the 4-byte size of a type index).&nbsp; SHA1 is also notoriously slow.&nbsp; It might be interesting to try, for example, a Blake2 set to output an 8 byte hash.&nbsp; This should give sufficiently low probability of a collision while improving cache performance.&nbsp; The on-disk format is designed with this flexibility in mind, as different hash algorithms can be specified in the header.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Hashes for compilands with missing </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> sections can be computed in parallel before linking.&nbsp; Currently when we encounter an object file without a </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$H</span><span lang=en> section, we must synthesize one in the linker.&nbsp; Our prototype algorithm does this serially for each input.<o:p></o:p></span></li><li class=MsoNormalCxSpMiddle><span lang=en>Symbol records from </span><span lang=en style='font-family:courier new;mso-fareast-font-family:"Courier New"'>.debug$S </span><span lang=en>sections can be merged in parallel.&nbsp; Currently in lld, we first merge type records into the TPI stream, then we iterate symbol records and remap types in each symbol record to correspond to the new type indices.&nbsp; If we merge types from all modules up front, the symbol records (with the exception of global symbols) can be merged in parallel since they get written to independent streams).<o:p></o:p></span></li></ol><h2>Try it out!</h2></div><div>If you're already using clang-cl and lld on Windows today, you can try this out.&nbsp; There are two flags needed to enable this, one for the compiler and one for the linker:</div><div><ol><li>To enable the emission of a .debug$H section by the compiler, you will need to pass the undocumented&nbsp;<span style="font-family:courier new,courier,monospace">-mllvm -emit-codeview-ghash-section</span><span style=font-family:inherit>&nbsp;flag to clang-cl&nbsp; (this flag should go away in the future, once this is considered stable and good enough to be turned on by default).</span></li><li><span style=font-family:inherit>To tell lld to use this information, you will need to pass the </span><span style="font-family:courier new,courier,monospace">/DEBUG:GHASH</span><span style=font-family:inherit>&nbsp;to lld.</span></li></ol><div>Note that this feature is still considered highly experimental, so we're interested in your feedback (llvm-dev@ mailing list, direct email is ok too)&nbsp;and bug reports (bugs.llvm.org).&nbsp;&nbsp;</div><div><br></div></div></span></div></article><section class=post-nav><ul><li><a href=https://blog.llvm.org/posts/2017-09-19-clang-bash-better-auto-completion-is/><i class="fa fa-chevron-circle-left"></i>Clang ♥ bash -- better auto completion is coming to bash</a></li><li><a href=https://blog.llvm.org/posts/2018-02-14-llvm-accepted-to-2018-google-summer-of/>LLVM accepted to 2018 Google Summer of Code! <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.llvm.org/index.xml>Subscribe</a></h6></footer></div><script src=https://blog.llvm.org/js/scripts.js></script></body></html>