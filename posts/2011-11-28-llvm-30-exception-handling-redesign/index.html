<!doctype html><html lang=en><head><title>The LLVM Project Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LLVM Project News and Details from the Trenches"><meta name=author content="Bill Wendling"><meta property="og:title" content="LLVM 3.0 Exception Handling Redesign"><meta property="og:description" content="One of the biggest IR changes in the LLVM 3.0 release is a redesign and reimplementation of the LLVM IR exception handling model. The old model, while it worked for most cases, fell over in some key situations, leading to obscure miscompilations, missed optimizations, and poor compile time."><meta property="og:type" content="article"><meta property="og:url" content="https://new-blog.llvm.org/posts/2011-11-28-llvm-30-exception-handling-redesign/"><meta property="article:published_time" content="2011-11-28T13:16:00+00:00"><meta property="article:modified_time" content="2011-11-28T13:16:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM 3.0 Exception Handling Redesign"><meta name=twitter:description content="One of the biggest IR changes in the LLVM 3.0 release is a redesign and reimplementation of the LLVM IR exception handling model. The old model, while it worked for most cases, fell over in some key situations, leading to obscure miscompilations, missed optimizations, and poor compile time."><meta name=generator content="Hugo 0.68.3"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://new-blog.llvm.org/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://new-blog.llvm.org/css/styles.css></head><body><div id=container><header><h1><a href=https://new-blog.llvm.org/>The LLVM Project Blog</a></h1><ul id=social-media><li><a href=https://www.facebook.com/llvmorg title=Facebook><i class="fab fa-facebook fa-lg"></i></a></li><li><a href=https://github.com/llvm title=GitHub><i class="fab fa-github fa-lg"></i></a></li><li><a href=https://twitter.com/llvmorg title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://www.youtube.com/c/LLVMPROJ title=Youtube><i class="fab fa-youtube fa-lg"></i></a></li></ul><p><em>LLVM Project News and Details from the Trenches</em></p></header><nav><ul><li><a href=https://new-blog.llvm.org/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://new-blog.llvm.org/posts><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://new-blog.llvm.org/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://llvm.org/><i class="fa-li fa fa-lg"></i><span>llvm.org</span></a></li></ul></nav><main><article><h1>LLVM 3.0 Exception Handling Redesign</h1><aside><ul><li><time class=post-date datetime=2011-11-28T13:16:00Z>Nov 28, 2011</time></li><li>Bill Wendling</li><li><em><a href=https://new-blog.llvm.org/tags/new-in-llvm-3.0>#new-in-llvm-3.0</a>
,
<a href=https://new-blog.llvm.org/tags/llvm-ir>#LLVM-IR</a></em></li><li>6 minutes read</li></ul></aside>One of the biggest IR changes in the LLVM 3.0 release is a redesign and reimplementation of the LLVM IR exception handling model. The old model, while it worked for most cases, fell over in some key situations, leading to obscure miscompilations, missed optimizations, and poor compile time. This post talks about the changes in LLVM 3.0 and how to move an existing LLVM front-end to the new design. It assumes some familiarity with the Itanium C++ ABI for exception handling.<a name=more></a><h2>Goals of the exception handling system</h2>Exception handling needs to be a first-class citizen of the LLVM IR. This allows us to manipulate the exception handling information in an intelligent fashion (e.g., during inlining). Also, code generation needs to be able to reliably find a variety of information associated specific <tt>invoke</tt> call (e.g. the personality function for use with a call). Finally, we need to follow the established exception handling ABI to ensure binary compatibility with other compilers.<p>While there are a lot of details to get right for exception handling to work (with regards to the ABI), our goal is to keep LLVM IR as simple to generate and manipulate as possible. By making EH a first-class citizen, the new instructions will have a simple, easily understood syntax and constraints which can be tested to ensure that the IR is correct after each code transformation.<h2>The old exception handling system</h2>The old system used LLVM intrinsics to convey the exception handling information to the code generator. The primary problem with the old system is that there was nothing that bound these intrinsics to the invoke calls that could be unwound through, making code generation fragile, and optimizations like inlining impossible to represent (in the general case).<p>Further, the intrinsics were very difficult for code transformations to maintain and update correctly: we would frequently get exception tables which had incorrect information in them (e.g., specifying that a specific type couldn't propagate past that point when it wasn't specified in the original program). It also couldn't handle "cleanup" situations without a lot of work.<p>Because of normal code motion, the intrinsics, which held the information that the code generator needed to generate the correct tables, could be moved far away from the <tt>invoke</tt> instruction they were associated with. I.e., they could be moved out of the <tt>invoke</tt>'s landingpad. This made code generation of the previous exception handling constructs fragile, and sometimes caused miscompilations of exception handling code, which wasn't acceptable.<p>A final (somewhat theoretical) issue is that the old system only worked with standard personality functions. It would be nearly impossible to use custom personality functions (e.g. that returned 3 registers in a landing pad instead of 2) with it. While we had no specific use case for this, we were unable to use custom personality functions to optimize code size or performance of C++ exceptions.<h2>The LLVM 3.0 Exception Handling System</h2>The backbone of the new exception handling system are the two new instructions <tt>landingpad</tt> and <tt>resume</tt>:<dl><dt><tt><a href=http://llvm.org/docs/LangRef.html#i_landingpad>landingpad</a></tt></dt><dd>Defines a landing pad basic block. It contains all of the information that's needed by the code generator to generate the correct EH tables. It's also required to be the first non-<tt>PHI</tt> instruction in the unwind destination of an invoke instruction. In addition, a landing pad may <em>only</em> be jumped to by the unwind edge of an <tt>invoke</tt> instruction. These constraints ensure that it is always possible to accurately match up the unwind information with an invoke call. It replaces the<tt>@llvm.eh.exception</tt> and <tt>@llvm.eh.selector</tt>intrinsics.</dd><dt><tt><a href=http://llvm.org/docs/LangRef.html#i_resume>resume</a></tt></dt><dd>Causes the current exception to resume propagation up the stack. It replaces the <tt>@llvm.eh.resume</tt> intrinsic.</dd></dl><p>Here is a simple example of what the new syntax looks like. For this program:<p><br><pre><br>  void bar();<br>  void foo() throw (const char *) {<br>    try {<br>      bar();<br>    } catch (int) {<br>    }<br>  }<br></pre><br>The IR looks like this:<br><pre><br>  @_ZTIPKc = external constant i8*<br>  @_ZTIi = external constant i8*<br>  define void @_Z3foov() uwtable ssp {<br>  entry:<br>    invoke void @_Z3barv()<br>            to label %try.cont unwind label %lpad<br><br>  lpad:<br>    <b>%0 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*)<br>                                   catch i8* bitcast (i8** @_ZTIi to i8*)<br>                                   filter [1 x i8*] [i8* bitcast (i8** @_ZTIPKc to i8*)]</b><br>    %1 = extractvalue { i8*, i32 } %0, 0<br>    %2 = extractvalue { i8*, i32 } %0, 1<br>    %3 = tail call i32 @llvm.eh.typeid.for(i8* bitcast (i8** @_ZTIi to i8*)) nounwind<br>    %matches = icmp eq i32 %2, %3<br>    br i1 %matches, label %catch, label %filter.dispatch<br><br>  filter.dispatch:<br>    %ehspec.fails = icmp slt i32 %2, 0<br>    br i1 %ehspec.fails, label %ehspec.unexpected, label %eh.resume<br><br>  ehspec.unexpected:<br>    tail call void @__cxa_call_unexpected(i8* %1) no return<br>    unreachable<br><br>  catch:<br>    %4 = tail call i8* @__cxa_begin_catch(i8* %1) nounwind<br>    tail call void @__cxa_end_catch() nounwind<br>    br label %try.cont<br><br>  try.cont:<br>    ret void<br><br>  eh.resume:<br>    <b>resume { i8*, i32 } %0</b><br>  }<br></pre><br>The <tt>landingpad</tt> instruction specifies the <i>personality function</i>the EH runtime uses, a list of types which it can catch (<tt>int</tt>), and a list of types which <tt>foo</tt> is allowed to throw (<tt>const char *</tt>).<p>The <tt>resume</tt> instruction resumes propagation of the exception if it's not caught and of an allowed type.<h2>Converting to the LLVM 3.0 exception handling system</h2>Converting from the old EH API to the new EH API is rather simple because a lot of complexity has been removed. To generate the EH code in LLVM 2.9, you would have to do something akin to this:<br><pre><br>  Function *ExcIntr =<br>    Intrinsic::getDeclaration(TheModule, Intrinsic::eh_exception);<br>  Function *SlctrIntr =<br>    Intrinsic::getDeclaration(TheModule, Intrinsic::eh_selector);<br>  Function *PersonalityFn =<br>    Function::Create(FunctionType::get(Type::getInt32Ty(Context), true),<br>                     Function::ExternalLinkage,<br>                     "__gxx_personality_v0", TheModule);<br><br>  // The exception pointer.<br>  Value *ExnPtr = Builder.CreateCall(ExcIntr, "exn");<br><br>  // The arguments to the @llvm.eh.selector instruction.<br>  std::vector&lt;Value*&gt; Args;  Args.push_back(ExnPtr);<br>  Args.push_back(Builder.CreateBitCast(PersonalityFn,<br>                                       Type::getInt8PtrTy(Context)));<br><br>  <i>// ... Complex code to add catch types, filters, cleanups, and catch-alls to Args ...</i><br><br>  // The selector call.<br>  Value *Sel = Builder.CreateCall(SlctrIntr, Args, "exn.sel");<br></pre><br>You should instead generate a <tt>landingpad</tt> instruction, that returns an exception object and selector value:<br><pre><br>  LandingPadInst *LPadInst =<br>    Builder.CreateLandingPad(StructType::get(Int8PtrTy, Int32Ty, NULL),<br>                             PersonalityFn, 0);<br>  Value *ExnPtr = Builder.CreateExtractValue(LPadInst, 0);<br>  Value *Sel = Builder.CreateExtractValue(LPadInst, 1);<br></pre><br>It's now trivial to add the individual clauses to the <tt>landingpad</tt>instruction.<br><pre><br>  <b><i>// Adding a catch clause</i></b><br>  Constant *TypeInfo = getTypeInfo();<br>  LPadInst-&gt;addClause(TypeInfo);<br><br>  <b><i>// Adding a C++ catch-all</i></b><br>  LPadInst-&gt;addClause(Constant::getNullValue(Builder.getInt8PtrTy()));<br><br>  <b><i>// Adding a cleanup</i></b><br>  LPadInst-&gt;setCleanup(true);<br><br>  <b><i>// Adding a filter clause</i></b><br>  std::vector&lt;Value*&gt; TypeInfos;<br>  Constant *TypeInfo = getFilterTypeInfo();<br>  TypeInfos.push_back(Builder.CreateBitCast(TypeInfo, Builder.getInt8PtrTy()));<br>  ArrayType *FilterTy = ArrayType::get(Int8PtrTy, TypeInfos.size());<br>  LPadInst-&lt;addClause(ConstantArray::get(FilterTy, TypeInfos));<br></pre><br>Converting from using the <tt>@llvm.eh.resume</tt> intrinsic to the <tt>resume</tt> instruction is trivial. It takes the exception pointer and exception selector values returned by the <tt>landingpad</tt>instruction:<br><pre><br>  Type *UnwindDataTy = StructType::get(Builder.getInt8PtrTy(),<br>                                       Builder.getInt32Ty(), NULL);<br>  Value *UnwindData = UndefValue::get(UnwindDataTy);<br>  Value *ExcPtr = Builder.CreateLoad(getExceptionObjSlot());<br>  Value *ExcSel = Builder.CreateLoad(getExceptionSelSlot());<br>  UnwindData = Builder.CreateInsertValue(UnwindData, ExcPtr, 0, "exc_ptr");<br>  UnwindData = Builder.CreateInsertValue(UnwindData, ExcSel, 1, "exc_sel");<br>  Builder.CreateResume(UnwindData);<br></pre><br><h4>Conclusion</h4>The new EH system now works much better than the old system. It is much less fragile and complex. This makes it easier to understand when you have to read the IR to figure out what's going on. More importantly, it allows us to follow the ABI more closely than before.<p>Better yet, it's rather straight-forward to convert from the old system to the new one. In fact, you may see your code become much simpler! If you're interested in more details and reference information, please see the <a href=http://llvm.org/docs/ExceptionHandling.html>Exception Handling in LLVM IR</a> document.</article><section class=post-nav><ul><li><a href=https://new-blog.llvm.org/posts/2011-11-26-llvm-30-type-system-rewrite/><i class="fa fa-chevron-circle-left"></i>LLVM 3.0 Type System Rewrite</a></li><li><a href=https://new-blog.llvm.org/posts/2011-12-19-llvm-31-vector-changes/>LLVM 3.1 vector changes <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><h6>llvm.org |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://new-blog.llvm.org/index.xml>Subscribe</a></h6></footer></div><script src=https://new-blog.llvm.org/js/scripts.js></script></body></html>